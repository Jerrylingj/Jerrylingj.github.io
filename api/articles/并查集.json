{"title":"并查集","uid":"c18469ab20e7b093d36b4a61728d07eb","slug":"并查集","date":"2024-09-26T05:08:52.000Z","updated":"2024-10-16T14:15:06.104Z","comments":true,"path":"api/articles/并查集.json","cover":"https://th.bing.com/th/id/R.fee079a5295cd84de146adf2ae8fb673?rik=ljoYC8Go8n1K3A&pid=ImgRaw&r=0","content":"<h1 id=\"并查集（Union-Find）\"><a href=\"#并查集（Union-Find）\" class=\"headerlink\" title=\"并查集（Union-Find）\"></a>并查集（Union-Find）</h1><h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p><strong>并查集</strong>是一种高效的数据结构，以<strong>多棵树</strong>的形式存储，每棵树有一个被打上标记的根节点</p>\n<p><strong>主要用途：</strong></p>\n<ul>\n<li>合并两个集合</li>\n<li>查询元素所属的集合</li>\n</ul>\n<p><strong>常见题型：</strong></p>\n<ul>\n<li>朴素并查集</li>\n<li>带权并查集</li>\n<li>维护size并查集</li>\n</ul>\n<h2 id=\"结构\"><a href=\"#结构\" class=\"headerlink\" title=\"结构\"></a>结构</h2><p>并查集通常使用三个数组实现：</p>\n<ul>\n<li><code>p[]</code> <code>(parent)</code>数组：记录每个元素的父节点。</li>\n<li><code>d[]</code> <code>(distanse)</code>数组：记录每个元素到父节点距离</li>\n<li><code>size[]</code>数组：记录每个并查集的大小</li>\n</ul>\n<p><em><strong>ps:虽然并查集在逻辑结构上是一棵棵在同一集合的树，但是存储结构仍可以用普通的数组实现</strong></em></p>\n<h2 id=\"操作\"><a href=\"#操作\" class=\"headerlink\" title=\"操作\"></a>操作</h2><h3 id=\"1-建立\"><a href=\"#1-建立\" class=\"headerlink\" title=\"1.建立\"></a>1.建立</h3><p>初始化并查集</p>\n<p><strong>并查集根节点<code>root</code>:的标记方式<code>p[root] = root</code></strong></p>\n<p>表示根节点的父节点就是自己</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 一开始每个节点各自为营</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i ++ )</span><br><span class=\"line\">\t\tp[i] = i;</span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-查找\"><a href=\"#2-查找\" class=\"headerlink\" title=\"2.查找\"></a>2.查找</h3><p>查找元素 <code>x</code> 所在集合的根节点：</p>\n<p>这里有个优化，利用<strong>递归</strong>在查找的时候就直接把每个节点的<strong>父节点压缩向了祖宗节点</strong>，此时距离<strong>d</strong>也更新为了到<strong>父节点(祖宗节点)的距离</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">find</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p[x] != x) p[x] = <span class=\"built_in\">find</span>(p[x]);</span><br><span class=\"line\">    <span class=\"comment\">// p[x]效果为找x的祖宗节点</span></span><br><span class=\"line\">    <span class=\"comment\">// 这里调用p[x] = find(p[x])直接让x的父节点指向了p[x]的祖宗节点</span></span><br><span class=\"line\">    <span class=\"comment\">// 经过层层递归会最终指向整棵树的根节点</span></span><br><span class=\"line\">    <span class=\"type\">int</span> root = <span class=\"built_in\">find</span>(p[x]); </span><br><span class=\"line\">    <span class=\"comment\">// 先要存root是因为只有先跑find()才能让d[p[x]]变为p[x]到祖宗节点的距离</span></span><br><span class=\"line\">    d[x] += d[p[x]];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"3-合并\"><a href=\"#3-合并\" class=\"headerlink\" title=\"3.合并\"></a>3.合并</h3><p>合并两棵树：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">merge</span><span class=\"params\">(<span class=\"type\">int</span> x, <span class=\"type\">int</span> y)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 找出两棵树的根节点</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> px = <span class=\"built_in\">find</span>(x), py = <span class=\"built_in\">find</span>(y);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// 根节点不同才需要合并</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (px != py) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">\t\tp[px] = py;</span><br><span class=\"line\">        size[py] += size[px];</span><br><span class=\"line\">        <span class=\"comment\">// 可能还需要对d[px]进行操作,具体情形依题目而定</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>至此，并查集的基本操作均已介绍完毕，操作简洁作用大，用处这么大的数据结构上哪里找呀~</strong></p>\n<p><strong>来几道例题尝试尝试~</strong></p>\n<h2 id=\"例题\"><a href=\"#例题\" class=\"headerlink\" title=\"例题\"></a>例题</h2><p><strong>朴素并查集</strong></p>\n<p><strong><a href=\"https://www.luogu.com.cn/problem/P3367\">洛谷 P3367 【模板】并查集</a></strong></p>\n<br>\n\n<p><strong>维护size的并查集</strong></p>\n<p><strong><a href=\"https://www.luogu.com.cn/problem/P1455\">洛谷P1455 搭配购买</a></strong></p>\n<br>\n\n<p><strong>维护到祖宗节点距离的并查集(带权并查集)</strong></p>\n<p> <strong><a href=\"https://www.luogu.com.cn/problem/P1196\">洛谷P1196 银河英雄传说</a></strong></p>\n<p> <strong><a href=\"https://www.luogu.com.cn/problem/P2024\">洛谷P2024食物链 </a></strong></p>\n","text":"并查集（Union-Find）概述并查集是一种高效的数据结构，以多棵树的形式存储，每棵树有一个被打上标记的根节点 主要用途： 合并两个集合 查询元素所属的集合 ...","permalink":"/post/并查集","photos":[],"count_time":{"symbolsCount":"1.2k","symbolsTime":"1 mins."},"categories":[{"name":"数据结构","slug":"数据结构","count":5,"path":"api/categories/数据结构.json"}],"tags":[{"name":"并查集","slug":"并查集","count":1,"path":"api/tags/并查集.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%B9%B6%E6%9F%A5%E9%9B%86%EF%BC%88Union-Find%EF%BC%89\"><span class=\"toc-text\">并查集（Union-Find）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">概述</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">结构</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">操作</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E5%BB%BA%E7%AB%8B\"><span class=\"toc-text\">1.建立</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E6%9F%A5%E6%89%BE\"><span class=\"toc-text\">2.查找</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E5%90%88%E5%B9%B6\"><span class=\"toc-text\">3.合并</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BE%8B%E9%A2%98\"><span class=\"toc-text\">例题</span></a></li></ol></li></ol>","author":{"name":"Jerry","slug":"blog-author","avatar":"https://th.bing.com/th/id/R.7a1adf834060c41d2d476af2a5e322fd?rik=N35%2fqYx%2fr4RSog&riu=http%3a%2f%2fimg.keaiming.com%2fuploads%2fallimg%2f2020090111%2fsvaseyx4m3v.jpg&ehk=EBywhQ9emNaCt5dbn%2b%2fxbUc5yK42H8b%2ffRDsZKdVI6I%3d&risl=&pid=ImgRaw&r=0","link":"/","description":"<strong>Keep a single spark to start a prairie fire.</strong>","socials":{"github":"https://github.com/Jerrylingj","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/2301_79143568?spm=1010.2135.3001.5343","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"单调队列与单调栈","uid":"f897c3d44f1ea027302ceab6694fc628","slug":"单调队列与单调栈","date":"2024-09-26T05:09:03.000Z","updated":"2024-10-04T06:53:56.778Z","comments":true,"path":"api/articles/单调队列与单调栈.json","cover":" https://wallpaperaccess.com/full/1217432.jpg","text":" .image-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(300...","permalink":"/post/单调队列与单调栈","photos":[],"count_time":{"symbolsCount":"4.1k","symbolsTime":"4 mins."},"categories":[{"name":"数据结构","slug":"数据结构","count":5,"path":"api/categories/数据结构.json"}],"tags":[{"name":"单调队列","slug":"单调队列","count":1,"path":"api/tags/单调队列.json"},{"name":"单调栈","slug":"单调栈","count":1,"path":"api/tags/单调栈.json"}],"author":{"name":"Jerry","slug":"blog-author","avatar":"https://th.bing.com/th/id/R.7a1adf834060c41d2d476af2a5e322fd?rik=N35%2fqYx%2fr4RSog&riu=http%3a%2f%2fimg.keaiming.com%2fuploads%2fallimg%2f2020090111%2fsvaseyx4m3v.jpg&ehk=EBywhQ9emNaCt5dbn%2b%2fxbUc5yK42H8b%2ffRDsZKdVI6I%3d&risl=&pid=ImgRaw&r=0","link":"/","description":"<strong>Keep a single spark to start a prairie fire.</strong>","socials":{"github":"https://github.com/Jerrylingj","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/2301_79143568?spm=1010.2135.3001.5343","juejin":"","customs":{}}}},"next_post":{"title":"线段树","uid":"a448dfd8ebb4408d1633f0dff8411f1c","slug":"线段树","date":"2024-09-26T05:05:40.000Z","updated":"2024-09-26T05:06:45.615Z","comments":true,"path":"api/articles/线段树.json","cover":"https://th.bing.com/th/id/R.fa3e78819de038c741076b8fddc6d160?rik=SKPOERrrNiyH%2fg&pid=ImgRaw&r=0","text":"线段树（Segment Tree）概述线段树是一种高效的数据结构，用于解决区间查询和更新问题。它能够在 (O(\\log n)) 时间复杂度内完成以下操作： 查询...","permalink":"/post/线段树","photos":[],"count_time":{"symbolsCount":543,"symbolsTime":"1 mins."},"categories":[{"name":"数据结构","slug":"数据结构","count":5,"path":"api/categories/数据结构.json"}],"tags":[{"name":"线段树","slug":"线段树","count":1,"path":"api/tags/线段树.json"}],"author":{"name":"Jerry","slug":"blog-author","avatar":"https://th.bing.com/th/id/R.7a1adf834060c41d2d476af2a5e322fd?rik=N35%2fqYx%2fr4RSog&riu=http%3a%2f%2fimg.keaiming.com%2fuploads%2fallimg%2f2020090111%2fsvaseyx4m3v.jpg&ehk=EBywhQ9emNaCt5dbn%2b%2fxbUc5yK42H8b%2ffRDsZKdVI6I%3d&risl=&pid=ImgRaw&r=0","link":"/","description":"<strong>Keep a single spark to start a prairie fire.</strong>","socials":{"github":"https://github.com/Jerrylingj","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/2301_79143568?spm=1010.2135.3001.5343","juejin":"","customs":{}}}}}