[{"id":"d2bcea86278ef526e533e46062b014d6","title":"数据结构与算法--week8","content":"老师还是挺仁慈的，题目没考什么难的东西，基本都是模拟\n常年当AI战神的本蒟蒻非常开心 φ(゜▽゜*)♪\n1. 简单字符串操作\n题目\n读取输入字符串    和整数  ，把字符串   前面的   个字符转移到字符串的尾部，输出结果字符串。\n输入样例1\n1abcdefg 2\n\n输出样例1\n1cdefgab\n\n输入样例2\n1lrloseumgh 6\n\n输出样例2\n1umghlrlose\n\n\n\n思路\n直接把前面几个字符拎到后面就行\n123456789101112131415#include &lt;iostream&gt;using namespace std;int main(){    int n;\tstring s;\t\tcin &gt;&gt; s &gt;&gt; n;\ts = s.substr(n) + s.substr(0, n);\tcout &lt;&lt; s &lt;&lt; endl;\t\treturn 0;}\n\n\n\n2. 计算比赛得分\n题目\n题目描述\n你现在是一场采用特殊赛制比赛的记录员。这场比赛由若干回合组成，过去几回合的得分可能会影响以后几回合的得分。\n比赛开始时，记录是空白的。你会得到一个记录操作的字符串列表 ops，其中 ops[i] 是你需要记录的第 i 项操作，ops 遵循下述规则：\n\n整数 x - 表示本回合新获得分数 x\n+ - 表示本回合新获得的得分是前两次得分的总和。题目数据保证记录此操作时前面总是存在两个有效的分数。\nD - 表示本回合新获得的得分是前一次得分的两倍。题目数据保证记录此操作时前面总是存在一个有效的分数。\nC - 表示前一次得分无效，将其从记录中移除。题目数据保证记录此操作时前面总是存在一个有效的分数。\n若列表中只剩下整数，则默认对剩余整数做求和操作。\n\n输入包含两行，第一行为字符串列表ops的长度n，第二行为n个字符串。请输出计算得到的最终得分。\n样例1\n1234567891011121314输入：5 5 2 C D +输出：30解释：5 - 记录加 5 ，记录现在是 [5]2 - 记录加 2 ，记录现在是 [5, 2]C - 使前一次得分的记录无效并将其移除，记录现在是 [5].D - 记录加 2 * 5 = 10 ，记录现在是 [5, 10].+ - 记录加 5 + 10 = 15 ，记录现在是 [5, 10, 15].所有得分的总和 5 + 10 + 15 = 30\n\n样例2\n1234567891011121314151617输入：85 -2 4 C D 9 + +输出：27解释：5 - 记录加 5 ，记录现在是 [5]-2 - 记录加 -2 ，记录现在是 [5, -2]4 - 记录加 4 ，记录现在是 [5, -2, 4]C - 使前一次得分的记录无效并将其移除，记录现在是 [5, -2]D - 记录加 2 * -2 = -4 ，记录现在是 [5, -2, -4]9 - 记录加 9 ，记录现在是 [5, -2, -4, 9]+ - 记录加 -4 + 9 = 5 ，记录现在是 [5, -2, -4, 9, 5]+ - 记录加 9 + 5 = 14 ，记录现在是 [5, -2, -4, 9, 5, 14]所有得分的总和 5 + -2 + -4 + 9 + 5 + 14 = 27\n\n样例3\n123456输入：213 4输出：17\n\n\n\n思路\n可以用vector数组存每局比分，然后相加即可\n注意比分有可能是负数，需要特别处理\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;vector&gt;using namespace std;int n, res;vector&lt;int&gt; num;int main(){    cin &gt;&gt; n;    while (n -- )    {        string c;        cin &gt;&gt; c;        // 数字        if (isdigit(c[0]) || c[0] == '-')        {            // 负数            if (c[0] == '-')            {                int i = 1, dig = 0;                while (i &lt; c.size() &amp;&amp; isdigit(c[i])) dig = dig * 10 + c[i] - '0', i ++ ;                num.push_back(-dig);            }            // 正数            else             {                int i = 0, dig = 0;                while (i &lt; c.size() &amp;&amp; isdigit(c[i])) dig = dig * 10 + c[i] - '0', i ++ ;                num.push_back(dig);            }        }        // 前面2局得分和        else if (c == \"+\")        {            int t = num[num.size() - 2] + num[num.size() - 1];            num.push_back(t);        }        // 上局比分×2        else if (c == \"D\") num.push_back(num[num.size() - 1] * 2);        else if (c == \"C\") num.pop_back();    }    // 统计总分    for (int i = 0; i &lt; num.size(); i ++ ) res += num[i];    cout &lt;&lt; res &lt;&lt; endl;        return 0;}\n\n\n\n\n\n3. 环形链表\n题目\n给定一个链表，判断链表中是否有环。\n链表有环的情况：\n\n\n请实现头文件 has_cycle.h 中的 hasCycle 函数。\nhas_cycle.h\n123456789101112131415#ifndef HAS_CYCLE_H_#define HAS_CYCLE_H_#include &lt;vector&gt;using namespace std; struct ListNode {     int val;     ListNode *next;     ListNode(int x) : val(x), next(nullptr) {} };bool hasCycle(ListNode *head);#endif // !HAS_CYCLE_H_\n\n\n\n思路\n快慢指针，慢指针一次走1步，快指针一次走2步，如果无环，快指针会到nullptr；如果有环，快指针会追上慢指针\n丢一个while循环，判断循环结束条件即可知有无环\n123456789101112131415161718#include &lt;iostream&gt;#include \"has_cycle.h\"bool hasCycle(ListNode *head){    ListNode* p = head; // 慢指针    ListNode* q = head; // 快指针    while (p == head || p != q &amp;&amp; p &amp;&amp; q)    {        p = p-&gt;next;        q = q-&gt;next;        if (q) q = q-&gt;next;    }    if (p == q) return true; // 相遇    return false;            // 未相遇}\n\n\n\n\n\n4. 卡牌排序\n题目\n问题描述\n牌组中的每张卡牌都对应有一个唯一的整数。\n最初，这些卡牌在牌组里是正面朝下的（即，未显示状态）。\n现在，重复执行以下步骤，直到显示所有卡牌为止：\n\n从牌组顶部抽一张牌，显示它，然后将其从牌组中移出。\n如果牌组中仍有牌，则将下一张处于牌组顶部的牌放在牌组的底部。\n如果仍有未显示的牌，那么返回步骤 1。否则，停止行动。\n\n输入包括两行，第一行为卡牌数量n，第二行为n个整数。请输出能以递增顺序显示卡牌的牌组顺序。答案中的第一张牌被认为处于牌堆顶部。\n样例输入\n12717 13 11 2 3 5 7\n\n样例输出\n12,13,3,11,5,17,7\n\n解释\n读取得到的牌组为  （这个顺序不重要），然后将其重新排序。重新排序后，牌组以  开始，其中  位于牌组的顶部。我们显示 ，然后将 13 移到底部。牌组现在是  。我们显示  ，并将 11 移到底部。牌组现在是 。我们显示  ，然后将 17 移到底部。牌组现在是 。我们显示  ，并将  移到底部。牌组现在是 。我们显示  ，然后将  移到底部。牌组现在是 。我们展示 ，然后将  移到底部。牌组现在是  。我们显示 。因此所有卡片都是按递增顺序排列显示的。\n\n\n思路\n设确定了最终顺序的数组为  ，先用队列模拟整个过程，得到最后的显示顺序 \n  表示第  张显示的牌  ，只需用一个  存储  的映射即可得到  \n注意输出用,间隔\n123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;map&gt;using namespace std;int n;int num[1000];int main(){    cin &gt;&gt; n;    for (int i = 1; i &lt;= n; i ++ ) cin &gt;&gt; num[i];    sort(num + 1, num + 1 + n);    // 模拟过程,得到q'    queue&lt;int&gt; q;    for (int i = 1; i &lt;= n; i ++ ) q.push(i);     vector&lt;int&gt; q1;    while (q.size())    {        auto t = q.front();        q.pop();\t\t        //cout &lt;&lt; t &lt;&lt; endl; 调试用                q1.push_back(t);        if (q.size()) q.push(q.front()), q.pop();    }    // cout &lt;&lt; endl;    // 获取i-&gt;q[j]    map&lt;int, int&gt; mp;    for (int i = 1; i &lt;= n; i ++ )        mp[q1[i - 1]] = num[i];\t    // 输出    for (int i = 1; i &lt; n; i ++ ) cout &lt;&lt; mp[i] &lt;&lt; ',';    cout &lt;&lt; mp[n];    return 0;}\n\n\n\n5. 多项式加法\n题目\n问题\n假定多项式按降幂排列， 并用其系数指数对的序列表示，试实现多项式的加法。\n输入\n第一行是测试样例数n, 接下来是n个测试样例。每个测试样例包含两个多项式，每个多项式的第一行是一个非负整数，表示多项式的项数，然后是按照降幂排列的多项式各项系数及指数对，系数和指数间用空格分隔。\n输出\n对每个测试样例，计算并输出两个多项式的和，第一行输出多项式和的项数，然后按照降幂排列输出各项系数和指数对，每对系数和指数各占一行，中间用一个空格分隔。\n输入样例\n12345678910111213221 2-1 0031 22 19 03-1 2-1 1-8 0\n\n输出样例\n12345621 2-1 021 11 0\n\n\n\n思路\n难在读题，大概是这个意思，  组样例，每组  个多项式\n多项式：输入 ，有  行；每一行输入系数和次数\n然后把两个多项式相加即可\n用一个数组  存储最后结果，  表示  系数为  \n12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;int main() {    int T;    cin &gt;&gt; T;    while (T--)     {        // 存储每组结果        int s[1000];        memset(s, 0, sizeof(s));        // 2个多项式        for (int p = 0; p &lt; 2; p++)         {            int n;            cin &gt;&gt; n;            for (int i = 0; i &lt; n; i++)             {                int x, v;                cin &gt;&gt; x &gt;&gt; v;                s[v] += x;             }        }        // 统计项数        int res = 0;        for (int i = 0; i &lt; 1000; i ++ )             if (s[i] != 0) res++;        cout &lt;&lt; res &lt;&lt; endl;        // 输出每一项        for (int i = 999; i &gt;= 0; i -- )             if (s[i] != 0)                 cout &lt;&lt; s[i] &lt;&lt; \" \" &lt;&lt; i &lt;&lt; endl;    }    return 0;}\n\n","slug":"数据结构与算法--week8","date":"2024-10-31T07:06:35.000Z","categories_index":"算法","tags_index":"字符串,链表,模拟","author_index":"Jerry"},{"id":"c4f1d9b0ea2dfb547d6ac2c3ff859913","title":"数据结构与算法--week3","content":"1.两个链表的第大K位数\n题目\n题目描述\n给定两个单链表，找出其第K大的数。\n输入：k表示第k大的数，两个单链表（无重复数字）。\n输出：第k大的数的结点。\n结构体：\n123456struct Node{    Node* next;    int value;    Node(int val):value(val),next(nullptr){}};\n\n样例输入\n12377 3 5 9 28 1 6 10 4\n\n样例输出\n14\n\n要求完成的函数\n1Node* FindKthBigElementInTwoList(Node* List1, Node* List2, int k);\n\n需要添加到function.cpp的依赖文件：function.h\nfunction.h\n123#include \"helper.h\"Node* FindKthBigElementInTwoList(Node* List1, Node* List2, int k);\n\n\n\n思路\n暴力把所有数读进vector数组里再排序即可，复杂度  \n1234567891011121314151617181920212223#include &lt;iostream&gt;#include \"function.h\"#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;Node* FindKthBigElementInTwoList(Node* List1, Node* List2, int k){\tNode* p1 = List1;\tNode* p2 = List2;\tvector&lt;Node*&gt; alls;\t// 存储所有结点\t\twhile (p1 != nullptr)\t\talls.push_back(p1), p1 = p1-&gt;next;\twhile (p2 != nullptr)\t\talls.push_back(p2), p2 = p2-&gt;next;\t\t    // 按值降序排序\tsort(alls.begin(), alls.end(), [](Node* a, Node* b) {return a-&gt;value &gt; b-&gt;value;});\t\treturn alls[k - 1];}\n\n\n\n2.移除重复节点\n题目\n题目描述\n编写代码，移除未排序链表中的重复节点。保留最开始出现的节点。\n示例1\n输入\n1[1,2,3,3,2,1]\n\n输出\n1[1,2,3]\n\n示例2\n输入\n1[1,1,1,1,2]\n\n输出\n1[1,2]\n\n要求完成的函数\n1Node* removeDuplicateNodes(Node* head)\n\n注意\n需要添加到answer.cpp的依赖文件：List.h\nList.h\n1234567891011#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;struct Node{    Node* next;    int value;    Node(int val):value(val),next(nullptr){}};Node* removeDuplicateNodes(Node* h);\n\n\n\n思路\n暴力，每次把后面的所有重复元素都删掉\n12345678910111213141516171819202122232425#include \"List.h\"Node* removeDuplicateNodes(Node* h){    Node* p1 = h;        while (p1 != nullptr)    {        // 把所有值和p1一样的都删了        Node* pre = p1;        Node* cur = p1-&gt;next;                while (cur != nullptr)        {            if (cur-&gt;value == p1-&gt;value)                pre-&gt;next = cur-&gt;next, delete cur, cur = pre-&gt;next;            else                 pre = cur, cur = cur-&gt;next;        }                p1 = p1-&gt;next;\t}        return h;}\n\n\n\n3.链表交点\n题目\n问题描述\n找到两个链表的相交节点\n123456struct linkNode {    int val;    linkNode *next;    linkNode(int x) : val(x), next(nullptr) {}};\n\n你所需实现的函数为\n1linkNode *getIntersectionNode(linkNode *headA, linkNode *headB);\n\n返回节点\n\n请记得#include\"linkNode.h\"。\nNULL不是关键字，使用需要头文件cstddef，建议使用nullptr。\n需要找到的是两个链表的相交节点，而不是值相同的节点（见样例2）。\n\n输入样例1\n\n\n输出样例1\n13\n\n输入样例2\n\n\n输出样例2\n13\n\nListNode.h\n12345678910111213#ifndef linkNode_h#define linkNode_h struct linkNode {     int val;     linkNode *next;     linkNode(int x) : val(x), next(nullptr) {} };linkNode *getIntersectionNode(linkNode *headA, linkNode *headB);#endif /* linkNode_h */\n\n\n\n思路\n假设公共结点为  的第  号， 的第  号，从两个链表头开始走，每次两个指针均向后走一格，走到末尾后回到链表头，即把链表视作循环链表，容易发现，如果两个链表有公共结点，两个指针必将在有限轮次中第一次相遇在链表的第一个公共结点\n所以只需无脑放两个指针走，相遇后就输出即可\n12345678910111213141516171819#include &lt;iostream&gt;#include \"linkNode.h\"using namespace std;linkNode *getIntersectionNode(linkNode *headA, linkNode *headB){    linkNode* p1 = headA;    linkNode* p2 = headB;            while (p1 != p2)     {        // 不相遇就继续走        p1 = (p1 == nullptr) ? headB : p1-&gt;next;        p2 = (p2 == nullptr) ? headA : p2-&gt;next;    }        return p1;}\n\n\n\n4.链表分区\n题目\n题目描述\n下面所给的是链表节点的结构，给定一个链表和一个值  ，对其进行分区，使得节点值小于  的节点放在前面，大于等于  的节点放在后面，保持每个分区节点的原始顺序：\n12345678910struct ListNode {\tint val;\tListNode *next;\tListNode(){\t\tval=0;\t\tnext=NULL;\t}\tListNode(int x) : val(x), next(NULL) {}\t~ListNode(){}};\n\n上述结构定义在头文件ListNode.h中，而你所需实现的函数为：\n1ListNode* partList(ListNode* head, int x);\n\n提示：请记得将头文件包含进去，即 #include\"ListNode.h\" 。\n示例\n原链表：5-&gt;7-&gt;44-&gt;1-&gt;35x = 10\n分区后的链表：5-&gt;7-&gt;1-&gt;44-&gt;35\n注意事项\n你只需写出partList函数实现即可，不用提交main函数。\nListNode.h\n1234567891011121314151617#ifndef ListNode_h#define ListNode_h#include&lt;iostream&gt;using namespace std;struct ListNode { int val; ListNode *next; ListNode(){  val=0;  next=NULL; } ListNode(int x) : val(x), next(NULL) {} ~ListNode(){}};#endif\n\n\n\n思路\n从前往后扫，小于  的放在链表  ，大于等于  的放在链表  ，然后再拼接  即可\n细节，放两个虚拟头结点，防止出现nullptr取next的错误\n1234567891011121314151617181920212223242526272829303132333435#include \"ListNode.h\"ListNode* partList(ListNode* head, int x){    ListNode* head1 = new ListNode(0);     ListNode* head2 = new ListNode(0);    ListNode* p1 = head1;    ListNode* p2 = head2;    while (head != nullptr)    {        if (head-&gt;val &lt; x)        {            p1-&gt;next = head;            p1 = p1-&gt;next;        }        else         {            p2-&gt;next = head;            p2 = p2-&gt;next;        }        head = head-&gt;next;    }\t// 把末尾结点原有的关系切断    p1-&gt;next = nullptr;    p2-&gt;next = nullptr;        // 拼接两个链表    p1-&gt;next = head2-&gt;next;\t// head1是虚拟的头结点,head1-&gt;next才是头    return head1-&gt;next;}\n\n\n\n5.最少纸币组合\n题目\n问题描述\n小明想要买一个玩具，爸爸为了考验他，将一系列面值的纸币按顺序排放，玩具的价格为  ，爸爸让小明从这一堆排列好的纸币中找出和大于等于玩具价格并且连续排列的纸币，并要求这个找出的序列长度是其中最小的，你能帮小明找出这个最小长度是多少吗。（要求时间复杂度尽可能小 ）第一行输入玩具价格  以及纸币数量  ，第二行输入按顺序排放的纸币面值。输出最小的达标长度。如果不存在则返回  。\n输入样例 \n127 62 3 1 2 4 3\n\n输出样例 \n12（4,3是其中长度最小的硬币组合）\n\n\n\n思路\n法1：前缀和 + 二分，复杂度  \n快速求连续一段的纸币总和（片段和）  利用前缀和\n判断是否有更短的长度  二分，check成功就搜更短的，直到搜到能满足的最短的长度\n12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;using namespace std;const int N = 1000;int n, m;int a[N];bool check(int x){    for (int i = 0; i + x &lt;= n; i ++ )        if (a[i + x] - a[i] &gt;= m)            return true;    return false;}int main(){    cin &gt;&gt; m &gt;&gt; n;    for (int i = 1; i &lt;= n; i ++ )        cin &gt;&gt; a[i];    for (int i = 1; i &lt;= n; i ++ )        a[i] += a[i - 1];  // 前缀和    int l = 1, r = n + 1;  // 为了判断无解的情况，右边界多设置了一位    while (l &lt; r)    {        int mid = l + r &gt;&gt; 1;        if (check(mid)) r = mid;         else l = mid + 1;      }    if (r == n  + 1) cout &lt;&lt; 0 &lt;&lt; endl;  // 无解    else cout &lt;&lt; l &lt;&lt; endl;  // 输出最小的满足条件的长度    return 0;}\n\n\n\n法2：单调队列，复杂度 \n这题就是专门设计给滑动窗口的\n","slug":"数据结构与算法--week3","date":"2024-10-28T02:14:54.000Z","categories_index":"算法","tags_index":"二分,前缀和,链表,滑动窗口","author_index":"Jerry"},{"id":"9c3316028136ec33d52d70d3c0c29141","title":"数据结构与算法--week1","content":"第一周的题目比较简单，题解的撰述写的比较简洁\n1.Two Sum\n题目\n问题描述\n输入一个含  个整数的数组  ，以及一个目标整数  ，在数组中找到两个数，使得它们的和等于  ，返回这两个数在数组中的索引。假设所有输入都存在输出且输出唯一。\n输入样例 \n2 7 11 15 4 7 26 77 88 1566\n输出样例 \n0 4\n\n\n思路\n法1：暴力，复杂度 \n123456789101112131415161718192021222324// 暴力枚举#include &lt;iostream&gt;using namespace std;int a[10];int x;int main(){    for (int i = 0; i &lt; 10; i ++ ) cin &gt;&gt; a[i];    cin &gt;&gt; x;    for (int i = 0; i &lt; 10; i ++ )        for (int j = i + 1; j &lt; 10; j ++ )            if (a[i] + a[j] == x)            {                cout &lt;&lt; i &lt;&lt; \" \" &lt;&lt; j &lt;&lt; endl;                break;            }    return 0;}\n\n\n\n法2：map映射,复杂度 \n1234567891011121314151617181920212223242526// map映射#include &lt;iostream&gt;#include &lt;map&gt;using namespace std;int a[10];int x;map&lt;int, int&gt; mp; // 值映射向下标int main(){\tfor (int i = 0; i &lt; 10; i ++ ) cin &gt;&gt; a[i], mp[a[i]] = i;\t\tcin &gt;&gt; x;\t\tfor (int i = 0; i &lt; 10; i ++ )\t\tif (mp[x - a[i]])\t\t{            // 另一半在\t\t\tcout &lt;&lt; i &lt;&lt; \" \" &lt;&lt; mp[x - a[i]] &lt;&lt; endl;\t\t\tbreak;\t\t}\t\t\treturn 0;}\n\n\n\n2.字符串中的单词反转\n题目\n问题描述\n给定一个字符串，你需要颠倒一个句子中每个单词中的字符顺序，同时保留空格和初始单词顺序。\n输入样例\n1Let's take the contest\n\n输出样例\n1s'teL ekat eht tsetnoc\n\n\n\n思路\n每次读字符串都读到空格停，相当于一次读一个单词，每次反转单词即可，复杂度  \n12345678910111213#include&lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;string s;int main(){\twhile (cin &gt;&gt; s) reverse(s.begin(), s.end()), cout &lt;&lt; s &lt;&lt; \" \";\t\treturn 0;}\n\n\n\n3.同24.鲜花的种植\n题目\n问题描述\n假设你有一个长的花坛，其中一些地块种植着花，另一些没有。 然而，花不能种植在相邻的地块否则他们会争取水导致两者都死亡。给定一个花坛（表示为包含  和  的数组，其中  表示没有种花， 表示种植着花）以及数字  。如果  个新鲜花还可以种植在其中则返回真，否则返回假。\n输入格式\n第一行输入数字  ，表示花坛的地块数目，第二行输入花坛目前的状态（用  ,  ）表示，第三行输入还需要种植的花的数目  。\n输出格式\n为每个测试用例单独输出一行。\n输入样例1\n12351 0 0 0 11\n\n输出样例1\n11\n\n输入样例2\n12351 0 1 0 11\n\n输出样例2\n10\n\n\n\n思路\n计算最大可再容纳的花朵数即可，复杂度  \n123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;using namespace std;const int N = 1e3 + 10;int n, m;int a[N];int st[N]; // st[i] = 0,可; st[i] = 1,不可int main(){\tcin &gt;&gt; n;\tfor (int i = 1; i &lt;= n; i ++ ) cin &gt;&gt; a[i];\tcin &gt;&gt; m;\t\t// 把不可种的地方划出来\tfor (int i = 1; i &lt;= n; i ++ )\t\tif (a[i])\t\t{\t\t\tst[i] |= 1;\t\t\tif (i - 1 &gt;= 1) st[i - 1] |= 1;\t\t\tif (i + 1 &lt;= n) st[i + 1] |= 1;\t\t}\t\t// 统计\tfor (int i = 1; i &lt;= n; i ++ )\t\tif (!st[i]) m -- ;\t\t// m &lt;= 0,都种完了\tcout &lt;&lt; (m &lt;= 0);\t\treturn 0;}\n\n\n\n5.战利品的最高价值\n题目\n问题描述 \n小明喜欢玩RPG游戏，有一天他进行到奖励关卡，关卡里有一个  的棋盘，上面放着  个价值不等的战利品，每个格子放置一个并有对应的价值，小明要从左上角开始游戏，每次只能向下或者向右移动一步，到达右下角停止，所经过的格子的战利品小明都能拿到，请设计一个算法使小明能获得的战利品总价值最高。输入一个二维数组，每个元素为对应格子的战利品价值，返回能获得的最大价值。\n输入样例 \n12341 10 3 812 2 9 65 7 4 113 7 16 5\n\n输出样例 \n153（1+12+5+7+7+16+5=53）\n\n\n\n思路\n法1：\n爆搜，维护全局最大值即可\n12345678910111213141516171819202122232425262728293031323334353637383940414243// 爆搜#include &lt;iostream&gt;using namespace std;int res = 0;int g[4][4]; \t// 存地图int dx[] = {0, 1}, dy[] = {1, 0}; // 两个移动方向void dfs(int x,int y, int cur){\t// 走向(x, y),当前价值cur\tcur += g[x][y]; // 捡起来        // 维护全局最大值    if (x == 3 &amp;&amp; y == 3)    {        res = max(cur, res);        return;    }        for (int i = 0; i &lt; 2; i ++ )    {        int x1 = x + dx[i], y1 = y + dy[i];                // 下一步位置合法, 走过去        if (x1 &gt;= 0 &amp;&amp; x1 &lt; 4 &amp;&amp; y1 &gt;= 0 &amp;&amp; y1 &lt; 4) dfs(x1, y1, cur);    }}int main(){    for (int i = 0; i &lt; 4; i ++ )        for (int j = 0; j &lt; 4; j ++ )            cin &gt;&gt; g[i][j];        dfs(0, 0, 0);        cout &lt;&lt; res &lt;&lt; endl;        return 0;}\n\n\n\n法2：线性DP\n状态表示：  走到  的最大价值\n状态计算：上一步，向下： ，向右：  \n\n12345678910111213141516171819202122// 线性DP#include &lt;iostream&gt;using namespace std;int g[5][5];int dp[5][5];int main(){\tfor (int i = 1; i &lt;= 4; i ++ )\t\tfor (int j = 1; j &lt;= 4; j ++ )\t\t\tcin &gt;&gt; g[i][j];\t\t\t\tfor (int i = 1; i &lt;= 4; i ++ )\t\tfor (int j = 1; j &lt;= 4; j ++ )\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + g[i][j];\t\tcout &lt;&lt; dp[4][4] &lt;&lt; endl;\t\treturn 0;}\n\n","slug":"数据结构与算法--week1","date":"2024-10-27T15:34:12.000Z","categories_index":"算法","tags_index":"线性DP,dfs","author_index":"Jerry"},{"id":"4eca039891b4a6833a730a5615b5573d","title":"数据结构与算法--week7","content":"1.无重复最长子串\n题目\n问题描述\n给定一个字符串，请你找出其中不含有重复字符的最长子串的长度。\n输入样例1\n1pwwkew\n\n输出样例1\n13\n\n输入样例2\n1abcabcbb\n\n输出样例2\n13\n\n\n\n思路\n法1：暴力枚举，复杂度 \n暴力枚举所有子串  含重复字符，舍弃；不含，维护最长长度\n12345678910111213141516171819202122232425262728293031323334// 法一：暴力枚举#include &lt;iostream&gt;#include &lt;map&gt;using namespace std;int n;string s;int main(){    cin &gt;&gt; s;    n = s.size();    int res = 0;    for (int i = 0; i &lt; n; i++)    {        map&lt;char, bool&gt; mp;                            // 映射,用于统计每个字符是否出现        for (int j = i; j &lt;= n; j++)        {            if (j &lt; n &amp;&amp; mp[s[j]])                     // 出现重复字符,截断,维护最大值            {                res = max(res, j - i);                break;            }                       else if (j == n) res = max(res, j - i);    // 遍历完子串都没出现重复字符,维护最大值            else mp[s[j]] = true;        }    }    cout &lt;&lt; res &lt;&lt; endl;    return 0;}\n\n\n\n法2：\n2.最长公共子串\n题目\n题目描述\n给定两个字符串，请你找出它们最长的公共子串的长度。\n输入样例\n12helloworldloop\n\n输出样例\n12\n\n注意\n最长公共子串为lo，即子串必须是连续的\n\n\n思路\n法一：动态规划，复杂度  \n和 最长公共子序列 相似，这里的子序列要求连续，实际是条件更严苛了，也使状态转移更简单了\n可以仍旧用动态规划的思想处理\n状态表示： ： 的前  项，以  结尾和  的前  项，以  结尾的最长连续公共子序列\n状态计算：\n①公共   才有机会转移\n②连续  只能从转移过来 \n注意，维护全局最大值\n不过似乎好像和直接暴力也差不多。。\n代码\n123456789101112131415161718192021222324252627282930// 动态规划#include &lt;iostream&gt;using namespace std;const int N = 1e3 + 10;int n, m;string a, b;int dp[N][N];int res;int main(){\tcin &gt;&gt; a &gt;&gt; b;\tn = a.size(), m = b.size();\t\tfor (int i = 1; i &lt;= n; i ++ )\t\tfor (int j = 1; j &lt;= m; j++)\t\t\tif (a[i - 1] == b[j - 1])\t\t\t{\t\t\t\tdp[i][j] = dp[i - 1][j - 1] + 1;\t\t\t\tres = max(res, dp[i][j]);\t\t\t}\tcout &lt;&lt; res &lt;&lt; endl;\treturn 0;}\n\n\n\n\n\n3.最长回文子串\n题目\n题目描述\n给定一个字符串 s，找到 s 中最长的回文子串，假定唯一。\n输入样例1\n1cbbd\n\n输出样例1\n1bb\n\n输入样例2\n1babac\n\n输出样例2\n1bab\n\n\n\n思路\n法一：暴力枚举，枚举所有子串+判断是否回文，复杂度  \n代码\n123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;int n;string s;string reverse(string s){    for (int i = 0; 2 * i &lt; s.size(); i ++ )        swap(s[i], s[s.size() - i - 1]);        return s;}int main(){    cin &gt;&gt; s;    string res;    n = s.size();         for (int i = 0; i &lt; n; i ++ )        for (int len = 1; i + len - 1 &lt; n; len ++ )        \t// 回文            if (s.substr(i, len) == reverse(s.substr(i, len)))                if (res.size() &lt; len)                    res = s.substr(i, len);    cout &lt;&lt; res &lt;&lt; endl;\treturn 0;}\n\n\n\n\n\n4. 最短子串\n题目\n问题描述\n输入两个字符串 （均由大写英文字母组成，且 ）,要求在  中找出包含  中所有字符的最短子串，假设最短子串唯一。（有兴趣的同学可以尝试用  的时间复杂度解决该问题，注：本题无该要求）\n输入分为两行，第一行为字符串  ，第二行为字符串  。\n输出  的一个子串，该子串为包含  中所有字符的最短子串，如果不存在这样的子串，则输出”  “。\n输入样例1：\n12ADOBECODEBANCABC\n\n输出样例1：\n1BANC\n\n输入样例2：\n12ABADHJGCDBAAAA\n\n输出样例2：\n1ABADHJGCDBA\n\n输入样例3：\n12ABCDEFACDABGH\n\n输出样例3：\n1No\n\n\n\n思路\n问S的子串中包含T所有字符（不一定顺序同，只要字符数量对的上就行）的最短子串\n法一：暴力枚举，复杂度  \n枚举S的所有子串，再判断子串是否包含T的所有字符，如果包含了就\n代码\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;#include &lt;map&gt;using namespace std;int n, m;string a, b;int main(){\t\tcin &gt;&gt; a &gt;&gt; b;    n = a.size(), m = b.size();\t    map&lt;char, int&gt; mp;\t\t\t\t\t// 统计b串的各个字符数量情况    for (char c : b) mp[c]++;    // 初始化    string res = \"\";    int len = n + 1;    for (int i = 0; i &lt; n; i++)     {        map&lt;char, int&gt; mp1;        int cnt = 0;\t\t\t\t\t// 统计当前子串存了b中多少个字符        for (int j = i; j &lt; n; j++)         {            char c = a[j];            mp1[c]++;            if (mp.count(c) &amp;&amp; mp1[c] &lt;= mp[c])                 cnt++;\t\t\t            // b串均包含完了            if (cnt == m)             {                string s = a.substr(i, j - i + 1);                if (s.size() &lt; len)                 {                    res = s;                    len = s.size();                }                break;             }        }    }    if (res.size()) cout &lt;&lt; res &lt;&lt; endl;    else puts(\"No\");\treturn 0;}\n\n\n\n法二：滑动窗口\n5.统计单词数\n题目\n题目描述\n一般的文本编辑器都有查找单词的功能，该功能可以快速定位特定单词在文章中的位置，有的还能统计出特定单词在文章中出现的次数。\n现在，请你编程实现这一功能，具体要求是：给定一个单词，请你输出它在给定的文章中出现的次数和第一次出现的位置。注意：匹配单词时，不区分大小写，但要求完全匹配，即给定单词必须与文章中的某一独立单词在不区分大小写的情况下完全相同（参见样例 1），如果给定单词仅是文章中某一单词的一部分则不算匹配（参见样例 2）。\n输入格式\n共 2 行。\n第 1 行为一个字符串，其中只含字母，表示给定单词；\n第 2 行为一个字符串，其中只可能包含字母和空格，表示给定的文章。\n  第一行单词长度  。\n  文章长度  。\n输出格式\n一行，如果在文章中找到给定单词则输出两个整数，两个整数之间用一个空格隔开，分别是单词在文章中出现的次数和第一次出现的位置（即在文章中第一次出现时，单词首字母在文章中的位置，位置从 0 开始）；如果单词在文章中没有出现，则直接输出一个整数 −1。\n注意：空格占一个字母位\n样例输入 #1\n12Toto be or not to be is a question\n\n样例输出 #1\n12 0\n\n样例输入 #2\n12toDid the Ottoman Empire lose its power at that time\n\n样例输出 #2\n1-1\n\n\n\n思路\n字符串里有空格，要读入一行：getline(cin, str)\n预处理：给字串统一大小写\n法一：KMP匹配，复杂度  \n匹配成功后注意判断是否是单词\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// KMP算法#include &lt;iostream&gt;using namespace std;int n, m;string a, b; // 长的A短的Bint ne[N];int res, loc = -1;int main(){    getline(cin, b);\tgetline(cin, a);\tint n = a.length();\tint m = b.length();\t\t// 全部转小写\tfor (int i = 0; i &lt; n; i++)\t\tif (a[i] &gt;= 'A' &amp;&amp; a[i] &lt;= 'Z')\t\t\ta[i] += 'a' - 'A';\tfor (int i = 0; i &lt; m; i++)\t\tif (b[i] &gt;= 'A' &amp;&amp; b[i] &lt;= 'Z')\t\t\tb[i] += 'a' - 'A';        // 预处理ne数组    ne[0] = -1;    for (int i = 1, j = -1; i &lt; m; i ++ )    {        while (~j &amp;&amp; b[j + 1] != b[i]) j = ne[j];                if (b[j + 1] == b[i]) j ++ ;                ne[i] = j;    }            // KMP匹配    for (int i = 0, j = -1; i &lt; n; i ++ )    {        while (~j &amp;&amp; b[j + 1] != a[i]) j = ne[j];                if (b[j + 1] == a[i]) j ++ ;                if (j == m - 1)         {            // 匹配成功,判断是否是单词            int k = i - m + 1;            if ((!k || a[k - 1] == ' ') &amp;&amp; (i + 1 == m || a[i + 1] == ' '))            {                if (loc == -1) loc = k;                res ++;            }                        }    }        if (res) cout &lt;&lt; res &lt;&lt; \" \" &lt;&lt; loc;    else puts(\"-1\");    return 0;}\n\n\n\n法二：find函数\nC++ 中字符串a.find(b, i)返回  串中从  开始第一次找到  子串的位置，利用这一点不断迭代  即可实现搜完全部  \n不过其实字符串自带的find函数似乎原理也是用KMP，应该不如直接上KMP快，胜在简便\n123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;string a, b;int res, loc = -1;int main(){    getline(cin, b);\tgetline(cin, a);\tint n = a.length();\tint m = b.length();\t\t// 全部转小写\tfor (int i = 0; i &lt; n; i++)\t{\t\tif (a[i] &gt;= 'A' &amp;&amp; a[i] &lt;= 'Z')\t\t\ta[i] += 'a' - 'A';\t}\tfor (int i = 0; i &lt; m; i++)\t{\t\tif (b[i] &gt;= 'A' &amp;&amp; b[i] &lt;= 'Z')\t\t\tb[i] += 'a' - 'A';\t}\t    // 开始查找,终止时为a在i后不再含b    for (int i = a.find(b); i != -1; i = a.find(b, i + 1))    {        if ((!i || a[i - 1] == ' ' ) &amp;&amp; (i + b.size() == n || a[i + b.size()] == ' ' ))         {            if (loc == -1) loc = i;            res ++;        }    }    if (res) cout &lt;&lt; res &lt;&lt; \" \" &lt;&lt; loc;    else puts(\"-1\");        return 0;}   \n\n","slug":"数据结构与算法--week7","date":"2024-10-24T07:10:39.000Z","categories_index":"算法","tags_index":"字符串","author_index":"Jerry"},{"id":"9e3423b767d3fa0ce58b8cbfd68d8397","title":"ubantu 20.04 里安装 Docker","content":"参考一条命令即可！在 ubantu 20.04 里安装 Docker（无法连接官网，镜像网站找不到的解决办法\n按照步骤安装docker报错，提示连接超时\n\n\n\n\n使用以下命令替代\n1sudo curl -fsSL https://github.com/tech-shrimp/docker_installer/releases/download/latest/linux.sh| bash -s docker --mirror Aliyun\n\n\n\n要是访问不了github，可以换这条\n1sudo curl -fsSL https://gitee.com/tech-shrimp/docker_installer/releases/download/latest/linux.sh| bash -s docker --mirror Aliyun\n\n\n\n检查是否成功安装\n1docker --version\n\n","slug":"ubantu-20-04-里安装-Docker","date":"2024-10-24T02:23:14.000Z","categories_index":"技术","tags_index":"docker","author_index":"Jerry"},{"id":"11f0ab19a9ece9ddf223ec86aeed180d","title":"数据结构与算法--week6","content":"1.直线上的点\n题目\n问题描述:\n小明很喜欢研究直线上的点。最近，小明的妈妈给小黄出了一个问题，给定  个  轴上的整数点，可以有多少种方式选择三个不同的点，使得它们之间最远的两个点之间的距离不超过  。注意，选择的三个点不要求连续。\n输入：第一行包含两个整数:  和   ( )。下一行包含  个整数  …它们的绝对值不超过  。保证输入点的坐标严格增加。\n输出：打印一个整数，表示三个点组成的组的数量，其中两个最远点之间的距离不超过  。\n输入样例 \n124 31 2 3 4\n\n输出样例 \n14\n\n\n\n思路\n法一：暴力\n枚举  ，二分找到距离大于  的第一个点  ，则贡献方案数为 \n组合数求解：利用递推 \n代码\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;map&gt;typedef long long  LL;using namespace std;const int N = 1e5 + 10;int n, d;LL c[N][3];  // 存组合数LL  a[N];    // 位置int res;int main(){    ios::sync_with_stdio(false);    cin.tie(0);    cout.tie(0);    cin &gt;&gt; n &gt;&gt; d;    for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i];    // 预处理组合数    for (int i = 0; i &lt;= n; i++)    {        c[i][0] = 1;        for (int j = 1; j &lt;= min(i, 2); j++)            c[i][j] = c[i - 1][j - 1] + c[i - 1][j];    }    // 暴力枚举    for (int i = 1; i &lt;= n; i++)    {        int l = i + 1, r = n;        int mid;        while (l &lt; r)        {            // 找到长度小于等于d的最大值            mid = l + r + 1&gt;&gt; 1;            if (a[mid] - a[i] &lt;= d) l = mid;            else r = mid - 1;        }        if (l - i &gt;= 2) // 判断是否有3个点            res += c[l - i][2];     }    cout &lt;&lt; res &lt;&lt; endl;    return 0;}\n\n\n\n\n\n2.数位组合与删除\n题目\n问题描述 \n小明定义了一个特殊的集合，该集合的元素有如下规律：\n（1）1是集合元素；\n（2）若x是集合的元素，则  ，也是集合的元素。\n小明从集合中取出最小的  个元素，按从小到大的顺序组合成一个多位数，再从中删除  个数位上的数字，要求由剩下的数字组合的数最大，小明最后想得到该多位数以及删除后新组合的数。小明在设置  时，特别注意排除了所有数位都被删除的情况。\n输入：仅一行，即  的值，均小于等于  \n输出：两行，第一行为组合的多位数，第二行为删除后新组合的数\n输入样例 \n5 4\n输出样例 \n137915\n95\n提示\n\n你需要得到集合中最小的n个元素。集合中的初始元素为1，计算得到3和9。注意，当x为3时， 。因此，元素并不是按照大小有序生成的。\n你可以考虑使用优先队列管理你的集合元素，优先队列能够将你队列中的元素自动进行排序。\n\n1234//升序队列，小顶堆priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt; q;//降序队列，大顶堆priority_queue&lt;int,vector&lt;int&gt;,less&lt;int&gt;&gt; q;\n\n\n\n关于堆，在堆里面用数组模拟出了堆，介绍了基本的原理\n不过其实C++ STL里面的优先队列已经实现了堆，题目只给小大根堆的定义方式，也不把一些API展示出来，确实有点离谱\n这里先简单介绍一下优先队列的一些常用操作\n1234567891011/* 大小根堆声明的格式,直接记住就行 */// 优先队列默认是大根堆,即大数在上priority_queue&lt;int&gt; q;// 小根堆priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q;/* 基本的操作 */q.top(); \t// 堆顶q.pop(); \t// 弹出堆顶q.size(); \t// 堆中元素数量\n\n\n\n思路\n题目意思是：\n①先处理出集合内的最小的  个元素\n②从这  个数组合成的数中删除  位使得剩余最大，和上周的题目求最小恰好反过来，可以看移除K位数字\n笔者一开始的想法是，利用小根堆的自动排序，不需要按顺序，直接无脑往堆中加入足够多的数，取出前  个即可,于是写出了这样的代码\n12345678910void dfs(int x){\tq.push(x);\t\tif (q.size() &lt;= n * n) // 盲猜n^2够了\t{\t\tq.push(2 * x + 1), q.push(4 * x + 5);\t\tdfs(2 * x + 1), dfs(4 * x + 5);\t}}\n\n但很快就发现这是种很蠢的想法。。。。\n因为深度优先搜索的逻辑的一条路走到黑再回溯,他会一直添加2 * x - 1 至超出大小限制才回溯，\n尽管可能某一层 4 * x + 5 应该先插入进去，大概如下面的情况\n\n\n所以这个思路行不通了，会一条路走到黑\n关键是要及时回头，于是笔者想到了迭代加深（emmm迭代加深的文章还没码，后续尽快补上）的思路\n由于集合生成构成的树状结构不满足堆的严格单调性，还是得确保存多遍历一些点\n题目说  , 第  层节点数为  则前  层节点数为 ，保险起见，多设置几层，最大深度设置为  \n为了不存多余的元素，将堆替换为大根堆，到后面堆满了只需要把大数丢出来就行\n于是这部分代码如下：\n12345678910111213141516priority_queue&lt;int&gt; q;void dfs(int x, int dep){\tif (dep &gt; 15) return;        if (q.size() &lt; n)        q.push(x); // 没满,继续加\telse if (q.top() &gt; x)    {        q.pop();        q.push(x);    }        dfs(2 * x + 1, dep + 1), dfs(4 * x + 5, dep + 1);}\n\n再结合上星期的题目即可得移除K位最大的代码为\n1234567891011121314151617181920212223242526272829303132// 从num里面删除k位最大string removedigits(string num, int k){    stack&lt;char&gt; s;    for (int i = 0; i &lt; num.size(); i++)    {        while (k &amp;&amp; !s.empty() &amp;&amp; s.top() &lt; num[i])        {            // 栈顶小于当前,需要删,可以删            s.pop();            k--;        }        s.push(num[i]);    }    // k没有用完,单调不增栈，删后面的    while (k &amp;&amp; s.size())    {        s.pop();        k--;    }    string res;    while (s.size())    {        res = s.top() + res;        s.pop();    }        return res;}\n\n\n\n代码\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;string&gt;using namespace std;priority_queue&lt;int&gt; q; // 大根堆int n, m;string res;void dfs(int x, int dep){    if (dep &gt; 15) return;    if (q.size() &lt; n)        q.push(x); // 没满,继续加    else if (q.top() &gt; x)    {        q.pop();        q.push(x);    }    dfs(2 * x + 1, dep + 1), dfs(4 * x + 5, dep + 1);}// 从num里面删除k位最大string removedigits(string num, int k){    stack&lt;char&gt; s;    for (int i = 0; i &lt; num.size(); i++)    {        while (k &amp;&amp; !s.empty() &amp;&amp; s.top() &lt; num[i])        {            // 栈顶小于当前,需要删,可以删            s.pop();            k--;        }        s.push(num[i]);    }    // k没有用完,单调不增栈，删后面的    while (k &amp;&amp; s.size())    {        s.pop();        k--;    }    string res;    while (s.size())    {        res = s.top() + res;        s.pop();    }        return res;}int main(){    cin &gt;&gt; n &gt;&gt; m;    // 存数    dfs(1, 1);    // 取数    while (q.size())    {        res = to_string(q.top()) + res;        q.pop();    }    cout &lt;&lt; res &lt;&lt; endl; // 输出最小的n个数    cout &lt;&lt; removedigits(res, m) &lt;&lt; endl;    return 0;}\n\n\n\n\n\n3.航班起飞时间表\n题目\n问题描述\n小红在某机场工作。她负责制定一个离境时间表。今天要起飞的航班有  个，其中第  个计划在当天的第  分钟起飞。\n该机场是该市的主要交通枢纽，因此通常很难保证航班的正常运行。今天也碰到了这样的情况:由于技术问题，在今天的前k分钟，没有航班能够起飞，所以现在必须创建新的起飞时间表。\n新的起飞时间表有如下要求：\n（1）所有航班现在必须在第  和第  分钟 (包含)之间的不同时间起飞。\n（2）不再要求这些航班按照最初计划的顺序起飞，也就是说它们在新计划中的顺序可能有所不同。\n（3）任何航班都不能比原定时间提前起飞。\n小红知道，班机每延误一分钟，机场就要付出很大的代价。请帮助她创建一个新的航班起飞时间表，使机场的总成本降到最低。\n输入：第一行包含两个整数  和   ， 表示航班数，  表示当天所有航班都不能起飞的分钟数。第二行包含  个整数  ，这里  是第  次航班延误1分钟的损失费用。\n输出：延误航班的最低损失。\n输入样例 \n5 2\n4 2 1 10 2\n输出样例 \n20\n\n\n思路\n原本第  架飞机在第  分钟起飞，现在前  分钟的飞机都飞不了，而  的都能正常起飞\n但是需要重新安排顺序，让损失最小\n方法是贪心，在排每架飞机的时候一定会选择当前架飞机的最优位置，所以关键就是决定飞机排序的先后顺序\n结论是   越大的飞机越先排\n证明如下：\n\n\n知道顺序之后剩余的便容易做了，直接先对  排序，然后每排一个就给一个位置打上标记，然后一个个找最优位置算出当前损失即可\n代码\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;algorithm&gt;#define x first#define y secondusing namespace std;typedef long long LL;typedef pair&lt;long long, int&gt; PLI;const int N = 3e4 + 10;int n, k;LL res;bool st[N];\t\t// 标记是否选择PLI q[N]; \t\t// {ci, i} 存储飞机信息int main(){\tios::sync_with_stdio(false);\tcin.tie(0);\tcout.tie(0);\tcin &gt;&gt; n &gt;&gt; k;\tfor (int i = 1; i &lt;= n; i++)\t{\t\tcin &gt;&gt; q[i].x;\t\tq[i].y = i;\t}\tsort(q + 1, q + 1 + n);\t\t// 从小到大排序\treverse(q + 1, q + 1 + n);\t// 反转\t// 开始从大到小枚举飞机\tfor (int i = 1; i &lt;= n; i++)\t{\t\tint c = q[i].x, t = q[i].y;\t\t// 如果t &lt; k + 1,最早从k + 1开始,找最合适的位置\t\tfor (int j = max(t, k + 1); j &lt;= k + n; j++)\t\t\tif (!st[j])\t\t\t{\t\t\t\tst[j] = true;\t\t\t\tres += c * (j - t);\t\t\t\tbreak;\t\t\t}\t}\tcout &lt;&lt; res &lt;&lt; endl;\treturn 0;}\n\n\n\n\n\n4.谁是最佳选手\n题目\n题目描述\n某视频网站举办了一个综艺节目，每周会有一名新选手加入节目，并根据才艺表现获得分数。\n从第  周开始，最早加入节目的选手离开。\n从第  周开始，得分最高的选手会获得“最佳选手”称号，请从第  周开始，找出每周“最佳选手”的分数。\n输入：第一行包含两个整数  和   ，  表示选手总人数， 表示从第  周开始评选“最佳选手”；第二行包括  个整数，表示每位选手初登节目时获得的分数。\n输出：包括  行数据，分别是从第  周开始，到第  周结束，每周“最佳选手”的分数。\n样例输入\n127 31 3 2 4 5 8 6\n\n样例输出\n1234534588\n\n解释\n\n\n\n周数\n本周选手得分\n最高分\n\n\n\n3\n1，3，2\n3\n\n\n4\n3，2，4\n4\n\n\n5\n2，4，5\n5\n\n\n6\n4，5，8\n8\n\n\n7\n5，8，6\n8\n\n\n\n\n思路\n其实这题就是简单的滑动窗口，队列存下标，用于判断是否弹出队头，维护窗口内  周的值单调递减队列，则队头为窗口内的最大值，可以看这个滑动窗口\n需要进行的步骤如下\n\n判断队头是否弹出\n维护单调递减队列\n输出队头（窗口内的最大值）\n\n代码\n1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;const int N = 3e4 + 10;int n, k;int a[N];deque&lt;int&gt; q;\t// 双端队列实现双向弹出int main(){    ios::sync_with_stdio(false);    cin.tie(0);    cout.tie(0);        cin &gt;&gt; n &gt;&gt; k;         for (int i = 1; i &lt;= n; i ++ ) cin &gt;&gt; a[i];        for (int i = 1; i &lt;= n; i ++ )    {        // 弹出队头        while (q.size() &amp;&amp; q.front() &lt; i - k + 1) q.pop_front();                // 维护单调递减队列        while (q.size()  &amp;&amp; a[q.back()] &lt;= a[i]) q.pop_back();        q.push_back(i);                // 第k周开始输出        if (i &gt;= k) cout &lt;&lt; a[q.front()] &lt;&lt; endl;         \t}        return 0;}\n\n\n\n\n\n5.每次传送变小\n题目\n题目描述\n一条绳子上系着  个小球，初始时小球从左到右依次编号为  到  。现给定小球的大小，记录在数组  中，即  分别代表小球  的大小。\n每一秒，位于绳子左端的小球会向左飞出，经过传送装置传送到绳子的最右端并且大小减少 1，同时其他小球同步向左移动；当小球大小达到 0 时，这个小球消失。\n现在给出所有小球的大小，需要你求出每个小球消失所需的时间。（第一个球飞出变小算作第一秒）。\n输入格式\n第一行一个整数 。\n接下来一行   个整数表示 \n输出格式\n输出  个数，第  个数表示第  个球消失的时间\n样例输入\n1243 4 2 1\n\n样例输出\n18 10 7 4\n\n数据规模\n对于给定的数据，保证 ，\n\n\n思路\n可以像之前飞盘高手一样开个队列一直模拟传送过程\n代码\n12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;queue&gt;#define x first#define y secondusing namespace std;typedef pair&lt;int, int&gt; PII;const int N = 1e3 + 10;int n;queue&lt;PII&gt; q;int t[N];int main() {    cin &gt;&gt; n;        for (int i = 1; i &lt;= n; i++)     {        int x;        cin &gt;&gt; x;        q.push({ i, x });    }    // 全局时间    int T = 0;        while (!q.empty())     {        T++;        auto p = q.front();        q.pop();                int u = p.x, t1 = p.y;        t1--;                 if (t1 &gt; 0) q.push({u, t1});    // 放到队尾        else t[u] = T;                  // 大小变为0,保存结果    }    for (int i = 1; i &lt;= n; i++)  cout &lt;&lt; t[i] &lt;&lt; \" \";    return 0;}\n\n","slug":"数据结构与算法--week6","date":"2024-10-17T07:54:38.000Z","categories_index":"算法","tags_index":"栈,队列,堆,双端队列,迭代加深","author_index":"Jerry"},{"id":"6591524f62622b02d2700a4bea4ebb53","title":"科研日记1","content":"科研日记110.13日记\n突发奇想，想要记录一下自己的科研实习经历，既总结自己在实习中的所见所思所想，顺便分享一下自己的经历，或许能让大家对科研的日常有点小感受\n前情提要现在和zxy一起帮cqd师兄重做BrokerHub论文中的几个实验图。\n在的参与下，用户能够获得更高的收益。通过数学推导，用户在的参与程度将趋于稳定，且对用户的税率将收敛。\n我们的任务是通过实验来验证这一理论，具体包括：\n\n选择税率时，需要确保总体收益最大化。虽然现有的default优化器已经实现，但论文证明税率的收敛与优化器选择无直接关系。我们需要开发更多优化器来验证这一点。\n在预测和的收益时，当前的收益预测不够准确，需进一步完善。\n还原结论场景并绘制实验图。\n\n原本计划昨晚忙完回去再改代码，但zxy改了半天代码，直到晚上10点半都看不到好转。于是我便也决定放弃赶工，保存体力，今天再全力投入。\n截至昨天的进展及遇到的问题：\n\n绘制出的实验图存在以下问题：\n用户在的参与度出现剧烈震荡，部分用户反复加入退出，猜测是因为的预测不准确，导致错误决策，加入后收益过低便退出，再次反复。\n在两个竞争的场景中，总有一个在后期陷入完全劣势，原因是两个初始条件一致，导致用户倾向选择第一个遍历到的，进一步扩大其优势。我们打算为两个使用不同的优化器来增加差异。\n\n\n我写了一个基于强化学习的优化器，zxy写了一个基于回归分析和随机波动的优化器，两个优化器都可以正常运行，但结果依然存在相同问题。特别是优化器的反馈机制导致用户的参与程度和税率反复震荡，最终无法收敛。唯一正常的是最后计算的收益。\n我们尝试调整对的判断逻辑。zxy提出了通过建立收益b2e_return与轮次的回归函数进行预测，尽管这个回归函数有局限性，我在此基础上引入了滑动窗口策略进行数据预测，但结果依然不理想。调整细节、参数等后，实验图依然震荡不定，甚至幅度更大。\n\n哎，恰逢师兄论文临近ddl，无论如何今天都得把结果弄出来了！\n上午&amp;几近崩溃今天我们依然怀疑是那边出了问题。我猜测的收益像股票一样，根本无法准确预测，回归模型预测的思路可能本身就有问题。zxy也觉得有道理，于是我们为预测的b2e_return和brokerhub_return都加入了随机波动，模拟不可预测性。但结果仍旧不行。\n师兄建议我们输出中间数据，看看问题出在哪。于是我们把每一轮每个预测的b2e_return、stay_return、leave_return都输出了，结果发现，用户每次的决策变化几乎都是因为收益差一点点，导致做出了剧烈的改变。\n为了看看实验图的理想效果，并顺便debug其他问题，我们决定手动调整一下b2e_return，约束当轮次大于25时，直接让的收益乘上0.00001（这样总该一直呆在了吧…）。\n12python run_simulation.pysimulation start!\n\n……\n一切如我们所料，后期b2e_return直接拼不过其他两个，我们美滋滋地想象着实验图的美好场景。\n1python draw.py\n\n……\n\n\n结果崩溃，还是在反复横跳！明明都看不到收益了，怎么还愿意出去，真是搞不懂。\n\n\n也许这就是科研的常态吧，理想很美好，现实却骨感。\n唉，没办法，还是得改。\n于是我们决定输出用户的决策，看看每轮用户的选择。每次用户做出决策前，都将决策打印出来，看看究竟出了什么问题。\n12python run_simulation.pysimulation start!\n\n……\n到了b2e_return被我们强行压低的轮次，用户的确加入了。\n(下一轮)b2e_ return还是很小，但…用户又了。\n我们的内心os：哥们你在干啥？\n这下我们真的崩溃了，已经强行干了它还不听。这…\n幸好，这时候xbz师兄带来了一个好消息，已经做好了，我们的PPT也能更新了，稍微测试了一下功能，正常工作，心理上也算得些安慰。\n经过一番摆烂调整，我们进入了下一轮抗争。\n这次我们直接取消了用户的选项，zxy把else的决策都改成，这下总不可能出错了吧？\n继续！\n12python run_simulation.pysimulation start!\n\n……\n……\n……确实没了，但为什么用户连续两轮都在？你都没离开，为什么输出的不是？看到这个输出，我们知道又要死了，头大……\n画出的图也确实如此，用户既没加入另一个，也没有输出过，但就是退出了原本的。\n整个上午就这么耗过去了，问题越来越奇怪，试过的都试过了，实在是没招了……\n刚好到饭点了，决定放弃，干饭去。\n可能坏事情总是成双成对……中午去瑾园吃的现炒也是一坨，荤素菜一个味道。吃第一口还行，吃完真的想吐。\n今天算是认了，幸好今天不训练，不然真要崩溃了。\n中午&amp;尝试未果饭后回到工位，我们一时不知该干什么，能尝试的方法基本都试过了，还是没法解决。\n和cqd师兄讨论了一下，觉得上午跑出的结果很奇怪，但又不知道怎么改。\n我们仔细检查了原本的决策逻辑，反复确认没有问题，又添加了几处结果打印，跑了好几遍，依旧无果。\n转眼就到了3点半，连午觉都没来得及睡。\n还是先休整一下吧，忙活了一整天，zxy回宿舍睡午觉，走之前我们讨论了一下，可能是数据上传时，上层函数处理出了问题。但向上看了几层，发现返回的数据确实是正确的，更新的状态也没问题。\n开始午睡。\n下午&amp;转折独自从午睡中醒来后，我重新爬起来看代码。\n既然make_decision没问题，那是不是后面某个函数出了问题？\n在不停地Ctrl+左键查找的过程中，我一层层查看用户决策和状态更新的函数。\nemmm，似乎没有什么问题。\n也许是老天看不下去我今天的遭遇，转折终于来了……\n当我Ctrl+鼠标放在volunteer_manager，往下调用到最后一层的update_state函数时，突然发现——诶？怎么传不过去？\n\n\n原来这里没有成功调用状态更新函数……我们忙活了一上午，错的居然是这个。\n虽然检查了好几遍，没发现什么明显问题，函数名也没拼错，调用逻辑也正常。直到后来才发现，问题虽然出在这里，但并不是拼写错误，而是字典变量名错了。\n哎，Python和JS差不多，变量名错了也不会报错，真是够麻烦的……\n终于找到了问题，修正后结果正常了，用户全部加入到，没有再退出。画出的图趋势也和之前类似，结论也基本验证了。\n接下来是还原论文中的实验图，需要重写绘图函数。\n刚好zxy回来了，我合并了几张图，调整了一下样式，基本解决了fig3和fig4的问题。他负责处理fig5中更复杂的箱线图部分。\n\n\n刚好也到饭点了，我已经疲惫不堪，这一天的调试真让人头大，先去干饭了，zxy继续在工位上写画图代码。\n晚上&amp;小插曲\n\n饭后，zxy基本完成了画图的代码，我负责接下来的图片合并和样式调整，胜利在望！\n刚好晚上约了打羽毛球，便先去休息调整了一下。\n\n\n\n9点，回到工位。之前解决了大问题，实验效果图也不错，准备将扩大到200轮。\n\n\n然而出了点小插曲。文件检测到之前处理过的数据，没有重新处理，导致数据仍然是50轮，跑到50轮后因为没读到数据报错了。\n\n\n修改后继续运行，在等待过程中写了这篇文章。\n第一次跑时，63轮出现报错，非常奇怪，前面的轮次都正常，怎么可能突然在这一轮停了？问了师兄，觉得没有问题，可能是在编辑时手滑，复制粘贴中断了进程……（吐血，不过还好只是虚惊一场\n第二次运行时，不知道为什么速度突然慢了很多。本打算今晚把实验结果等出来，画好图给师兄，但速度慢到每轮1分钟，等到11点半才跑完一半。\n   \n第一次见学院楼门口的单车空无一人的场景。\n\n\n希望明天一切顺利吧！\n","slug":"科研日记1","date":"2024-10-13T13:41:21.000Z","categories_index":"科研","tags_index":"日记,BrokerHub","author_index":"Jerry"},{"id":"cb49df4bebbec542f5250fde4983b056","title":"数据结构与算法--week5","content":"1.栈\n题目\n题目描述\n给定一个栈S和如下4种操作。\n\nS.push(X): 将整数X入栈S。\nS.pop(): 如果栈S不为空，弹出栈顶元素。\nS.top(): 输出栈顶元素（如果栈为空，输出-1）。\nS.min(): 输出栈S中的最小元素（如果栈为空，输出-1）。\n\n输入描述\n输入包括多组数据。对于每组数据，第一行为整数  ( )。接下来n行对应n个操作，每行的第一个整数为操作类型，如果操作类型为0，接下来还包括一个整数   ( )。\n输出描述\n对于每组数据的操作2和3，每行输出一个整数。\n输入样例\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677100 010 20 00 03130 5212120 211230 410 10 40 0230 0330 40 513230 00 420 60 2120 0210 30 80 90 82410 20 00 70 60 80 50 230 530 020 30 420 30 030 410 30 93\n\n输出样例\n1234567891011121314151617181920005-1-1-100040460000400\n\n\n\n吐槽一下这个题目。。。。原本的题目把多组输入放在多个代码框里，也不说明白都在一个输入样例里，还以为要输入组数，又发现根本就没给组数，结果最后是读到n就要处理\n思路\n直接处理栈的4个操作即可\n\n用STL的stack报MLE\n\n\n这时候就体现出数组模拟栈的优势了，可以看看我之前写的这个基础数据结构—栈 \n\n\n  ：存栈\n：存栈顶编号（等价于地址）\n代码\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;using namespace std;const int N = 1e4;int n, op, x;int stk[N];int tt;int main(){\twhile (cin &gt;&gt; n)\t{\t\ttt = 0; // 重置\t\twhile (n--)\t\t{\t\t\tcin &gt;&gt; op;\t\t\tif (op == 0) // push\t\t\t{\t\t\t\tcin &gt;&gt; x;\t\t\t\tstk[tt++] = x;\t\t\t}\t\t\telse if (op == 1)\t// pop\t\t\t{\t\t\t\tif (tt) tt--;\t\t\t}\t\t\telse if (op == 2)  // top\t\t\t{\t\t\t\tif (tt) cout &lt;&lt; stk[tt - 1] &lt;&lt; endl;\t\t\t\telse cout &lt;&lt; -1 &lt;&lt; endl;\t\t\t}\t\t\telse // min \t\t\t{\t\t\t\tif (!tt)\t\t\t\t{\t\t\t\t\tcout &lt;&lt; -1 &lt;&lt; endl;\t\t\t\t\tcontinue;\t\t\t\t}\t\t\t\tint res = 1e8 + 10;\t\t\t\tfor (int i = 0; i &lt; tt; i++)\t\t\t\t\tres = min(res, stk[i]);\t\t\t\tcout &lt;&lt; res &lt;&lt; endl;\t\t\t}\t\t}\t}}\n\n\n\n\n\n2.有效的括号\n题目\n题目描述\n给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。\n有效字符串需满足：\n\n左括号必须用相同类型的右括号闭合。\n括号必须以正确的顺序闭合。\n\n示例输入\n123456()()[]{}(]([)]{[]}\n\n示例输出\n12345truetruefalsefalsetrue\n\n要求\n实现头文件 valid_parentheses.h 中的 isValid 函数。\nvalid_parentheses.h\n123456789#ifndef VALID_PARENTHESES_H_#define VALID_PARENTHESES_H_#include &lt;string&gt;using namespace std;bool isValid(string s);#endif // !VALID_PARENTHESES_H_\n\n\n\n思路\n\n这个题目大一程设已经做过很多遍了，一个个遍历字符串，左括号入栈，右括号判断是否匹配\n\n注意最后要判断是否全部匹配完毕\n\n这里无脑if-else竟然还要扣分。。。我后面改成map提前存好匹配了\n\n\n\n\n\n\n代码\n1234567891011121314151617181920212223242526272829#include \"valid_parentheses.h\"#include &lt;stack&gt;#include &lt;map&gt;bool isValid(string s) {      stack&lt;char&gt; stk; \t// 使用 char 类型的栈，因为我们存储的是字符    \t    map&lt;char, char&gt; mp; // 预处理匹配    mp['('] = ')';    mp['['] = ']';    mp['{'] = '}';        for (int i = 0; i &lt; s.size(); i ++ )    {        if (s[i] == '(' || s[i] == '[' || s[i] == '{') stk.push(s[i]);                else        {            if (stk.empty()) return false; \t\t\t // 栈空                        if (s[i] != mp[stk.top()]) return false; // 不匹配            else stk.pop();\t\t\t\t\t\t\t // 匹配,pop        }        \t    }      return stk.empty();\t// 判断是否匹配完毕  }  \n\n\n\n\n\n3.移除K位数字\n题目\n题目描述\n给你一个以字符串表示的非负整数 num 和一个整数 k ，移除这个数中的 k 位数字，使得剩下的数字最小。请你以字符串形式返回这个最小的数字。\n示例 1\n123输入：num = \"1432219\", k = 3输出：\"1219\"解释：移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219 。\n\n示例 2\n123输入：num = \"10200\", k = 1输出：\"200\"解释：移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。\n\n示例 3\n123输入：num = \"10\", k = 2输出：\"0\"解释：从原数字移除所有的数字，剩余为空就是 0 。\n\n要求\n实现头文件 remove_k_digits.h 中的 removeKdigits 函数。\n提示：\n\n\nnum 仅由若干位数字（0 - 9）组成\n除了 0 本身之外，num 不含任何前导零\n\nremove_k_digits.h\n123456789#ifndef REMOVE_K_DIGITS_H_#define REMOVE_K_DIGITS_H_#include &lt;string&gt;using namespace std;string removeKdigits(string num, int k);#endif // !REMOVE_K_DIGITS_H_\n\n\n\n思路\n\n\n\n\n代码\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;stack&gt;#include \"remove_k_digits.h\"using namespace std;// 维护栈,判断是否需要删除void stack_new(stack&lt;char&gt;&amp; s, char c, int &amp;k){    while (k &amp;&amp; !s.empty() &amp;&amp; s.top() &gt; c)    {        // 前一个大于后一个,需要删,可以删        s.pop();        k--;    }}string removedigits(string num, int k){    if (num.size() == k) return \"0\";\t// 全部删除     stack&lt;char&gt; s;    for (int i = 0; i &lt; num.size(); i++)    {        stack_new(s, num[i], k);        // 专门分开写一个函数不然要扣分。。。。        s.push(num[i]);    }    // k没有用完    while (k &amp;&amp; s.size())    {        s.pop();        k--;    }    // 存储结果    string res;    while (s.size())    {        res = s.top() + res;        s.pop();    }    // 删除前导0    while (res.size() &amp;&amp; res[0] == '0')        res.erase(res.begin());    return res;}\n\n\n\n\n\n4.简单计算器\n题目\n题目描述\n给定一个四则运算的表达式的字符串，计算表达式最终的结果。\n提示，输入不会出现除0，输入的数字在-1000000到100000之间，表示负数时会用括号消除歧义。\n输入\n160+(3*2+1)\n\n输出\n167\n\n\n\n思路\n和国庆的作业题差不多，但是这里要处理负数的情况\n和数据结构课不一样的是，我将这里详细讲解一下为什么处理表达式运算可以用栈实现，而不是直接一上来就告诉结论，详细思路如下\n\n\n由此，在已知表达式树的情况下，计算表达式的值的伪代码大致如下：\n12345678910111213int dfs(char u){\t// 递归终点\tif (isdigit(u)) return u - '0'; // 如果已经到达底部了,开始向上回溯把数字往上传\t    int l = dfs(left), r = dfs(right); // 求左数和右数的值,假设已经知道了树的结构        // 计算当前节点的值并向上返回    if (u == '+') return l + r;    if (u == '-') return l - r;    if (u == '*') return l * r;    if (u == '/') return l / r;}\n\n\n\n\n\n\n\n\n\n完整代码\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;unordered_map&gt;using namespace std;string str;  \t // 表达式stack&lt;int&gt; num;  // 操作数stack&lt;char&gt; ops; // 操作符unordered_map&lt;char, int&gt; pr = { {'+', 1}, {'-', 1}, {'*', 2}, {'/', 2} }; //运算符优先级void eval(){\t// 进行一次运算\tint b = num.top(); num.pop();\tint a = num.top(); num.pop();\tchar c = ops.top(); ops.pop();\tint res;\tif (c == '+') res = a + b;\telse if (c == '-') res = a - b;\telse if (c == '*') res = a * b;\telse res = a / b;\tnum.push(res);  \t\t// 结果存回去}int main(){\tcin &gt;&gt; str;\tfor (int i = 0; i &lt; str.size(); i++)\t{\t\tchar c = str[i];\t\tif (isdigit(c))\t\t{\t\t\t// 数字直接入栈,注意处理多位\t\t\tint res = 0, j = i;\t\t\twhile (isdigit(str[j]))\t\t\t\tres = res * 10 + str[j++] - '0';\t\t\ti = j - 1;\t\t\t// isdigit(j) = false\t\t\tnum.push(res);\t\t// 数字入栈\t\t}\t\telse if (c == '(') ops.push(c);\t\telse if (c == ')')\t\t{\t\t\t// 计算至左括号\t\t\twhile (ops.size() &amp;&amp; ops.top() != '(') eval(); // 作一次运算\t\t\tops.pop();\t\t\t\t\t\t // 弹出左括号\t\t}\t\telse if (c == '-' &amp;&amp; (!ops.size() || ops.top() == '('))\t\t{\t\t\t// 负号的情况,前面有括号或者在最前面\t\t\tint res = 0, j = i + 1;\t\t\twhile (isdigit(str[j]))\t\t\t\tres = res * 10 + str[j++] - '0';\t\t\ti = j - 1;\t\t\tnum.push(-res);\t\t// 数字入栈\t\t}\t\telse\t\t{\t\t\t// 正常运算符,判断优先级\t\t\t// 小于等于的上放,回溯求值\t\t\twhile (ops.size() &amp;&amp; pr[ops.top()] &gt;= pr[c]) eval();\t\t\t// 大于之后压入栈\t\t\tops.push(c);\t\t}\t}\t// 计算剩余的数,返回结果\twhile (ops.size()) eval();\tcout &lt;&lt; num.top() &lt;&lt; endl;\treturn 0;}\n\n","slug":"数据结构与算法--week5","date":"2024-10-10T08:30:29.000Z","categories_index":"算法","tags_index":"栈","author_index":"Jerry"},{"id":"7f00768b865696d227f7b794a43f7717","title":"离散化","content":"引入简单来说，离散化就是一种映射\n想象这样一个场景，假如你需要对数轴上范围为  的数进行操作，但是只需要操作  个数\n开  的数组太浪费，开  的数组不够用，离散化正是为解决这一问题\n特征便是 覆盖范围大，操作范围小\n计算这里利用一到简单的例题来让各位体会一下离散化的过程\n洛谷P1955程序自动分析\n\n题目\n题目描述\n在实现程序自动分析的过程中，常常需要判定一些约束条件是否能被同时满足。\n考虑一个约束满足问题的简化版本：假设  代表程序中出现的变量，给定  个形如  或  的变量相等/不等的约束条件，请判定是否可以分别为每一个变量赋予恰当的值，使得上述所有约束条件同时被满足。例如，一个问题中的约束条件为：，这些约束条件显然是不可能同时被满足的，因此这个问题应判定为不可被满足。\n现在给出一些约束满足问题，请分别对它们进行判定。\n输入\n输入的第一行包含一个正整数 ，表示需要判定的问题个数。注意这些问题之间是相互独立的。\n对于每个问题，包含若干行：\n第一行包含一个正整数 ，表示该问题中需要被满足的约束条件个数。接下来  行，每行包括三个整数 ，描述一个相等/不等的约束条件，相邻整数之间用单个空格隔开。若 ，则该约束条件为 。若，则该约束条件为 。\n输出格式\n输出包括  行。\n输出文件的第  行输出一个字符串 YES 或者 NO（字母全部大写），YES 表示输入中的第  个问题判定为可以被满足，NO 表示不可被满足。\n样例 #1\n样例输入 #1\n1234567221 2 11 2 021 2 12 1 1\n\n样例输出 #1\n12NOYES\n\n样例 #2\n样例输入 #2\n12345678910231 2 12 3 13 1 141 2 12 3 13 4 11 4 0\n\n样例输出 #2\n12YESNO\n\n\n\n勘误：测试点  的  约束为 ，而不是下图中的 。\n\n\n\n\n分析\n其实就是用并查集来维护相等的集合，并查集介绍见并查集\n优先处理=来合并集合，再处理≠来查找集合\n但是这里有个问题就是  范围过大，但是个数很少，开不了  的数组\n离散化思路\n把每个数从小到大排序，然后映射向其索引  \n这样就能用  个互不相同的数来代表范围在  的数，这便是离散化的思想\n代码\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;map&gt;#include &lt;vector&gt;#define x first#define y second using namespace std;typedef pair&lt;int, int&gt; PII;const int N = 2e5 + 10;int t;int n;int p[N];int a, b, c;map&lt;int, int&gt; mp;// 处理所有涉及到的坐标int cnt;\t\t// 存储所有涉及到的数的数量vector&lt;PII&gt; eq;vector&lt;PII&gt; neq;void init(){\tcnt = 0;\tfor (int i = 1; i &lt;= 2 *n; i++) p[i] = i; // 初始化并查集\teq.clear(), neq.clear(), mp.clear();}int find(int x){\tif (x != p[x]) p[x] = find(p[x]);\treturn p[x];}int main(){\tios::sync_with_stdio(false);\tcin.tie(0);\tcout.tie(0);\tcin &gt;&gt; t;\twhile (t--)\t{\t\tcin &gt;&gt; n;\t\tinit();\t\tfor (int i = 1; i &lt;= n; i++)\t\t{\t\t\tcin &gt;&gt; a &gt;&gt; b &gt;&gt; c;\t\t\t// 离散化：第cnt个读取到的数映射为cnt\t\t\t// 若没有被离散化,则离散化\t\t\tif (!mp[a]) mp[a] = ++cnt;\t\t\tif (!mp[b]) mp[b] = ++cnt;\t\t\ta = mp[a], b = mp[b];\t\t\t// 相等,不相等分开处理\t\t\tif (c) eq.push_back({ a,b });\t\t\telse neq.push_back({ a,b });\t\t}\t\t// 先处理相等的\t\tfor (auto i : eq)\t\t{\t\t\tauto x = i.x, y = i.y;\t\t\tint px = find(x), py = find(y);\t\t\t// 不在一个集合,合并\t\t\tif (px != py) p[px] = py;\t\t}\t\t// 再处理不相等的\t\tbool fact = true;\t\tfor (auto i : neq)\t\t{\t\t\tauto x = i.x, y = i.y;\t\t\tint px = find(x), py = find(y);\t\t\tif (px == py)\t\t\t{\t\t\t\tfact = false;\t\t\t\tbreak;\t\t\t}\t\t}\t\tif (fact) puts(\"YES\");\t\telse puts(\"NO\");\t}\treturn 0;}\n\n\n\n容易发现，在这里离散化甚至不需要对原有的数进行排序，只需要按照读入顺序离散化就行，因为这里只需要区分出数的不同，不关系数字的大小性质，所以不需要那么严格的离散化\n结语\n实际上离散化的方式有很多，可按照题目要求自行设定，我一般喜欢用  映射来存储离散化关系，这样可以比较方便的读写离散化坐标\n记住离散化的特征：覆盖范围大，操作范围小\n\n","slug":"离散化","date":"2024-10-06T16:01:43.000Z","categories_index":"算法","tags_index":"基础算法,离散化","author_index":"Jerry"},{"id":"f65c2271ed43cdf14e2eea3c0c440d44","title":"前缀和与差分","content":"引入定义数组 \n 为  的前缀和数组，\n 为  的差分数组， \n前缀和与差分为一对互逆关系，类似高中时的数列通项  和前n项和  \n死去的记忆立马复活，这样一类比就清晰了许多吧~\n前缀和计算1for (int i = 1; i &lt;= n; i ++ ) b[i] = b[i - 1] + a[i];\n\n其实还是挺显然的\n应用  求片段和复杂度 \n\n例题差分由前面的定义其实能很快知道差分数组的计算，但这里笔者想介绍另一种方法，使得差分的计算和应用可以统一起来，少写一些代码\n先介绍差分的应用，便于直观理解差分数组的构造\n应用  区间修改给 在区间  添加上常数  \n观察 数组变化\n\n\n\n\n1\n……\n\n……\n\n\n……\n\n\n\n\n差分\n—\n—\n\n—\n—\n\n—\n—\n\n\n前缀和\n—\n—\n\n\n\n—\n—\n—\n\n\n即差分数组可以在  时间实现对一段区间修改\n1234void add(int l, int r, int c){    a[l] += c, a[r + 1] -= c;}\n\n计算可以用差分数组的定义来直接求出差分数组，但其实可以直接用差分数组的应用来构造差分数组\n初始化令 \n当  赋值  ，其实等价于  ,这样就可以直接用之前写好的  函数而不用再多写代码了\n12345// 构造b的差分数组avoid init(int b[]){\tfor (int i = 1; i &lt;= n; i ++ ) add(i, i, b[i]);}\n\n \n\n结语前缀和与差分是非常基础但是又经常会用到的算法优化思路，在很多算法题目中都会成为优化复杂度的关键一步，虽然简单，还是希望读者不要忽略其重要性 o(￣▽￣)ブ~\n","slug":"前缀和与差分","date":"2024-10-06T16:01:42.000Z","categories_index":"算法","tags_index":"基础算法,前缀和,差分","author_index":"Jerry"},{"id":"53896b079468d4c41963b2300dea196e","title":"KMP","content":"KMP算法引入 算法用于解决字符串匹配问题，判断字符串B是否为主串A的字串，复杂度为 (两个字符串的长度)\n对于朴素的字符串匹配问题，思路是，将A，B串从前到后一一匹配，如果就重新开始匹配，复杂度 \n显然这样做效率极低，因为字符串可能前后缀相同，即  可能没必要跳回到0，如下面的例子\n\n\n\n\n用数组  来存储  向前跳到的位置，则每次当  时，只是  串跳回到  的位置而不是重新再在  串找下一个位置重新匹配\n利用一些前面匹配过程的匹配信息，省去从头匹配再试之前错的过程，这样将大大降低复杂度\n思路讲解KMP算法的核心思路就是处理出  数组，下面介绍实现思路\n\n\n\n\n\n\n代码由前面的推导,其实知道第1位就能往下递推了,KMP的代码部分并不复杂,关键是能想到这里可以用递推，代码如下：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344// KMP算法#include &lt;iostream&gt;using namespace std;const int N = 1e5 + 10, M = 1e6 + 10;int n, m;char b[N], a[M]; // 和之前一样,长的A短的Bint ne[N];int main(){    cin &gt;&gt; n &gt;&gt; b + 1 &gt;&gt; m &gt;&gt; a + 1;        // 预处理ne数组,ne[1] = 0已经初始化好,从2开始    for (int i = 2, j = 0; i &lt;= n; i ++ )    {        // 如果匹配失败就回退,退无可退才停        while (j &amp;&amp; b[j + 1] != b[i]) j = ne[j];                // 匹配成功        if (b[j + 1] == b[i]) j ++ ;                // 匹配成功,ne[i] = j + 1,前面已经自增过了; 匹配不成功,j = 0, ne[i] = 0, 也没问题        ne[i] = j;    }            // KMP匹配    for (int i = 1, j = 0; i &lt;= m; i ++ )    {        // 匹配失败就回退,退无可退才停        while (j &amp;&amp; b[j + 1] != a[i]) j = ne[j];                // 匹配成功        if (b[j + 1] == a[i]) j ++ ;                // 匹配完毕        if (j == n) cout &lt;&lt; i - n &lt;&lt; \" \";    }        return 0;}\n\n\n\n","slug":"KMP","date":"2024-10-06T16:01:03.000Z","categories_index":"算法","tags_index":"字符串,KMP","author_index":"Jerry"},{"id":"bb7fb6071a1bfe6c506396917992c585","title":"数学--欧拉函数","content":"欧拉函数   引入 定义为  中与  互质的数的个数\n对  （分解质因数得)\n结论 \n思路埃氏筛法欧拉筛法单个数的欧拉函数 更新\n","slug":"数学-欧拉函数","date":"2024-10-06T16:00:08.000Z","categories_index":"算法","tags_index":"数论,欧拉函数","author_index":"Jerry"},{"id":"52c3d43467d5b3dc99c6cd71203838c1","title":"动态规划--状态压缩DP","content":"状态压缩DP引入在某些问题中，状态数非常多，用暴力搜索的方法（复杂度  ）无法解决，\n利用二进制数的思想，把每个状态用一个二进制数来表示，每一位的0/1代表某个点的两个状态，可以将复杂度优化至 \n例题洛谷P10447 最短 Hamilton 路径  精确覆盖问题，二进制存状态 + 预处理优化\n\n题目\n题目描述\n给定一张  个点的带权无向图，点从  标号，求起点  到终点  的最短 Hamilton 路径。 \nHamilton 路径的定义是从  到  不重不漏地经过每个点恰好一次。\n输入\n第一行输入整数 。\n接下来  行每行  个整数，其中第  行第  个整数表示点  到  的距离（记为 ）。\n对于任意的 ，数据保证 ， 并且 ​。\n ，\n输出\n输出一个整数，表示最短 Hamilton 路径的长度。\n样例输入 #1\n12345650 2 4 5 12 0 6 5 34 6 0 8 35 5 8 0 51 3 3 5 0\n\n样例输出 #1\n118\n\n\n\n分析\n题目要求求不重不漏走完每个点的总距离\n朴素想法是直接dfs搜索每一种顺序，取最小值，复杂度  ，肯定过不了\n考虑用状态压缩DP：\n状态表示： ：当前走完的城市的为状态  ，在第  个城市，的最短路径\n例如： 代表我已经走完了第0、2座城市，终点在第2座城市所花的最短路径\n状态计算：枚举上一个到的城市  然后取最小值，即 \n复杂度为  有点极限，不过应该够用\n为什么动态规划能优化那么多？\n动态规划（DP）的本质是通过将问题分解为多个子问题，并保存子问题的解来避免重复计算，从而高效地解决具有重叠子问题和最优子结构的问题。而dfs暴力搜索的方法就是因为把每个单体的信息存取的过多，又忽略了问题与子问题之间的转移关系，没有利用起他们之间的信息，导致复杂度太高\n代码\n12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int N = 20, INF = 0x3f3f3f3f;int n;int dp[1 &lt;&lt; N][N];int d[N][N];int main(){\tcin &gt;&gt; n;\tfor (int i = 0; i &lt; n; i++)\t\tfor (int j = 0; j &lt; n; j++)\t\t\tcin &gt;&gt; d[i][j];\tmemset(dp, 0x3f, sizeof dp);\tdp[1][0] = 0; // 初始化起点\t// 开始dp\tfor (int i = 2; i &lt; (1 &lt;&lt; n); i++)\t\tfor (int j = 0; j &lt; n; j++)\t\t\tif ((i &gt;&gt; j) &amp; 1) // 判断有没有可能终点在j\t\t\t\tfor (int k = 0; k &lt; n; k++)\t\t\t\t{\t\t\t\t\tif (j == k) continue;\t\t\t\t\tif ((i &gt;&gt; k) &amp; 1)\t\t\t\t\t\tdp[i][j] = min(dp[i][j], dp[i - (1 &lt;&lt; j)][k] + d[k][j]);\t\t\t\t}\tcout &lt;&lt; dp[(1 &lt;&lt; n) - 1][n - 1] &lt;&lt; endl;\treturn 0;}\n\n上述代码在暴力枚举  的时候多花了点时间,事实上我们可以把可能的  提前预处理好，这样可以降低一点复杂度\n\n优化代码\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;cstring&gt;using namespace std;const int N = 20;int n;int dp[1 &lt;&lt; N][N];int d[N][N];int num[1 &lt;&lt; N];vector&lt;int&gt; segs[1 &lt;&lt; N]; // 提前预处理可行解inline int lowbit(int x){\treturn x &amp; -x;}int main(){\tcin &gt;&gt; n;\t\tfor (int i = 0; i &lt; n; i ++ )\t\tfor (int j = 0; j &lt; n; j ++ )\t\t\tcin &gt;&gt; d[i][j];\t\tfor (int i = 0; i &lt; n; i ++ ) num[1 &lt;&lt; i] = i;\t    \tfor (int i = 1; i &lt; (1 &lt;&lt; n); i ++ )\t{\t\tint j = i;\t\twhile (j)\t\t{\t\t\tsegs[i].push_back(num[lowbit(j)]); // 预处理\t\t\tj -= lowbit(j);\t\t}\t}\t\tmemset(dp, 0x3f, sizeof dp);\tdp[1][0] = 0;\t\tfor (int i = 2; i &lt; (1 &lt;&lt; n); i ++ )\t\tfor (auto j : segs[i])\t\t\tfor (auto k : segs[i])\t\t\t{\t\t\t\tif (j != k)\t\t\t\t\tdp[i][j] = min(dp[i][j], dp[i - (1 &lt;&lt; j)][k] + d[k][j]);\t\t\t}\t\t\t\tcout &lt;&lt; dp[(1 &lt;&lt; n) - 1][n - 1] &lt;&lt; endl;\t\treturn 0;}\n\n\n\n洛谷P2704 炮兵阵地 二进制存状态 + 预处理优化\n\n题目\n题目描述\n司令部的将军们打算在  的网格地图上部署他们的炮兵部队。\n一个  的地图由  行  列组成，地图的每一格可能是山地（用  表示），也可能是平原（用  表示），如下图。\n在每一格平原地形上最多可以布置一支炮兵部队（山地上不能够部署炮兵部队）；一支炮兵部队在地图上的攻击范围如图中黑色区域所示：\n  \n如果在地图中的灰色所标识的平原上部署一支炮兵部队，则图中的黑色的网格表示它能够攻击到的区域：沿横向左右各两格，沿纵向上下各两格。\n图上其它白色网格均攻击不到。从图上可见炮兵的攻击范围不受地形的影响。\n现在，将军们规划如何部署炮兵部队，在防止误伤的前提下（保证任何两支炮兵部队之间不能互相攻击，即任何一支炮兵部队都不在其他支炮兵部队的攻击范围内），在整个地图区域内最多能够摆放多少我军的炮兵部队。\n输入\n第一行包含两个由空格分割开的正整数，分别表示  和 。\n接下来的  行，每一行含有连续的 ​ 个字符，按顺序表示地图中每一行的数据。\n，，保证字符仅包含 P 与 H。\n输出\n一行一个整数，表示最多能摆放的炮兵部队的数量。\n样例输入 #1\n1234565 4PHPPPPHHPPPPPHPPPHHP\n\n样例输出 #1\n16\n\n\n\n分析\n参照上一题的思路，可以用一个二进制数来存一行的大炮摆放情况，由于第  行状态受第  两行的影响，这里存多一维的状态\n状态表示：：摆完第  行,第  行摆放情况为  且第  行为  的所有数量\n状态计算：枚举第 ​ 行的合法情况取最大值即可\n几个细节：\n\n这样存3维内存为  不够用，由于我是一层一层更新，每一层只需要上一层的状态，可以用滚动数组优化  只用存2层的数据\n把一些可能的情况预处理出来，避免枚举加大复杂度\n\n\n代码\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;const int N = 110, M = 11;int n, m;int g[N]; // 存地图int dp[2][1 &lt;&lt; M][1 &lt;&lt; M]; // 滚动数组优化,第一维只有2vector&lt;int&gt; states; // 预处理可行状态int counts[1 &lt;&lt; M]; // 预处理每个状态放了多少炮兵int main(){    cin &gt;&gt; n &gt;&gt; m;        // 读取地图    char c;    for (int i = 1; i &lt;= n; i ++ )        for (int j = 0; j &lt; m; j ++ )        {            cin &gt;&gt; c;            if (c == 'H') g[i] += 1 &lt;&lt; j; // 每一行地形用二进制数表示,方便后面运算        }        // 预处理可行状态    for (int i = 0; i &lt; 1 &lt;&lt; m; i ++ )    {        // 行内互相打不到        if ((i &lt;&lt; 1) &amp; i || (i &lt;&lt; 2) &amp; i || (i &gt;&gt; 1) &amp; i || (i &gt;&gt; 2) &amp; i) continue;        states.push_back(i); // 合法单行状态    }        // 预处理counts    for (auto i : states)    {        int j = i, cnt = 0;        while (j)        {            cnt ++ ; \t\t// 炮兵数 + 1            j -= j &amp; (-j);  // lowbit\t\t}        counts[i] = cnt; \t// 状态i放了cnt个炮兵 \t}        // 开始DP    for (int i = 1; i &lt;= n + 2; i ++ )\t// 枚举到第n+2行,这样dp[n + 2][0][0]其实就是答案,不用再在dp[n][ ][ ]取最大值        for (auto a : states)\t\t \t// 第i行状态,预处理了之后直接就是合法状态,减少复杂度            for (auto b : states)       // 第i-1行状态                for (auto c : states)   // 第i-2行状态                {                    // 行间不能互打(竖着的没有交集)                    if (a &amp; b || a &amp; c || b &amp; c) continue;                                        // 行内放的符合地形→2进制存每行地图状态的优势                    if (g[i] &amp; a || g[i - 1] &amp; b) continue; // 可以不用检查c,因为c如果不合法的话不会被更新,一定是0                                        // 滚动数组优化                    dp[i &amp; 1][a][b] = max(dp[i &amp; 1][a][b], dp[i - 1 &amp; 1][b][c] + counts[a]);                    // 这里如果没有counts[a]就还需要再枚举计算a状态放了多少兵                }        cout &lt;&lt; dp[n + 2 &amp; 1][0][0] &lt;&lt; endl;        return 0;}\n\n\n\n洛谷P1896 互不侵犯 简化版的炮兵阵地\n\n题目\n题目描述\n在  的棋盘里面放  个国王，使他们互不攻击，共有多少种摆放方案。国王能攻击到它上下左右，以及左上左下右上右下八个方向上附近的各一个格子，共  个格子。\n输入\n只有一行，包含两个数 。\n，\n输出\n所得的方案数\n样例输入 #1\n13 2\n\n样例输出 #1\n116\n\n\n\n\n题解\n思路\n状态表示：  摆完前  行，第  行为状态  ，花了  个国王的方案数\n状态计算: 枚举第 行的合法状态 \n \n代码\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;vector&gt;using namespace std;typedef long long LL; // 开ll避免爆intconst int N = 11, M = 1 &lt;&lt; N;int n, k;LL dp[N][1 &lt;&lt; N][N * N];vector&lt;int&gt; states;   // 预处理合法状态int counts[1 &lt;&lt; N];   // 数1int main(){\tcin &gt;&gt; n &gt;&gt; k;\t\tfor (int i = 0; i &lt; 1 &lt;&lt; n; i ++ )\t{\t\tif (i &amp; (i &lt;&lt; 1) || (i &gt;&gt; 1) &amp; i) continue;\t\tstates.push_back(i);\t}\t\tfor (auto i : states)\t{\t\tint j = i, cnt = 0;\t\twhile (j)\t\t{\t\t\tcnt ++ ;\t\t\tj -= j &amp; (- j);\t\t}\t\tcounts[i] = cnt;\t}\t\t// 开始dp\tdp[0][0][0] = 1;\tfor (int i = 1; i &lt;= n + 1; i ++ ) // 枚举到第n + 1行,后面可以直接输出答案\t\tfor (auto a : states) \t\t// 第i行\t\t\tfor (auto b : states)   // 第i-1行            {            \t// 行间不互打            \tif (a &amp; b || (a &gt;&gt; 1) &amp; b || (a &lt;&lt; 1) &amp; b) continue;            \t            \t// 枚举花的国王数量            \tfor (int j = counts[b]; j &lt;= k - counts[a]; j ++ )            \t\tdp[i][a][j + counts[a]] += dp[i - 1][b][j];            }            \tcout &lt;&lt; dp[n + 1][0][k] &lt;&lt; endl;\t\t\treturn 0;}\n\n\n\n洛谷P2831 愤怒的小鸟 重复覆盖问题，预处理轨迹 \n\n题目\n题目描述\nKiana 最近沉迷于一款神奇的游戏无法自拔。\n简单来说，这款游戏是在一个平面上进行的。\n有一架弹弓位于  处，每次 Kiana 可以用它向第一象限发射一只红色的小鸟，小鸟们的飞行轨迹均为形如  的曲线，其中  是 Kiana 指定的参数，且必须满足 ， 都是实数。\n当小鸟落回地面（即  轴）时，它就会瞬间消失。\n在游戏的某个关卡里，平面的第一象限中有  只绿色的小猪，其中第  只小猪所在的坐标为 。\n如果某只小鸟的飞行轨迹经过了 ，那么第  只小猪就会被消灭掉，同时小鸟将会沿着原先的轨迹继续飞行；\n如果一只小鸟的飞行轨迹没有经过 ，那么这只小鸟飞行的全过程就不会对第  只小猪产生任何影响。\n例如，若两只小猪分别位于  和 ，Kiana 可以选择发射一只飞行轨迹为  的小鸟，这样两只小猪就会被这只小鸟一起消灭。\n而这个游戏的目的，就是通过发射小鸟消灭所有的小猪。\n这款神奇游戏的每个关卡对 Kiana 来说都很难，所以 Kiana 还输入了一些神秘的指令，使得自己能更轻松地完成这个游戏。这些指令将在【输入格式】中详述。\n假设这款游戏一共有  个关卡，现在 Kiana 想知道，对于每一个关卡，至少需要发射多少只小鸟才能消灭所有的小猪。由于她不会算，所以希望由你告诉她。\n输入\n第一行包含一个正整数 ，表示游戏的关卡总数。\n下面依次输入这  个关卡的信息。每个关卡第一行包含两个非负整数 ，分别表示该关卡中的小猪数量和 Kiana 输入的神秘指令类型。接下来的  行中，第  行包含两个正实数 ，表示第  只小猪坐标为 。数据保证同一个关卡中不存在两只坐标完全相同的小猪。\n如果 ，表示 Kiana 输入了一个没有任何作用的指令。\n如果 ，则这个关卡将会满足：至多用  只小鸟即可消灭所有小猪。\n如果 ，则这个关卡将会满足：一定存在一种最优解，其中有一只小鸟消灭了至少  只小猪。\n保证 ，，，输入中的实数均保留到小数点后两位。\n上文中，符号  和  分别表示对  向上取整和向下取整，例如：。\n输出格式\n对每个关卡依次输出一行答案。\n输出的每一行包含一个正整数，表示相应的关卡中，消灭所有小猪最少需要的小鸟数量。\n样例 #1\n样例输入 #1\n1234567891022 01.00 3.003.00 3.005 21.00 5.002.00 8.003.00 9.004.00 8.005.00 5.00\n\n样例输出 #1\n1211\n\n样例 #2\n样例输入 #2\n123456789101112131432 01.41 2.001.73 3.003 01.11 1.412.34 1.792.98 1.495 02.72 2.722.72 3.143.14 2.723.14 3.145.00 5.00\n\n样例输出 #2\n123223\n\n样例 #3\n样例输入 #3\n123456789101112110 07.16 6.282.02 0.388.33 7.787.68 2.097.46 7.865.77 7.448.24 6.724.42 5.115.42 7.798.15 4.99\n\n样例输出 #3\n16\n\n提示\n【样例解释1】\n这组数据中一共有两个关卡。\n第一个关卡与【问题描述】中的情形相同， 只小猪分别位于  和 ，只需发射一只飞行轨迹为  的小鸟即可消灭它们。\n第二个关卡中有  只小猪，但经过观察我们可以发现它们的坐标都在抛物线 上，故 Kiana 只需要发射一只小鸟即可消灭所有小猪。\n【数据范围】\n\n\n\n测试点编号\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n题解\n分析\n愤怒的小鸟大家都非常熟悉了，这题小鸟轨迹为抛物线\n题目要求我们找到最少的抛物线数量，可以经过所有的小猪\n其实题目本身还好，关键是要我们计算好每条轨迹，考了点数学\n由题意，轨迹为经过原点开口向下抛物线 \n只需2点即可确定这条抛物线（要求两点的横坐标不同） 利用韦达定理\n所以题目里  个点最多有  条抛物线\n只需预处理出这  条抛物线以及每条抛物线经过的点就可以进行状态压缩DP\n思路\n先读取所有点\n预处理第   ,  两点确定的抛物线和抛物线经过的点\n开始dp\n状态表示：  ：经过的点的状态的  所花的最少抛物线条数\n状态计算：枚举任意一个  没到达的点，更新未来状态  动态规划的另一种写法，更新未来状态\n代码\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#define x first#define y secondusing namespace std;typedef pair&lt;double, double&gt; PDD;const int N = 20;const double eps = 1e-6;int T;int n, m;PDD q[N]; // 存储坐标int path[N][N]; // 存抛物线int dp[1 &lt;&lt; N];inline int cmp(double x1, double x2){\t// 判断两点横坐标是否相等\tif (fabs(x1 - x2) &lt;= eps) return 0;\tif (x1 &gt; x2) return 1;\treturn -1;}int main(){\tcin &gt;&gt; T;\twhile (T--)\t{\t\tcin &gt;&gt; n &gt;&gt; m;\t\t// 读点\t\tfor (int i = 0; i &lt; n; i++)\t\t\tcin &gt;&gt; q[i].x &gt;&gt; q[i].y;\t\t// 预处理抛物线        memset(path, 0, sizeof path); // 初始化\t\tfor (int i = 0; i &lt; n; i++)\t\t{\t\t\tpath[i][i] |= (1 &lt;&lt; i); // 有些点只经过自己\t\t\tfor (int j = 0; j &lt; n; j++)\t\t\t{\t\t\t\t// 两点确定一个抛物线\t\t\t\tdouble x1 = q[i].x, x2 = q[j].x;\t\t\t\tdouble y1 = q[i].y, y2 = q[j].y;\t\t\t\t\t\t\t\tif (cmp(x1, x2) == 0) continue;\t\t\t\t// 两点合法,用韦达定理\t\t\t\tdouble a = (y1 / x1 - y2 / x2) / (x1 - x2);\t\t\t\tif (cmp(a, 0) &gt;= 0) continue; // 开口必须向下\t\t\t\tdouble b = y1 / x1 - a * x1;\t\t\t\t// 抛物线参数确定完毕,判断走过了哪些点\t\t\t\tfor (int k = 0; k &lt; n; k++)\t\t\t\t{\t\t\t\t\tdouble x = q[k].x, y = q[k].y;\t\t\t\t\tif (cmp(a * x * x + b * x, y) == 0) path[i][j] |= (1 &lt;&lt; k);\t\t\t\t}\t\t\t}\t\t}\t\t// 开始DP\t\tmemset(dp, 0x3f, sizeof dp); // 初始化\t\tdp[0] = 0;\t\tfor (int i = 0; i + 1 &lt; (1 &lt;&lt; n); i++)\t\t{\t\t\tint x = 0; // 状态i没有到达的点\t\t\tfor (int j = 0; j &lt; n; j ++ )\t\t\t\tif (((i &gt;&gt; j) &amp; 1) == 0)\t\t\t\t{\t\t\t\t\tx = j;\t\t\t\t\tbreak;\t\t\t\t}\t\t\t// 枚举经过x的每一条抛物线,更新未来状态\t\t\tfor (int j = 0; j &lt; n; j++)\t\t\t\tdp[i | path[x][j]] = min(dp[i | path[x][j]], dp[i] + 1);\t\t}\t\tcout &lt;&lt; dp[(1 &lt;&lt; n) - 1] &lt;&lt; endl;\t}\treturn 0;}\n\n\n\n\n\n\n\n来看看压轴题~~\n洛谷P3959 宝藏 状压优化最小生成树\n\n题目\n题目描述\n参与考古挖掘的小明得到了一份藏宝图，藏宝图上标出了  个深埋在地下的宝藏屋， 也给出了这  个宝藏屋之间可供开发的  条道路和它们的长度。\n小明决心亲自前往挖掘所有宝藏屋中的宝藏。但是，每个宝藏屋距离地面都很远，也就是说，从地面打通一条到某个宝藏屋的道路是很困难的，而开发宝藏屋之间的道路则相对容易很多。\n小明的决心感动了考古挖掘的赞助商，赞助商决定免费赞助他打通一条从地面到某个宝藏屋的通道，通往哪个宝藏屋则由小明来决定。\n在此基础上，小明还需要考虑如何开凿宝藏屋之间的道路。已经开凿出的道路可以 任意通行不消耗代价。每开凿出一条新道路，小明就会与考古队一起挖掘出由该条道路所能到达的宝藏屋的宝藏。另外，小明不想开发无用道路，即两个已经被挖掘过的宝藏屋之间的道路无需再开发。\n新开发一条道路的代价是 。其中  代表这条道路的长度， 代表从赞助商帮你打通的宝藏屋到这条道路起点的宝藏屋所经过的宝藏屋的数量（包括赞助商帮你打通的宝藏屋和这条道路起点的宝藏屋） 。\n请你编写程序为小明选定由赞助商打通的宝藏屋和之后开凿的道路，使得工程总代价最小，并输出这个最小值。\n输入\n第一行两个用空格分离的正整数 ，代表宝藏屋的个数和道路数。\n接下来  行，每行三个用空格分离的正整数，分别是由一条道路连接的两个宝藏屋的编号（编号为 ），和这条道路的长度 。\n ，，。\n输出\n一个正整数，表示最小的总代价。\n样例 #1\n样例输入 #1\n1234564 5 1 2 1 1 3 3 1 4 1 2 3 4 3 4 1\n\n样例输出 #1\n14\n\n样例 #2\n样例输入 #2\n1234564 5 1 2 1 1 3 3 1 4 1 2 3 4 3 4 2\n\n样例输出 #2\n15\n\n提示\n \n【样例解释 】\n小明选定让赞助商打通了  号宝藏屋。小明开发了道路 ，挖掘了  号宝藏。开发了道路 ，挖掘了  号宝藏。还开发了道路 ，挖掘了  号宝藏。\n工程总代价为 。\n【样例解释 】\n小明选定让赞助商打通了  号宝藏屋。小明开发了道路 ，挖掘了  号宝藏。开发了道路 ，挖掘了  号宝藏。还开发了道路 ，挖掘了  号宝藏。\n工程总代价为 。\n\n\n\n题解\n分析\n\n\n\n\n\n\n\n\n代码\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;cstring&gt;using namespace std;const int N = 12, M = 1 &lt;&lt; N, INF = 0x3f3f3f3f;int n, m;\t\t\t// 点数边数int d[N][N];\t\t// 邻接矩阵存图int dp[M][N], g[M]; // g[i]表示状态i可以拓展到的最大状态,用来判断状态转移是否合法int main(){\tcin &gt;&gt; n &gt;&gt; m;\t// 读图\tmemset(d, 0x3f, sizeof d);\tfor (int i = 0; i &lt; n; i++) d[i][i] = 0; // 点编号从0开始\t\tint a, b, c;\twhile (m--)\t{\t\tcin &gt;&gt; a &gt;&gt; b &gt;&gt; c;\t\ta--, b--;\t\td[a][b] = d[b][a] = min(d[a][b], c);\t // 防止重边,只取短边\t}\t// 开始预处理每个点集的拓展点集\tfor (int i = 1; i &lt; 1 &lt;&lt; n; i ++ )\t\tfor (int j = 0; j &lt; n;j ++ )\t\t\tif (i &gt;&gt; j &amp; 1)\t\t\t\t\t\t// 找i中点j\t\t\t\tfor (int k = 0; k &lt; n; k++)\t\t\t\t\tif (d[j][k] != INF)\t\t\t// j可拓展至k\t\t\t\t\t\tg[i] |= 1 &lt;&lt; k;  \t// 初始化\tmemset(dp, 0x3f, sizeof dp); \tfor (int i = 0; i &lt; n; i++) dp[1 &lt;&lt; i][0] = 0;\t\t // 通往地面免费\t\t// 开始dp\tfor (int i = 1; i &lt; 1 &lt;&lt; n; i ++ )\t\tfor (int j = (i - 1) &amp; i; j; j = (j - 1) &amp; i)\t\t\tif ((g[j] &amp; i) == i)\t\t\t\t\t\t// j可拓展至i--&gt;i为g[j]子集\t\t\t{\t\t\t\tint p = i ^ j;\t\t\t\t\t\t\t// 剩余的点\t\t\t\tint cost = 0;\t\t\t\tfor (int k = 0; k &lt; n; k ++ )\t\t\t\t\tif (p &gt;&gt; k &amp; 1)\t\t\t\t\t\t// 找t中的点到j中点的最短路\t\t\t\t\t{\t\t\t\t\t\tint t = INF;\t\t\t\t\t\tfor (int u = 0; u &lt; n; u++)\t\t\t\t\t\t\tif (j &gt;&gt; u &amp; 1)\t\t\t\t\t\t\t\tt = min(t, d[k][u]);\t\t\t\t\t\tcost += t;\t\t\t\t\t\t// 加上当前点的代价\t\t\t\t\t}\t\t\t\t// 枚举深度,一个个更新\t\t\t\tfor (int k = 1; k &lt; n; k++) dp[i][k] = min(dp[i][k], dp[j][k - 1] + cost * k);\t\t\t}\t// 寻找各个深度下的最小值\tint res = INF;\tfor (int i = 0; i &lt; n; i++) res = min(res, dp[(1 &lt;&lt; n) - 1][i]);\tcout &lt;&lt; res &lt;&lt; endl;\treturn 0;}\n\n\n\n结语状态压缩DP在状态的表示上其实都挺类似的，都是拿二进制0/1来表示状态，基本上都是在优化爆搜，优化包括预处理优化、位运算优化……\n如果爆搜复杂度过不了，不妨往状压DP想一想~\n","slug":"动态规划-状态压缩DP","date":"2024-10-06T15:58:38.000Z","categories_index":"算法","tags_index":"动态规划,状态压缩DP,lowbit","author_index":"Jerry"},{"id":"255c74842319a79aad2f8bcbbeafd0ea","title":"动态规划--树形DP","content":"树形DP1.引入特点：\n利用树的递归结构，通过dfs遍历定义和计算状态。\n每个节点的状态通常表示以该节点为根的子树的最优解\n\n考法：树的直径或最长路径\n找到树任意两个点的最长距离\n用dfs遍历树，分别计算左子树的深度和右子树的深度，更新全局最长路径\n\n树的最大独立集或最小覆盖集\n以某一个点为根的树，节点间有权值关系，要求选择最少的点或尽可能多的点\n每个节点只有选与不选两个状态，利用这个写出状态转移方程\n\n树上背包问题\n给定一棵有根树，每个节点有一个价值或权值，每个节点有一定数量的子节点，要求利益最大\n将依赖关系转化为一个组里的多样物品，进而演变为分组背包问题\n\n换根法或二次扫描法\n\n\n\n\n\n2.例题2.1 树上背包问题洛谷P1352 没有上司的舞会 树形DP经典题\n\n题目\n题目描述\n某大学有  个职员，编号为 。\n他们之间有从属关系，也就是说他们的关系就像一棵以校长为根的树，父结点就是子结点的直接上司。\n现在有个周年庆宴会，宴会每邀请来一个职员都会增加一定的快乐指数 ，但是呢，如果某个职员的直接上司来参加舞会了，那么这个职员就无论如何也不肯来参加舞会了。\n所以，请你编程计算，邀请哪些职员可以使快乐指数最大，求最大的快乐指数。\n输入\n输入的第一行是一个整数 。\n第  到第  行，每行一个整数，第  行的整数表示  号职员的快乐指数 。\n第  到第  行，每行输入一对整数 ，代表  是  的直接上司。\n，，，且给出的关系一定是一棵树。\n输出\n输出一行一个整数代表最大的快乐指数。\n样例输入 #1\n1234567891011121314711111111 32 36 47 44 53 5\n\n样例输出 #1\n15\n\n\n\n分析\n\n\n\n\n\n\n\n代码\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// 状态表示:dp[i][0]以i为根的子树,i不来 dp[i][1]以i为根的子树,i来 // 状态计算:记忆化搜索 #include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int N = 6e3 + 10;int n;int h[N], e[N], ne[N], idx; // 邻接表存int w[N];\t\t\t\t\t// 开心度int dp[N][2], root;bool st[N];void add(int a, int b){    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;}void dfs(int x){    dp[x][1] = w[x];    for (int i = h[x]; ~ i; i = ne[i])    {        int j = e[i];        dfs(j);                // i不来,j可来可不来        dp[x][0] += max(dp[j][0], dp[j][1]);        dp[x][1] += dp[j][0];    }}int main(){    cin &gt;&gt; n;        for (int i = 1; i &lt;= n; i ++ ) cin &gt;&gt; w[i];        memset(h, -1, sizeof h);    for (int i = 1; i &lt; n; i ++ )    {        int a, b;        cin &gt;&gt; a &gt;&gt; b;        add(b, a);        st[a] = true;    }        for (int i = 1; i &lt;= n; i ++ )        if (!st[i])        {            root = i;            break;        }            dfs(root); // 从根节点开始往下搜        cout &lt;&lt; max(dp[root][0], dp[root][1]) &lt;&lt; endl;        return 0;}\n\n\n\n洛谷P2014 选课 记忆化搜索+分组背包\n\n题目\n题目描述\n在大学里每个学生，为了达到一定的学分，必须从很多课程里选择一些课程来学习，在课程里有些课程必须在某些课程之前学习，如高等数学总是在其它课程之前学习。现在有  门功课，每门课有个学分，每门课有一门或没有直接先修课（若课程 a 是课程 b 的先修课即只有学完了课程 a，才能学习课程 b）。一个学生要从这些课程里选择  门课程学习，问他能获得的最大学分是多少？\n输入\n第一行有两个整数  ,  用空格隔开。(  ,  )\n接下来的  行,第  行包含两个整数 和 ,  表示第I门课的直接先修课， 表示第I门课的学分。若  表示没有直接先修课（ , ）。\n输出\n只有一行，选  门课程的最大得分。\n样例输入 #1\n123456787  42  20  10  42  17  17  62  2\n\n样例输出 #1\n113\n\n\n\n\n题解\n思路\n\n\n分组背包模板请点击动态规划–背包问题\n代码\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;iostream&gt;using namespace std;#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int N = 310;int n, m;int h[N], e[N], ne[N], idx;int w[N];int dp[N][N];void add(int a, int b){\te[idx] = b, ne[idx] = h[a], h[a] = idx++;}void dfs(int u){\t// 先考虑子节点,还不考虑父节点的价值\tint t = (u == 0); // 根节点不算体积\tfor (int i = h[u]; ~i; i = ne[i]) // 每个子节点视为一个组\t{\t\tint son = e[i];\t\tdfs(son); // 先记忆化搜索更新子节点\t\t// 开始套分组背包模板\t\tfor (int j = m - 1 + t; j &gt;= 0; j--) // 枚举花费的体积,这里是进行了降维优化的,所以降序,因为存在依赖关系,所以必须把父节点的体积腾出来\t\t\tfor (int k = 0; k &lt;= j; k++) // 枚举选哪件物品→每个体积都视作一个物品\t\t\t{\t\t\t\tdp[u][j] = max(dp[u][j], dp[u][j - k] + dp[son][k]); // dp[son][k]在dfs(son)之后已经更新过,代表这个体积下的最大价值\t\t\t}\t}\t// 把父节点考虑进来\tif (u != 0)\t{\t\tfor (int i = m; i &gt;= 1; i--) dp[u][i] = dp[u][i - 1] + w[u]; // 之前的dp[u][]没把父节点考虑进来,现在考虑进来了之后要重新更新\t\tfor (int i = 0; i &lt; 1; i++) dp[u][i] = 0; // 放不下父节点的选不了\t}}int main(){\tcin &gt;&gt; n &gt;&gt; m;\tmemset(h, -1, sizeof h);\tfor (int i = 1; i &lt;= n; i++)\t{\t\tint a;\t\tcin &gt;&gt; a &gt;&gt; w[i];\t\tadd(a, i);\t}\t    // 默认0号为根节点\tdfs(0);\tcout &lt;&lt; dp[0][m] &lt;&lt; endl;\treturn 0;}\n\n\n\n洛谷P2015 二叉苹果树 和上一题几乎一模一样，练练手吧~\n\n题目\n题目描述\n有一棵苹果树，如果树枝有分叉，一定是分二叉（就是说没有只有一个儿子的结点）\n这棵树共有  个结点（叶子点或者树枝分叉点），编号为 ，树根编号一定是 。\n我们用一根树枝两端连接的结点的编号来描述一根树枝的位置。下面是一颗有  个树枝的树：\n123452   5 \\ /   3   4   \\ /    1\n\n现在这颗树枝条太多了，需要剪枝。但是一些树枝上长有苹果。\n给定需要保留的树枝数量，求出最多能留住多少苹果。\n输入\n第一行  个整数  和 ，分别表示表示树的结点数，和要保留的树枝数量。\n接下来  行，每行  个整数，描述一根树枝的信息：前  个数是它连接的结点的编号，第  个数是这根树枝上苹果的数量。\n，每根树枝上的苹果 。\n输出\n一个数，最多能留住的苹果的数量。\n样例输入 #1\n123455 21 3 11 4 102 3 203 5 20\n\n样例输出 #1\n121\n\n\n\n\n题解\n分析\n\n\n\n\n思路\n\n\n\n\n代码\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int N = 110;int n, m;int h[N], e[2 * N], ne[2 * N], w[2 * N], idx;int dp[N][N];bool st[N];void add(int a, int b, int c){\te[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;}void dfs(int u){\t// 计算以u为根的子树在各个体积下的最小价值\tst[u] = true;\tfor (int i = h[u]; ~i; i = ne[i])\t{\t\tint son = e[i];\t\tif (st[son]) continue;\t\tdfs(son);\t\tfor (int j = m; j &gt;= 0; j--)\t\t\tfor (int k = 0; k &lt; j; k++)\t\t\t\tdp[u][j] = max(dp[u][j], dp[u][j - k - 1] + dp[son][k] + w[i]);\t}}int main(){\tcin &gt;&gt; n &gt;&gt; m;\tmemset(h, -1, sizeof h);\tfor (int i = 1; i &lt; n; i++)\t{\t\tint a, b, c;\t\tcin &gt;&gt; a &gt;&gt; b &gt;&gt; c;\t\tadd(a, b, c);\t\tadd(b, a, c);\t}\tdfs(1);\tcout &lt;&lt; dp[1][m] &lt;&lt; endl;\treturn 0;}\n\n\n\n\n\n\n\n\n\n2.2 最大独立集与最小覆盖集洛谷P2016 战略游戏 最小覆盖集\n\n题目\n题目背景\nBob 喜欢玩电脑游戏，特别是战略游戏。但是他经常无法找到快速玩过游戏的办法。现在他有个问题。\n题目描述\n他要建立一个古城堡，城堡中的路形成一棵无根树。他要在这棵树的结点上放置最少数目的士兵，使得这些士兵能瞭望到所有的路。\n注意，某个士兵在一个结点上时，与该结点相连的所有边将都可以被瞭望到。\n请你编一程序，给定一树，帮 Bob 计算出他需要放置最少的士兵。\n输入\n第一行一个整数 ，表示树中结点的数目。\n第二行至第  行，每行描述每个结点信息，依次为：一个整数 ，代表该结点标号，一个自然数 ，代表后面有  条无向边与结点  相连。接下来  个整数，分别是每条边的另一个结点标号 ，表示  与这些点间各有一条无向边相连。\n对于一个  个结点的树，结点标号在  到  之间，在输入数据中每条边只出现一次。保证输入是一棵树。\n \n输出\n输出文件仅包含一个整数，为所求的最少的士兵数目。\n样例输入 #1\n1234540 1 11 2 2 32 03 0\n\n样例输出 #1\n11\n\n\n\n\n题解\n思路\n状态表示：  ：以  为根的子树选与不选的最少士兵数目\n状态计算：\n选  ，子节点可选可不选 \n不选 ，子节点必须选 \n仍旧是记忆化搜索 + 树形DP\n代码\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int N = 1510;int n;int h[N], e[2 * N], ne[2 * N], idx;bool st[N];int dp[N][2];void add(int a, int b){\te[idx] = b, ne[idx] = h[a], h[a] = idx++;}void dfs(int u){\t// 处理出以u为根节点的最佳方案\tst[u] = true;\tfor (int i = h[u]; ~i; i = ne[i])\t{\t\tint j = e[i];\t\tif (!st[j])\t\t{\t\t\tdfs(j);\t\t\tdp[u][0] += dp[j][1];\t\t\tdp[u][1] += min(dp[j][0], dp[j][1]);\t\t}\t}\tdp[u][1] += 1;}int main(){\tcin &gt;&gt; n;\t// 存图\tmemset(h, -1, sizeof h);\tint a, b, x;\tfor (int i = 0; i &lt; n; i++)\t{\t\tcin &gt;&gt; a &gt;&gt; x;\t\twhile (x--)\t\t{\t\t\tcin &gt;&gt; b;\t\t\tadd(a, b), add(b, a);\t\t}\t}\tdfs(0);\tcout &lt;&lt; min(dp[0][1], dp[0][0]) &lt;&lt; endl;\treturn 0;}\n\n\n\n","slug":"动态规划-树形DP","date":"2024-10-06T15:58:28.000Z","categories_index":"算法","tags_index":"动态规划,树形DP","author_index":"Jerry"},{"id":"b1af6f6437b58f6d156f800c63cd3640","title":"数据结构与算法--week2","content":"1.链表反转\n题目\n题目描述：\n   下面所给的是链表节点的结构，你的任务是写一个函数将链表反转。\n12345678910struct ListNode {    int val;    ListNode *next;    ListNode(){        val=0;        next=NULL;    }    ListNode(int x) : val(x), next(NULL) {}    ~ListNode(){}};\n\n   上述结构定义在头文件ListNode.h中，而你所需实现的函数为：\n1ListNode* reverseList(ListNode* head);\n\n提示：请记得将头文件包含进去，即#include\"ListNode.h\" 。\nListNode.h\n1234567891011121314151617#ifndef ListNode_h#define ListNode_h#include&lt;iostream&gt;using namespace std;struct ListNode { int val; ListNode *next; ListNode(){  val=0;  next=NULL; } ListNode(int x) : val(x), next(NULL) {} ~ListNode(){}};#endif\n\n\n\n思路\n其实就是把链表指向的箭头反过来\n3个指针 一个一个来换方向\n注意判断边界\n代码\n123456789101112131415161718192021#include \"ListNode.h\"ListNode* reverseList(ListNode* head){\t// 至少有2个节点才需要反转\tif (head == NULL || head-&gt;next == NULL) return head;\t\tListNode* pre = NULL;\tListNode* cur = head;\tListNode* next = head-&gt;next;\t\twhile (cur != NULL)\t{\t\tcur-&gt;next = pre;\t\tpre = cur;\t\tcur = next;        if (next != NULL) next = next-&gt;next; // 防止越界\t}\t\treturn pre;}\n\n\n\n\n\n2.飞盘高手\n题目\n题目描述\n杰克是美国某小镇有名的飞盘高手。他掷飞盘的时候有一个习惯，在一叠飞盘中，从第一个飞盘（即位于顶端的飞盘）开始，从上往下依次编号为。当至少还有两个飞盘的时候，杰克通常会掷出一个飞盘，然后把新的第一个飞盘放到所有飞盘的最后。输入  ，输出每次扔掉的飞盘，以及最后剩下的飞盘。\n输入描述\n第一行为一个整数t（），表示测试用例个数。以下  行每行包含一个整数 （）,为一个测试用例的飞碟数。\n输出描述\n为每个测试用例单独输出一行，该行中依次输出每次掷出的飞盘编号以及最后剩下飞盘，每个飞盘后跟着一个空格。\n输入样例\n123274\n\n输出样例\n121 3 5 7 4 2 61 3 2 4\n\n\n\n思路\n直接用STL队列来模拟丢飞盘的过程就行了\n代码\n1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;int t; // 测试用例int n; // 飞盘数int main(){\tcin &gt;&gt; t;\t\twhile (t -- )\t{\t\tcin &gt;&gt; n;\t\tqueue&lt;int&gt; q; // 模拟丢飞盘过程\t\t\t\t// 初始化\t\tfor (int i = 1; i &lt;= n; i ++ ) q.push(i);\t\t\t\twhile (q.size())\t\t{\t\t\tauto s = q.front();\t\t\tq.pop();\t\t\t\t\t\tif (q.size() &gt;= 1) // 丢一个,移一个\t\t\t{\t\t\t\tcout &lt;&lt; s &lt;&lt; \" \";\t\t\t\t\t\t\t\tq.push(q.front());\t\t\t\tq.pop();\t\t\t}\t\t\telse cout &lt;&lt; s &lt;&lt; \" \"; // 直接丢\t\t}\t\t\t\tcout &lt;&lt; endl;\t}}\n\n\n\n\n\n3.简单字符串匹配\n题目\n题目描述\n给定两个字符串  和  ，要求判定  是否能够被  做循环移位（  ）得到的字符串包含。说明：字符串  和  中不包含空格，每个字符串至少包含一个字符。例如：给定 ，，则返回  ；给定  ，，则返回  \n输入描述\n第一行为整数 （），第  到  行为  个输入数据，每行包括两个字符串，字符串  和字符串  。字符串的长度不超过  。\n输出描述\n针对每个例子，如果  能够被  做循环移位得到的字符串包含，输出  ，否则输出  ；每个输出结果为独立的一行。\n输入样例\n1232AABCD CDAAABCD ACBD\n\n输出样例\n12TrueFalse\n\n\n\n思路\n设，容易发现，对于任意  循环移位后的串，必定是  的子串\n所以原题等价于判断  是否为 子串，直接用  函数就行\n代码\n123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;using namespace std;int t;string s1, s2;int main(){\tcin &gt;&gt; t;\t\twhile (t -- )\t{\t\tcin &gt;&gt; s1 &gt;&gt; s2;\t\t\t\tif (s1.size() &lt; s2.size())\t\t{\t\t\tputs(\"False\");\t\t\tcontinue;\t\t}\t\t\t\ts1 += s1;\t\t\t\tif (s1.find(s2) != -1) puts(\"True\");\t\telse puts(\"False\");\t}\t\treturn 0;}\n\n\n\n\n\n4.赛马问题\n题目\n问题描述\nA与B之间将进行一场赛马比赛，C为裁判。A与B分别拥有n匹马，这2n匹马中每匹马拥有的能力值都不相同。比赛前，参赛的两人先决定自己的马的出场顺序；比赛时，A的第一匹马将对战B的第一匹马，A的第二匹马将对战B的第二匹马，以此类推。在每一轮的比赛当中，能力值较高的马将获得胜利，并记其拥有者加1分。进行过n轮比赛之后，得分较高的人将获得最终的胜利，并赢得所有的马。当然，可能存在平局的情况，此时算作裁判C胜利，并获得所有的马。\n问：给定每一匹马的能力值，裁判C能否通过重新调整马匹参赛顺序而获得胜利？\n输入描述\n第一行输入一个整数n (1 &lt;= n &lt;= 100)。\n第二行输入n个整数，代表选手A所有马匹的能力值。\n第二行输入n个整数，代表选手B所有马匹的能力值。\n输出描述\n如果可以平局的话，则输出\"YES\"，否则输出\"NO\"。\n输入样例\n123456741 2 7 83 4 5 621 23 4\n\n输出样例\n12YESNO\n\n\n\n思路\n第一步先A，B的所有马能力从小到大排序\n目标是合理分配尽可能平局，我们有几种配对思路：\n①强对强\n②弱对弱\n③强对弱\n贪心：平局的条件是控制对局结果使A，B各赢一半，而我们最有可能能直接掌控局面的是强对弱的搭配（强对强和弱对弱双方势均力敌，而强对弱往往强方会赢\n接下来就是如何匹配强和弱了\n考虑A的第1匹马，我应该派B的哪匹马应战才最有利呢？\n派B的第n匹马  太浪费了\n派B的第1匹马  可能打不过\n结论是  派第匹最好\n类似的A的第  匹马匹配B的第 ​ 匹马是最优的情况\n平局要求A的前一半均输于B的后一半，而A的后一半均赢B的前一半\n也许你会问为什么一定是这样一一对应，下面证明这种匹配即为最优解\n只需证明倘若当前方案无法平局，其他方案也无法一定平局\n\n\n\n\n代码\n12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 110;int n;int a[N], b[N];int main(){\twhile (cin &gt;&gt; n)\t{\t\tcin &gt;&gt; n;\t\t\t\tfor (int i = 1; i &lt;= n; i ++ ) cin &gt;&gt; a[i];\t\tfor (int i = 1; i &lt;= n; i ++ ) cin &gt;&gt; b[i];\t\t\t\tif (n % 2)\t\t{\t\t\tputs(\"NO\");\t\t\tcontinue;\t\t}\t\t\t\t// 排序\t\tsort(a + 1, a + 1 + n);\t\tsort(b + 1, b + 1 + n);\t\t\t\tbool fact = true;\t\tfor (int i = 1; i &lt;= n / 2; i ++ )\t\t\tif (a[i] &gt;= b[i + n / 2] || b[i] &gt;= a[i + n / 2])\t\t\t{\t\t\t\tfact = false;\t\t\t\tbreak;\t\t\t}\t\t\t\t\tif (fact) puts(\"YES\");\t\telse puts(\"NO\");\t}\t\treturn 0;}\n\n\n\n\n\n5.放鸡蛋\n题目\n题目描述\n把M个同样的鸡蛋放在N个同样的篮子里，允许有的篮子空着不放，求共有多少种不同的放法？（用K表示）5，1，1和1，5，1 是同一种分法。请写一个程序来输出每一种放记鸡蛋的方法。\n输入格式\n第一行是一个数字t，表示有t个测试用例接下来的t行每一行有两个数字M和N，中间用空格隔开，表示有M个鸡蛋和N个篮子\n输出格式\n对于每一个用例，输出它不同的放法，每种放法占一行，格式是每个篮子的鸡蛋数量，按照数量降序排序。不同方法之间也是 降序排序。\n样例输入\n1217 3\n\n样例输出\n12345678700610520511430421331322\n\n\n\n思路\ndfs，明确几个约束：\n\n序列降序排序 得记住上一个放的数的值\n允许不放鸡蛋枚举到0\n\n代码\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int N = 1e3 + 10;int t;int n, m; // n个鸡蛋m个篮子int q[N]; // 存储方案void dfs(int cnt, int la, int u){\t// 已经放好了cnt个篮子,上一个放的是la,当前放了u个鸡蛋\tif (cnt == m)\t{\t\tif (u == n)\t\t{            // 合法放完了,直接输出\t\t\tfor (int i = 0; i &lt; m; i ++ ) cout &lt;&lt; q[i];\t\t\tcout &lt;&lt; endl;\t\t}\t\treturn;\t}\t    // 后面放的不能比前面多\tfor (int i = la; i &gt;= 0; i -- )\t\tif (u + i &lt;= n)\t\t{\t\t\tq[cnt] = i;\t\t\tdfs(cnt + 1, i, u + i);\t\t}}int main(){\tcin &gt;&gt; t;\t\twhile (t -- )\t{\t\tcin &gt;&gt; n &gt;&gt; m;\t\t        // 已经放好了0个篮子,上一个放的是n(使第一项从n开始枚举),已经放了0个鸡蛋\t\tdfs(0, n, 0);\t\t\t\tcout &lt;&lt; endl;\t}\t\treturn 0;}\n\n\n\n类似题目洛谷P10483 小猫爬山\n洛谷P2404 自然数的拆分问题\n洛谷P1120 小木棍\n","slug":"数据结构与算法--week2","date":"2024-10-05T11:16:27.000Z","categories_index":"算法","tags_index":"字符串,链表,队列,dfs,贪心","author_index":"Jerry"},{"id":"52118211d89fd171196f274fe2d94d19","title":"html+css+js笔记","content":"1.html1.1 文件结构html 文件以树的形式组织\n1.2 基本标签\n&lt;html&gt;: 根节点\n\n&lt;head&gt;: 规定文档相关的配置信息：标题、引用的文档样式、脚本\n\n设置 icon:\n\n\n\n\n\n\n\n&lt;body&gt;: 表示文档的内容，document.body 树形可以访问 body 元素脚本\n\n&lt;title&gt;: 定义文档标题，显示在浏览器标题栏上，只能包含文本，包含的任何标签的会被忽略\n\n\n\n\n&lt;meta&gt;: 剩余的均用 &lt;meta&gt; 标签表示\n常见属性：\n\ncharset\nname\n\n\n\n1.3 注释格式如下：\n123&lt;!-- this is a 注释--&gt;\n\n\n\n1.4 文本标签绝大部分标签本质都是一样的，只不过有些标签是根据大多数用户的需求进行了标准化\n\n&lt;div&gt;: 通用型流行内容容器，块状元素\n&lt;span&gt;: 行内元素\n\n比较：\n\n\n&lt;div&gt;自带前后回车&lt;span&gt;不带回车\n\n&lt;h1&gt; ~ &lt;h6&gt;: 六级标题\n\n&lt;p&gt;: 文本的一段，块级元素，自带回车\n其实就是加了前后行间距，自动过滤空格和回车\n\n\n\n\n**&lt;pre&gt;**：预定义格式文本，不会过滤换行和空格\n\n&gt;用&amp;gt\n&lt;用&amp;lt\n空格用nbsp\n\n\n**&lt;br&gt;**：在文本生成一个换行，在写诗和写地址的时候有用\n\n&lt;hr&gt; ：表示段落及元素之间主题转换（一个故事中场景的改变或一个章节主题的改变） 在可视化浏览器表现为水平线\n\n&lt;i&gt; ：区分普通文本的一系列文本，一般为斜体\n\n&lt;b&gt; ：加粗，替代方案是用 CSS font-weight 来创建粗体文字\n\n**&lt;del&gt;**： 表示一些被从文档中删除的文字内容，一般用于显示修改记录或者源代码差异的情况\n\n**&lt;ins&gt;**： 与 del 相反，表示加入的内容\n\n\n1.5 图片\nsrc：路径/地址\n\nalt：对文本表述，非强制性，当图片无法正常显示时展示\n\n\nheight：高度，单位是 CSS 像素\n\nwidth：宽度，单位是 CSS 像素\n\n\n1.6 音频与视频\n&lt;audio&gt;：嵌入音频，src 表示地址\n\n1234567891011&lt;!--自动播放--&gt;&lt;audio src=\"/audios/林俊杰 - 愿与愁.mp3\" autoplay&gt;\"/audios/愿与愁.mp3\"无法播放&lt;/audio&gt;&lt;!--手动播放--&gt;&lt;audio controls src=\"/audios/林俊杰 - 愿与愁.mp3\"&gt;\"/audios/愿与愁.mp3\"无法播放&lt;/audio&gt;&lt;!--一次存多个音源，前面不行就放后面的--&gt;&lt;audio controls&gt;        &lt;source src=\"/audios/林俊杰 - 愿与愁.mp3\" type=\"audio/mpeg\"&gt;\"/audios/愿与愁.mp3\"无法播放&lt;/source&gt;        &lt;source src=\"/audios/郭采洁 - 你在不在.mp3\" type=\"audio/mpeg\"&gt;\"/audios/你在不在.mp3\"无法播放&lt;/source&gt;&lt;/audio&gt;\n\n\n\n\n&lt;video&gt;：嵌入视频，src 表示地址\n\n1234567891011&lt;!--自动播放--&gt;&lt;video src=\"/videos/video1.mp4\" autoplay&gt;&lt;/video&gt;&lt;!--手动播放--&gt;&lt;video controls src=\"/videos/video1.mp4\"&gt;&lt;/video&gt;&lt;!--一次存好几个视频--&gt;&lt;video controls&gt;        &lt;source src=\"/videos/video1.mp4\" type=\"video/mp4\"&gt;\"/videos/video1.mp4\"无法播放&lt;/source&gt;        &lt;source src=\"/videos/video2.mp4\" type=\"video/mp4\"&gt;\"/videos/video2.mp4\"无法播放&lt;/source&gt;&lt;/video&gt;\n\n\n\n\n\n1.7 超链接&lt;a&gt;&lt;/a&gt;\n格式：\n12345678910111213&lt;!--href+地址,标签中间放显示内容--&gt;&lt;a href=\"https://www.baidu.com\"&gt;百度&lt;/a&gt;&lt;!--相对路径--&gt;&lt;a href=\"/about.html\"&gt;About&lt;/a&gt;&lt;!--内嵌其他标签--&gt;&lt;!--内嵌图片，则整个图片就是一个超链接--&gt;&lt;!--target的作用是新开一个页面，没有target的话就是在原界面跳转--&gt;&lt;a href=\"\\about.html\" target=\"_blank\"&gt;        &lt;img height=\"800\" width=\"1650\" src=\"/images/picture2.jpg\" alt=\"about\"&gt;        关于&lt;/a&gt;\n\n\n\n\n1.8 表单\n&lt;input&gt;\ntype=\"text\"：基础的单行文字\ntype=\"number\"：只能是数字\ntype=\"email\"：合法的邮箱地址\ntype=\"password\"：密码\ntype=\"radio\"：选择，同样 name 的 radio 只能选一个，要多选就得每个都命不同的名字\n\n\n\n\n\n12345678&lt;form&gt;        &lt;!--表头--&gt;        &lt;label for=\"username\"&gt;用户名&lt;/label&gt;        &lt;!--把输入数据绑定进来--&gt;        &lt;input type=\"text\" name=\"username\" id=\"username\"&gt;        &lt;!--加一个按钮--&gt;        &lt;button type=\"submit\"&gt;提交&lt;/button&gt;&lt;/form&gt;\n\n\n\n\n\n+action=””实现超链接功能  获取数据并跳转到下一个网页\n\n常见属性：\n\nname：名称\nid：唯一 id\nmaxlength：最大长度\nminlength：最小长度\nrequired：是否必填\nplaceholder：背景填充\n\n\n**&lt;textarea&gt;**：多行的框框，一个块区域\n\n\n\n\n\n&lt;select&gt;+&lt;option&gt;：选择框+选项\n\n\n\n默认选项： selected value\n1.9 列表&lt;ul&gt;&lt;li&gt;无序\n&lt;ol&gt;&lt;li&gt;有序\n1.10 表格\n\n\n\n1.11 语义标签\n\n\n\n1.12 特殊符号\n\n\n2.CSS理解 html 与 css：\nhtml 是素颜，css 是化妆\n一个是底层，一个是装饰\n2.1 样式定义方式\n行内样式表：只对当前标签作用\n\n加多一个 style 属性，里面存储所有样式\n12345678&lt;!--设置宽度--&gt;&lt;!--html--&gt;&lt;img width=\"300\" src=\"\"&gt;&lt;!--css--&gt;&lt;img src=\"\" style=\"width: 300px;\"&gt;&lt;!--一些例子--&gt;&lt;div style=\"width: 100%;height: 100%;background-color: black;\"&gt;&lt;/div&gt;\n\n\n内部样式表：对同个页面多个元素产生影响\n\n单独写一个 style 标签，对某些标签的样式专门定义一个类\n\n对于同一种标签，用 class 来区别不同种样式，**class 可以叠加**\n\n\n\n\n\n外部样式表\n\n在一般的网站制作过程，有很多样式不可能在一个界面完成设计，需要写在额外的文件中，这时候在&lt;head&gt;标签底下就要用&lt;link&gt;方式引入进来以使用样式\n\n\n注：style 里面的注释只能用/* */\n2.2 选择器\n标签选择器\n\n123456&lt;!--选择所有div标签--&gt;div {    width: 200px;    height: 200px;    backfground-color: gray;}\n\n\n\n\nID 选择器\n\n对 id 属性选择\n123456&lt;!--选择ID为rect-1的标签--&gt;#rect-1 {    width: 200px;    height: 200px;    background-color: red;}\n\n\n\n\n类选择器\n\n对 class 属性选择\n123456&lt;!--选择所有rectangle类的标签--&gt;.rectangle {    width: 200px;    height: 200px;    background-color: green; }\n\n\n\n\n伪类选择器\n\n就是一个后缀，在前面几类的基础上加上一些特殊情况\n→如当鼠标悬停在这时、长按时……\n\n\n\n\n\n复合选择器\n\n\n\n\n\n\n通配符选择器\n\n\n\n\n\n\n伪元素选择器\n\n\n\n\n\n2.3 颜色\n\n\n\n2.4 文本\n**text-align**：center,left,right,justify \n\n定义行内元素（如文字）如何相对其块状父元素对齐，text-align 不控制块元素自己对齐，只控制他的行内内容的对齐\n\n子标签继承父标签的对齐方式\n\n\n\n**line-height**：设置多行元素的空间量，如多行文本的间距，对于块级元素，指定元素行盒（line boxes）的最小高度，对于非替代的 inline 元素，它用于计算行盒（line box）的高度\n\n补充：长度单位\n\n\n\n\n\n\ntips：通过设置行高可以竖直居中\n\n**letter-space**：文本字符的间距\n\n\n\n\n\n**text-indent**：块元素首行文本内容之前的缩进量\n\n\n\n\ntext-decoration：设置修饰线外观→在 MDN 上直接搜用法就行\ntext-decoration-line\ntext-decoration-style\ntext-decoration-thickness\n\n\n\n删除一条链接的任何修饰：\n\n\n\n\n\ntext-shadow：为文字添加阴影\n\n4 个参数：坐标（2）+阴影模糊半径+颜色\n\n模糊半径越大字体模糊\n\n坐标方向：\n\n\n\n\n\n\n\n\n\n\n2.5 字体\nfont-size：设置字体大小\nfont-weight：设置字体粗细程度\n\n\n\nfont-family：设置字体类型（楷体、黑体、宋体……）\n\n通过一个有先后顺序的，由字体名或者字体族名组成的列表来为选定的元素设置字体，属性之间用逗号隔开，浏览器会选择列表中第一个该计算机上有安装的字体，或者是通过@font-face 指定的可以直接下载的字体\n\n\tserif→带衬线字体      sans-serif→不带衬线字体\n\nmonospace→等宽字体\n\ncursive→草书字体\n\nfantasy→艺术字体\n\n\n\nfont-style：选择 font-family 底下的 italic 或 oblique 样式\n\n\n\n\n2.6 背景\nbackground-color：设置背景颜色，置于最底层\n\nbackground-image：设置背景图像\n\n渐变色 linear-gradient（rgba（0， 0， 255， 0.5）， rgba（255， 255， 0， 0.5））\n\n多个图：中间用逗号隔开，越靠前的优先级越高\n123background-image: url('./images/p1.ipg),url('./images/p2.jpg');/* p1优先级高于p2 */backgrount-size: 100px 200px, 200px 100px;\n\n\nbackground-size：设置背景图片大小\n\n50% 50% 横纵比例\n200px 300px 大小\n\n\nbackground-repeat：设置背景图像沿水平轴、竖直轴，两个轴重复，或者根本不重复\n\nbackground-position：设置背景图片初始位置\n\ncenter     …px\n\n\nbackground-attachment：设置背景图像的位置实在视口内固定或者随着区块滚动\n\n\n2.7 边框可以四条边独立设置样式\n\nborder-style：CSS 简写属性，用来设定元素所有边框的样式\n\n12345678910111213141516/* Apply to all four sides */border-style: dashed;/* horizontal | vertical */border-style: dotted solid;/* top | horizontal | bottom */border-style: hidden double dashed;/* top | right | bottom | left */border-style: none solid dotted dashed;/* Global values */border-style: inherit;border-style: initial;border-style: unset;\n\n\nborder-width：设置盒子模型的边框宽度\nborder-color：设置元素四个边框颜色的快捷属性\nborder-top-color\nborder-right-color\nborder-bottom-color\nborder-left-color\n\n\nborder-radius：设置矩形边框 4 个角的样式\n可以用来设置非常神奇的样式\n\n\nborder-collapse：设置相邻格子是否共享边框，设置在&lt;table&gt;标签里\n\n2.8 元素展示格式\ndisplay: \nblock: &lt;div&gt;\n独占一行\nwidth、height、margin（外边距）、padding（内边距）均可控制\nwidth 默认 100%\n\n\ninline: &lt;span&gt;\n可以共占一行\nwidth 与 height 无效，水平方向的 margin 与 padding 有效，竖直方向的 margin 与 padding 无效\nwidth 默认为本身内容宽度\n\n\ninline-block: &lt;img&gt;\n可以共占一行\nwidth、height、margin、padding 均可控制\nwidth 默认为本身内容宽度\n\n\n\n\nwhite-space：设置如何处理元素中的空白\nnowrap：不自动换行，多的直接溢出\npre：保留文本里的换行（原格式）？\n\n\ntext-overflow：设置文本溢出文本框部分的处理\nhidden：截断，不显示\nellipsis：超出部分用省略号代替\n\n\noverflow：设置内容显示是否有滚轮，分为 overflow-x，overflow-y\nhidden：不显示滚轮\nauto：自动设置滚轮\n\n\n\n2.9 内外边距边距：最小距离\n\nmargin：外边距\n\n直接设定 4 个值（上右下左）\n\n分别指明 4 个方向：\n\nmargin-top\nmargin-right\nmargin-bottom\nmargin-left\n\n\n可取值：\n\nlength：固定值→xxpx\npercentage：相对于包含块的宽度的百分比\nauto：让浏览器自己选\n\n\n\n\n\npadding：内边距，用法和 padding 同\n\n元素最后大小=初始大小+内边距大小+边界大小\nwidth=content+padding+border\n\n\n\n2.10 盒子模型\nBox-sizing:\n设置元素总宽度和总高度，锁死\ncontent-box：默认值，设置 border，padding 均会增加元素的宽高\nborder-box：设置 border 和 padding 不会改变元素的宽高，而是挤占内容区域\n\n\n\n2.11 位置position：指定一个元素在文档中的定位方式\n\n2.11 浮动float: \nclear: \n2.12 flex 布局设置弹性项目如何增大或缩小以适应其弹性容器中可用的空间→更好布局各个模块\n\n主轴→    交叉轴↓    优先沿主轴方向，摆满后沿交叉轴方向延伸\n\n\n\n\n\n\n没有 flex\n\n\n加了 flex\n\n\n\n可见 flex 可以改变内部元素排列方式\n当内部元素总宽度/长度大于当前元素时，会自动压缩\n\n\nflex-direction: \n\nrow：默认摆放方式，从左往右，从上往下\nrow-reverse：从右往左，从上往下\ncolumn：从上往下，从左往右\ncolumn：从下往上，从左往右\n\n\nflex-wrap:\n\n设置换行\nnowrap：默认，不换行\nwrap：换行，第一行在上\nwrap-reverse：换行，第一行在下\n\n\nflex-flow:\n\ndirection 和 wrap 一起设置\n\n\njustify-content: \n\n定义了浏览器之间如何分配顺着弹性容器主轴的元素之间及其周围的空前\n\nflex-start：默认，左对齐\n\n\nflex-end：右对齐\n\n\ncenter：居中\n\n\n\nspace-between：左右两端对齐，紧贴边缘\n\n\nspace-around：每行均匀分配元素，相邻元素距离相同，每行第一个元素到行首的距离和每行最后一个元素到行尾的距离会是相邻元素之间距离的一半\n\n\nspace-evenly：flex 项都沿着主轴均匀分布在指定的对齐容器中。相邻 flex 项之间的间距，主轴起始位置到第一个 flex 项的间距，主轴结束位置到最后一个 flex 项的间距，都完全一样\n\n\n\nalign-items:\n\n\n将所有直接子节点上的 align-self 值设置为一个组。 align-self 属性设置项目在其包含块中在交叉轴方向上的对齐方式。\n\nflex-start：元素向交叉轴起点对齐。\n\n\n\nflex-end：元素向交叉轴终点对齐。\n\n\n\n\n\ncenter：元素在侧轴居中，沿交叉轴居中。\n\nstretch：当没有设置高度时，弹性元素被在侧轴方向被拉伸到与容器相同的高度或宽度。\n\n\n\n\n\nalign-content:\n\n设置了浏览器如何沿着弹性盒子布局的纵轴和网格布局的主轴在内容项之间和周围分配空间。\n\nalign-items行在整个容器内均匀分布； 有行距，align-content没行距\n\nflex-start：所有行从垂直轴起点开始填充。第一行的垂直轴起点边和容器的垂直轴起点边对齐。接下来的每一行紧跟前一行。\n\nflex-end：所有行从垂直轴末尾开始填充。最后一行的垂直轴终点和容器的垂直轴终点对齐。同时所有后续行与前一个对齐。\n\ncenter：所有行朝向容器的中心填充。每行互相紧挨，相对于容器居中对齐。容器的垂直轴起点边和第一行的距离相等于容器的垂直轴终点边和最后一行的距离。\n\nstretch：拉伸所有行来填满剩余空间。剩余空间平均地分配给每一行。\n\norder\n\n\n决定元素展示顺序，值越小越靠前\n\nflex-grow:\n\n设置 flex 项主尺寸的 flex 增长系数，默认 0，负值无效\n\nflex-shrink:\n\n指定了 flex 元素的收缩规则。flex 元素仅在默认宽度之和大于容器的时候才会发生收缩，其收缩的大小是依据 flex-shrink 的值，负值无效，默认为 1。\n\nflex-basis:\nwidth 值可以是 &lt;length&gt;； 该值也可以是一个相对于其父弹性盒容器主轴尺寸的百分数 。负值是不被允许的。默认为 auto。\n\n\n\n2.13 响应式布局适配不同设备的布局\n\nmedia 查询\n\n在特定屏幕宽度应用特定 CSS→在不同环境写不同 CSS\n\n设备大小：\nxs:极小\nsm:小\nmd:中等\nlg:大\nxl:极大\n\n\n可以用 bootstrap 包来设计响应式布局，class 里面多叠几个就行\n\n3.JS绝大部分在前端执行，后端 JS 要用 NodeJS，有更多选择方案所以一般不用 JS\n3.1 调用和执行方式\n使用方式：\n在 html 页面任意位置上加上&lt;script type=\"module\"&gt;&lt;/script&gt;标签\n\n\n\n（ECMAScript6 写法）\n\n直接引入文件：\n1&lt;script type=\"module\" src=\"/static/js/index.js\"&gt;&lt;/script&gt;\n\n将所需的代码通过import关键字引入到当前作用域\n\n执行顺序：\n\n类似于 html 和 css，从上向下\n\n事件驱动执行\n\n\n\nhtml、css、js 之间的关系：\n\ncss 控制 html\njs 控制 html 和 css\n为了方便开发和维护，尽量按照上述顺序写代码，不要再 html 中调用 js 里面的函数\n\n\n\n3.2 变量与运算符\nlet和const：let 变量，const 常量，不需要声明类型，js 里面类型是动态的\n\n变量类型：\n\nnumber：数值\n\nstring：字符串，不区分单双引号；每一位都是只读变量，不允许改变，要改变只能创建新的字符串来存，例如：\n123let s1 = \"acwing\";let s2 = s1.substr(0, 1) + 'x' + s1.substr(2); // s2 = \"axwing\"\n\n\nboolean：布尔\n\nobject：对象，类似于 C++里面的指针，例如：[1, 2, 3]，{name: \"lgj\", age: 18}\n12345678910111213141516171819let d = {    name: 'jerry', // 前面的name可加可不加引号    age: 18,};console.log(d[\"name\"]); // map输出，必须加引号，同时这里允许动态变值console.log(d.name); // 点输出let key = \"name\";console.log(d[key]); // 允许console.log(d.key); // 不允许// 字典允许动态添加属性d.school = \"sysu\"; // 添加school属性// 遍历字典for (let key in d) {    console.log(d[key]);}\n\nundefined：未定义的变量\n\n输出变量类型：\n\nconsole.log(typeof x)\n\n\n\n3.3 输入与输出\n输入：\n从 html 与用户的交互中输入信息，例如通过input，textarea等标签获取用户键盘输入，通过click，hover等事件获取用户鼠标输入\n通过ajax与websocket从服务器端获取输入\n标准输入\n\n\n输出：\n调试用console.log，输出到浏览器控制台\n改变当前页面的 html 和 css\n通过ajax与websocket将结果返回到服务器\n\n\n格式化字符串：\n\n\n\n\n\n3.4 判断和循环语句同 C++\n3.5 对象一个字典，类似于 map，由key:value对构成\nkey均为字符串，但是可以不加引号\nvalue可以是字符串、数组、数值、函数…………\n\nvalue可以是变量，数组，对象，函数等\n函数中的this用来引用该函数的拥有者\n\n例如：\n12345678let person = {    name: \"yxc\";      age: 18,    money: 0,    add_money: function (x) {        this.money += x;    }}\n\n对象属性与函数的调用方式：\n\nperson.name、person.add_money(): \n简洁，但是关键字不可动态变化\n\n\nperson[\"name\"]、person[\"add_money\"]()\n繁琐，但是关键字可以动态变化\n\n\n\n3.6 数组\n特殊的对象，元素的变量类型是动态的\n\n如：\n\njavascriptlet a = ['lgj', 18, 175, 65]\n&lt;!--code￼15--&gt;\n可以通过这种访问方式动态赋值，甚至允许改变元素的类型\n\njs 里面没有下标越界概念，遇到没有定义的位置直接返回undefined，不会报错，甚至允许负下标的存在\n\n数组的长度：最大下标 + 1\n\n\n\n常用api\n\nlength：返回数组长度，注意是属性，不加()\n\npush()：添加元素\n\npop()：弹出元素\n\nsplice(a, b)：删除从 a 开始的 b 个元素\n\nsort()：默认从小到大排序，对整个数组排序\n\n自定义比较函数：array.sort(cmp)函数cmp输入两个比较的元素，返回一个实数\n\n例：\n1234567891011121314151617// 给数组降序排序let a = [5, 3, 2, 4, 1];let main = function() {    console.log(a);        a.sort(function(x, y) {        x = parseInt(x), y = parseInt(y);        return y - x;    });        console.log(a);};export {    main};\n\n\n\n\n\n\n\n3.7 函数类型为function，依靠对象实现\n\n定义方式：一共有 3 种\n\n1234567891011121314// 直接定义函数function add (a, b) {    return a + b;};// 声明函数变量let add = function (a, b) {        return a + b;};// 第二种方法的等价写法，如果只有一个参数可以不加括号let add = (a, b) =&gt; {    return a + b;};\n\n\n可以不按照函数的定义格式传入参数，没有传入的参数默认为undefined，由于这样 js 里面应该是不存在函数重载的，太随意了吧\n函数返回值默认是undefined\n\n3.8 类与C++的class类似，但是不存在私有成员\n一般用驼峰命名法，即每个单词首字母大写\n\n定义\n\n123456789101112131415161718192021222324252627class Point {    // 构造函数    constructor(x, y) {        this.x = x;        this.y = y;    }        // 类内函数不用加function关键字    init() {        this.sum = this.x + this.y;    }        toString() {        return `(${this.x}, ${this.y})`;    }}let main = function () {    // 生成类对象    let p = new Point(3, 4);    console.log(p.x, p.y);    console.log(p.toString());}export {    main}\n\n\n继承：用extends关键字\n\n123456789101112clsss ColorPoint extends Point {    constructor(x, y, color) {        // 必须先调用基类构造函数        super(x, y); // 这里的super是一个函数，特指基类的构造函数        this.color = color;    }        // 派生类的成员函数会覆盖基类的成员函数    toString() {        return `${this.color} ${super.toString()}`; // 这里的super代表的是基类对象    }}  \n\n\n静态方法：加static关键字\n和C++类似，属于所有类对象的共有成员\n静态方法不会被类的实例继承，需要通过类名访问\n\n\n\n1234567891011121314151617181920212223class Point {    // 构造函数    constructor(x, y) {        this.x = x;        this.y = y;    }        // 类内函数不用加function关键字    init() {        this.sum = this.x + this.y;    }        static print_class_name() {        console.log(\"Point\");    }}let main = function() {    let p = new Point(3, 4);        console.log(p.print_class_name());     // 错误，静态对象不允许直接访问    console.log(Point.print_class_name()); // 正确，用类名调用静态对象   }\n\n\n静态变量：\n和静态对象类似，和类本身绑定\n\n\n\n1234567891011121314151617class Point {    // 构造函数    constructor(x, y) {        this.x = x;        this.y = y;                Point.cnt ++ ;    }        // 类内函数不用加function关键字    init() {        this.sum = this.x + this.y;    }}// 静态变量定义：在类外Point.cnt = 0;\n\n\n\n3.9 事件js 代码一般通过事件触发，即通过事件实现对 CSS 和 html 的操控\n可以通过addEventListener函数为元素绑定事件的触发函数\n常见的触发函数有：\n\n鼠标\n\nclick：左键点击\ndblclick：左键双击\ncontextmenu：右键点击\nmousedown：鼠标按下，包括左键、滚轮、右键\nevent.button：0 表示左键，1 表示中键，2 表示右键\nevent.clientX：鼠标按下的位置\n其余的属性可以上 MDN 上搜索\n\n\nmouseup：鼠标弹起，包括左键、滚轮、右键\nevent.button：同上\n\n\n\n\n键盘\n\nkeydown：某个键是否被按住，事件会连续触发\nevent.code：返回被按住的键\nevent.altKey，event.ctrlKey，event.shiftKey分别表示alt，ctrl，shift是否被按住\n\n\nkeyup：某个键是否被释放\nevent：同上\n\n\nkeypress：紧跟在keydown事件后触发，只有按下字符键时触发\n\n\n\n表单\n\nfocus：聚焦某个元素\nblur：取消聚焦某个元素\nchange：某个元素的内容发生改变\n\n\n窗口\n\n需要作用到window元素上\nresize：窗口大小发生变化\nscroll：滚动指定的元素\nload：元素加载完成\n\n\n\n3.10 常用库3.10.1 jQuery让 js 更方便联系前端元素\n\n使用方式\n\n在元素中添加：\n\n按 jQuery 官网提示下载\n\n\n选择器\n\n$(selector) ，例如：\n123$('div');$('.big-div');$('div &gt; p');\n\n\n\nselector类似于 CSS 选择器\n\n事件\n\n$(selector).on(event, func)绑定事件，例如：\n123$('div').on('click', function(e) {    console.log(\"click div\");});\n\n$(selector).on(event, func)解绑事件，例如：\n12345$('div').on('click', function(e) {        console.log(\"click div\");    $('div').off('click');});\n\n当存在多个相同类型的事件触发函数时，可以通过click.name来区分，例如：\n12345$('div').on('click.first', function (e) {    console.log(\"click div\");    $('div').off('click.first');});\n\n在事件触发的函数中的return false等价于同时执行：\n\ne.stopPropagation()：阻止事件向上传递\ne.preventDefault()：阻止事件的默认行为\n\n\n\n\n元素的隐藏、展现\n\n$A.hide()：隐藏，参数表示消失时间\n$A.show()：展现，参数表示出现时间\n$A.fadeOut()：慢慢消失，参数表示消失时间\n$A.fadeIn()：慢慢出现，参数表示出现时间\n\n\n元素的添加、删除\n\n$('&lt;div class=\"mydiv\"&gt;&lt;span&gt;Hello World&lt;/span&gt;&lt;/div&gt;')构造一个jQuery对象\n$A.append($B)：将$B添加到$A的末尾\n$A.prepend($B)：将$B添加到$A的前面\n$A.remove()：删除元素$A\n$A.empty()：清空元素$A的所有儿子\n\n\n对类的操作\n\n$A.addClass(class_name)：添加某个类\n$A.removeClass(class_name)：删除某个类\n$A.hasClass(class_name)：判断某个类是否存在\n\n\n对 CSS 操作\n\n$(\"div\").css(\"background-color\")：获取某个 CSS 的属性\n\n$(\"div\").css(\"background-color\",\"yellow\")：设置某个 CSS 的属性\n\n同时设置多个 CSS 的属性：\n12345$('div').css({    width: \"200px\",    height: \"200px\",    \"background-color\": \"orange\",});\n\n\n对标签属性的操作\n\n\n$('div').attr('id')：获取属性\n$('div').attr('id', 'ID')：设置属性\n\n对 HTML 内容、文本的操作\n\n不需要背每个标签该用哪种，用到的时候 Google 或者百度即可。\n$A.html()：获取、修改 HTML 内容\n$A.text()：获取、修改文本信息\n$A.val()：获取、修改文本的值，常用在&lt;input&gt;上\n\n查找\n\n$(selector).parent(filter)：查找父元素\n$(selector).parents(filter)：查找所有祖先元素\n$(selector).children(filter)：在子元素中查找\n$(selector).find(filter)：在所有后代元素中查找\n\n\najax\n\n\n从服务器端获取JSON数据，不用刷新界面\n\nGET 方法：\n\n12345678910$.ajax({    url: url, // 后端链接    type: \"GET\",    data: {    },    dataType: \"json\",    success: function (resp) {    },});\n\n\nPOST 方法：\n\n12345678910$.ajax({    url: url,    type: \"POST\",    data: {    },    dataType: \"json\",    success: function (resp) {    },});\n\n3.10.2 setTimeout与setInterval返回number型数据，代表当前函数的唯一ID\n1setTimeout(func, delay)`：`delay`毫秒之后执行函数`func()\n\nclearTimeout()：关闭定时器，如：\n12345let timeout_id = setTimeout(() =&gt; {    console.log(\"Hello World!\");}, 2000);    // 2秒之后输出\"Hello World!\"clearTimeout(timeout_id);     // 清除定时器\n\nsetInterval(func, delay)：每隔delay毫秒执行func()，第一次在第delay毫秒执行\nclearInterval()：关闭周期执行的函数，如：\n12345let interval_id = setInterval(() =&gt; {    console.log(\"Hello World!\");}, 2000);    // 每隔2秒输出一次\"Hello World!\"clearInterval(interval_id);    // 清除周期执行的函数\n\n3.10.3 requestAnimationFramerequestAnimationFrame(func):\n在下次浏览器刷新(重新渲染之前)执行一次，通胀会用递归写法使其每秒执行60次func函数\n1234567let step = (timestamp) =&gt; {  // 每帧将div的宽度增加1像素    let div = document.querySelector('div');    div.style.width = div.clientWidth + 1 + 'px';    requestAnimationFrame(step);};requestAnimationFrame(step);\n\n与setTimeout和setInterval的区别：\n\nrequestAnimationFrame渲染动画的效果更好，性能更佳。\n\n该函数可以保证每两次调用之间的时间间隔相同，但setTimeout与setInterval不能保证这点。setTmeout两次调用之间的间隔包含回调函数的执行时间；setInterval只能保证按固定时间间隔将回调函数压入栈中，但具体的执行时间间隔仍然受回调函数的执行时间影响。\nsetTimeout：\n\n\n\n\nsetInterval:\n\n\n\n当页面在后台时，因为页面不再渲染，因此requestAnimationFrame不再执行。但setTimeout与setInterval函数会继续执行。\n\ncancelAnimationFrame：停止requestAnimationFrame\n\n\n3.10.4 Map与Set\nMap：保存键值对,不能排序\n\n用for...of或者forEach可以按插入顺序遍历\n123456789// for...offor (let [key, value] of map) {    console.log(key, value);}// forEachmap.forEach(function(value, key) {    console.log(key, value);}) \n\n键值可以为任意值 ，包括函数、对象或任意基本类型\n\n\n\n\n常用API：\n\nset(key, value)：插入键值对，如果key已存在，覆盖原有的value\n\nget(key)：查找关键字，如果不存在，返回undefined\n\nsize：返回键值对数量\n\nhas(key)：是否包含关键字key\n\ndelete(key)：删除关键字key\n\nclear()：删除所有元素\n\nSet：存储任何类型的唯一值，无论是原始值或者是对象引用\n\n用for...of或者forEach可以按插入顺序遍历\n常用API：\nadd()：添加元素\nhas()：是否包含元素\nsize：返回元素数量\ndelete()：删除某个元素\nclear()：删除所有元素\n\n\n\n3.10.5 localStorage在用户的浏览器上存储键值对，刷新后仍旧存在\n常用API：\n\nsetItem(key, value)：插入\ngetItem(key)：查找\nremoveItem(key)：删除\nclear()：清空\n\n3.10.6 JSON用于序列化对象、数组、数值、字符串、布尔值和null\n常用API：\n\nJSON.parse()：将字符串解析成对象\nJSON.stringify()：将对象转化为字符串\n\n123456789let obj = {    name: 'lgj',    age: 19,}let str = JSON.stringify(obj); // 字符串转JSONlet new_obj = JSON.parse(str); // JSON转字符串console.log(str);console.log(new_obj);\n\n3.10.7 日期返回值为整数的API，数值为1970-1-1 00:00:00 UTC（世界标准时间）到某个时刻所经过的毫秒数：\n\nDate.now()：返回现在时刻。\nDate.parse(\"2022-04-15T15:30:00.000+08:00\")：返回北京时间2022年4月15日 15:30:00的时刻。\n\n与Date对象的实例相关的API：\n\nnew Date()：返回现在时刻。\nnew Date(\"2022-04-15T15:30:00.000+08:00\")：返回北京时间2022年4月15日 15:30:00的时刻。\n两个Date对象实例的差值为毫秒数\ngetDay()：返回星期，0表示星期日，1-6表示星期一至星期六\ngetDate()：返回日，数值为1-31\ngetMonth()：返回月，数值为0-11\ngetFullYear()：返回年份\ngetHours()：返回小时\ngetMinutes()：返回分钟\ngetSeconds()：返回秒\ngetMilliseconds()：返回毫秒\n\n3.10.8 WebSocket与服务器建立全双工连接。\n常用API：\n\nnew WebSocket('ws://``localhost:8080``');：建立ws连接。\nsend()：向服务器端发送一个字符串。一般用JSON将传入的对象序列化为字符串。\nonopen：类似于onclick，当连接建立时触发。\nonmessage：当从服务器端接收到消息时触发。\nclose()：关闭连接。\nonclose：当连接关闭后触发。\n\n","slug":"html-css-js","date":"2024-09-30T09:19:16.000Z","categories_index":"技术","tags_index":"html,css,js","author_index":"Jerry"},{"id":"d6ffd179ab68b0daa56addeeaeb71166","title":"GPT获取sso信息出错","content":"尝试登陆GPT账号发现报错rt\n\n\n解决\n在网址的“auth”中加个0，改成https://auth0.openai.com//authorize?client这种形式再登录。\n\n\n正常登录\n\n\n\n\n参考的是以下文章：\nchatGPT获取sso信息出错解决方法_获取您的 sso 信息时出错-CSDN博客\n","slug":"GPT获取sso信息出错","date":"2024-09-30T08:43:11.000Z","categories_index":"","tags_index":"GPT","author_index":"Jerry"},{"id":"bbe13304b560081099040d9e49fec292","title":"初级实训作业1-贪吃蛇","content":"其实之前已经写过一个贪吃蛇小游戏网站了，可惜当时重心放在后端的匹配系统和贪吃蛇bot的代码运行上，前端做的稍微简陋了一点\n这次恰好利用Qt，把整体游戏界面做的更丰满一些o(￣▽￣)ブ\n1.安装Qt参考教程\n2.创建项目\n\n\n\n\n\n\n构建系统—qmake\nDetails—Base class—QWidget\n\n\n\n\n新项目创建完毕\n\n\n运行效果—白框框\n3.整体设计蛇身 + 地图 + 道具掉落（种类多设计一点） +生命值 + 计分板 + 难度调节器（调节速度）\n设计：初始设定：积分 0\n道具：\n①food：长度+1，积分+10\n②wall：障碍物 碰到停止\n③咬到自己：死\n基本流程：①调节难度，开始游戏\n②读取键盘输入\n②处理方向更新\n③处理蛇身更新\n④处理道具更新\n⑤判断是否死亡\n⑥全体布局确定，渲染地图\n最初版效果图如下：\n\n\n\n\n\n\n更新：\n\n\n4.Code(1)基本API及思路待更新 \n应该……20号之前会写完的罢\n","slug":"初级实训大作业1-贪吃蛇","date":"2024-09-29T15:18:32.000Z","categories_index":"小游戏","tags_index":"Qt","author_index":"Jerry"},{"id":"e9c911dbfeb3b82e631b7a70a15f2cf2","title":"动态规划--区间DP","content":"区间DP引入区间DP主要用于解决涉及区间分割与合并的动态规划问题。\n在这类问题中，我们往往会关注一段区间上的某种性质（方案数、组合数、最大值……）\n而区间DP的状态转移则是枚举区间划分的最后一步，把区间一分为二，利用小的区间求得的值求得整个区间的值\n由于大区间依赖小区间，所以长度都是从小遍历到大\n一起到例题中看看吧~\n例题洛谷P1880 石子合并\n题目\n题目描述\n在一个圆形操场的四周摆放  堆石子，现要将石子有次序地合并成一堆，规定每次只能选相邻的  堆合并成新的一堆，并将新的一堆的石子数，记为该次合并的得分。\n试设计出一个算法,计算出将  堆石子合并成  堆的最小得分和最大得分。\n输入\n数据的第  行是正整数 ，表示有  堆石子。\n第  行有  个整数，第  个整数  表示第  堆石子的个数。\n，\n输出\n输出共  行，第  行为最小得分，第  行为最大得分。\n样例输入 #1\n1244 5 9 4\n\n样例输出 #1\n124354\n\n\n\n分析\n\n\n\n代码\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//区间dp#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N = 210, INF = 0x3f3f3f3f;int dp[N][N];int n;int a[N];int main(){\tcin &gt;&gt; n;\tfor (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i];\tfor (int i = 1; i &lt;= n; i++) a[i + n] = a[i];\tfor (int i = 1; i &lt;= 2 * n; i++) a[i] += a[i - 1];\tfor (int len = 2; len &lt;= n; len++)\t\tfor (int i = 1; i + len - 1 &lt; 2 * n; i++)\t\t{\t\t\tint j = i + len - 1;\t\t\tdp[i][j] = INF;\t\t\tfor (int k = i; k + 1 &lt;= j; k++)\t\t\t\tdp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] + a[j] - a[i - 1]);\t\t}\tint mint = INF;\tfor (int i = 1; i &lt;= n; i++) mint = min(mint, dp[i][i + n - 1]);\tcout &lt;&lt; mint &lt;&lt; endl;\tfor (int len = 2; len &lt;= n; len++)\t\tfor (int i = 1; i + len - 1 &lt; 2 * n; i++)\t\t{\t\t\tint j = i + len - 1;\t\t\tdp[i][j] = 0;\t\t\tfor (int k = i; k + 1 &lt;= j; k++)\t\t\t\tdp[i][j] = max(dp[i][j], dp[i][k] + dp[k + 1][j] + a[j] - a[i - 1]);\t\t}\tint maxt = 0;\tfor (int i = 1; i &lt;= n; i++) maxt = max(maxt, dp[i][i + n - 1]);\tcout &lt;&lt; maxt &lt;&lt; endl;\treturn 0;}\n\n\n\n洛谷P4342  Polygon\n题目\n题目描述\n多边形是一个玩家在一个有  个顶点的多边形上的游戏，如图所示，其中 ＝ 。每个顶点用整数标记，每个边用符号 （加）或符号  （乘积）标记。\n\n第一步，删除其中一条边。随后每一步： \n选择一条边连接的两个顶点  和  ，用边上的运算符计算  和  得到的结果来替换这两个顶点。 \n游戏结束时，只有一个顶点，没有多余的边。\n如图所示，玩家先移除编号为3的边。之后，玩家选择计算编号为1的边，然后计算编号为4的边，最后，计算编号为2的边。结果是0。\n\n（翻译者友情提示：这里每条边的运算符旁边的数字为边的编号，不拿来计算）\n编写一个程序，给定一个多边形，计算最高可能的分数。\n输入\n输入描述一个有  个顶点的多边形，它包含两行。第一行是数字  ，为总边数。\n第二行描述这个多边形，一共有  个读入，每两个读入中第一个是字符，第二个是数字。\n第一个字符为第一条边的计算符号(  代表相加， 代表相乘)，第二个代表顶点上的数字。首尾相连。 \n\n对于任何一系列的操作，顶点数字都在  的范围内。\n输出\n第一行，输出最高的分数。在第二行，它必须写出所有可能的被清除后的边仍能得到最高得分的列表，必须严格递增。\n样例输入 #1\n124t -7 t 4 x 2 x 5\n\n样例输出 #1\n12331 2\n\n\n\n\n题解\n思路\n\n\n\n\n\n\n代码\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;const int N = 110, INF = 32768;int n;char c[N];int a[N];int f[N][N], g[N][N];int main(){    cin &gt;&gt; n;        // 破环成链    for (int i = 1; i &lt;= n; i ++ )    {        cin &gt;&gt; c[i] &gt;&gt; a[i];        c[i + n] = c[i];        a[i + n] = a[i];    }        for (int len = 1; len &lt;= n; len ++ )        for (int i = 1; i + len - 1 &lt;= 2 * n; i ++ )        {            int j = i + len - 1;                        // 只有一个数,不用操作            if (len == 1)            {                f[i][j] = g[i][j] = a[i];                continue;            }                        // 枚举分界点            f[i][j] = -INF, g[i][j] = INF; // 初始化            for (int k = i; k &lt; j; k ++ )            {                char op = c[k + 1]; // 取操作符                int lm = g[i][k], lM = f[i][k], rm = g[k + 1][j], rM = f[k + 1][j];                                if (op == 't') f[i][j] = max(f[i][j], lM + rM), g[i][j] = min(g[i][j], lm + rm);                else                 {                    int m = lm * rm, M = lm * rm;                                        m = min(m, lm * rM);                    m = min(m, lM * rm);                    m = min(m, lM * rM);                                        M = max(M, lm * rM);                    M = max(M, lM * rm);                    M = max(M, lM * rM);                                        f[i][j] = max(f[i][j], M), g[i][j] = min(g[i][j], m);                }            }                    }            int res = -INF; // 最大值    vector&lt;int&gt; segs; // 方案    for (int i = 1; i &lt;= n; i ++ ) res = max(res, f[i][i + n - 1]);    for (int i = 1; i &lt;= n; i ++ )        if (f[i][i + n - 1] == res)            segs.push_back(i);            cout &lt;&lt; res &lt;&lt; endl;    for (auto i : segs)        cout &lt;&lt; i &lt;&lt; \" \";        return 0;}\n\n\n\n洛谷P10956 金字塔\n题目\n题目描述\n虽然探索金字塔是极其老套的剧情，但是有一队探险家还是到了某金字塔脚下。\n经过多年的研究，科学家对这座金字塔的内部结构已经有所了解。\n首先，金字塔由若干房间组成，房间之间连有通道。\n如果把房间看作节点，通道看作边的话，整个金字塔呈现一个有根树结构，节点的子树之间有序，金字塔有唯一的一个入口通向树根。\n并且，每个房间的墙壁都涂有若干种颜色的一种。\n探险队员打算进一步了解金字塔的结构，为此，他们使用了一种特殊设计的机器人。\n这种机器人会从入口进入金字塔，之后对金字塔进行深度优先遍历。\n机器人每进入一个房间（无论是第一次进入还是返回），都会记录这个房间的颜色。\n最后，机器人会从入口退出金字塔。\n显然，机器人会访问每个房间至少一次，并且穿越每条通道恰好两次（两个方向各一次）， 然后，机器人会得到一个颜色序列。\n但是，探险队员发现这个颜色序列并不能唯一确定金字塔的结构。\n现在他们想请你帮助他们计算，对于一个给定的颜色序列，有多少种可能的结构会得到这个序列。\n因为结果可能会非常大，你只需要输出答案对 取模之后的值。\n输入\n输入仅一行，包含一个字符串 ，长度不超过 ，表示机器人得到的颜色序列。\n输出\n输出一个整数表示答案。\n样例输入 #1\n1ABABABA\n\n样例输出 #1\n15\n\n\n\n\n题解\n思路\n\n\n代码\n123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;using namespace std;typedef long long LL;const int mod = 1e9, N = 310;int n;string s;int dp[N][N];int main(){    cin &gt;&gt; s;    int n = s.size();        if (n % 2 == 0) puts(\"0\"); // 无解    else     {        for (int len = 1; len &lt;= n; len ++ )            for (int i = 0; i + len - 1 &lt; n; i ++ )            {                int j = i + len - 1;                if (len == 1) dp[i][j] = 1; // 边界                else if (s[i] == s[j]) // 两端相等才有解                    // 找符合条件的                    for (int k = i; k &lt; j; k ++ )                        if (s[k] == s[i])                            dp[i][j] = (dp[i][j] + (LL)dp[i][k] * dp[k + 1][j - 1]) % mod;            }                    cout &lt;&lt; dp[0][n - 1] &lt;&lt; endl;    }        return 0;}\n\n\n\n结语区间DP其实思路基本大体都相似，基本上推出来子状态到当前状态的状态更新就都能做了\n","slug":"动态规划-区间DP","date":"2024-09-26T05:12:32.000Z","categories_index":"算法","tags_index":"动态规划,区间DP","author_index":"Jerry"},{"id":"62555a6f14b066c1f526e128e3c72f4d","title":"动态规划--线性DP","content":"线性DP引入线性DP就是指状态的转移具有线性递推关系，每个状态只依赖之前的状态，按照线性顺序一步步递推下去。\n正如之前在背包问题中所写到的，仍旧可以用状态表示和状态计算来解决\n\n\n\n\n\n\n\n注意\n对于不同类的动态规划问题,核心解题步骤均为状态表示+状态计算,而如何在不同的题型中均捕捉到状态表示和状态计算的方法,才是需要通过刷题慢慢理解体会的\n\n\n例题洛谷B3637 最长上升子序列\n题目\n题目描述\n这是一个简单的动规板子题。\n给出一个由  个不超过  的正整数组成的序列。请输出这个序列的最长上升子序列的长度。\n最长上升子序列是指，从原序列中按顺序取出一些数字排在一起，这些数字是逐渐增大的。\n输入\n第一行，一个整数 ，表示序列长度。\n第二行有  个整数，表示这个序列。\n输出格式\n一个整数表示答案。\n样例输入 #1\n1261 2 4 1 3 4\n\n样例输出 #1\n14\n\n\n\n分析\n线性DP的经典问题\n状态表示：   前  项且以第  项结尾的上升子序列的最大长度\n状态计算： 子状态：枚举倒数第二项 且\n复杂度：\n\n代码\n1234567891011121314151617181920212223242526272829303132// LIS#include &lt;iostream&gt;using namespace std;const int N = 5e3 + 10;int n;int a[N], dp[N];int main(){\tcin &gt;&gt; n;\t\tfor (int i = 1; i &lt;= n; i ++ ) cin &gt;&gt; a[i];\t\t// 开始DP\tfor (int i = 1; i &lt;= n; i ++ )\t{\t\tdp[i] = 1;\t\tfor (int j = 1; j &lt; i; j ++ )\t\t\tif (a[j] &lt; a[i])\t\t\t\tdp[i] = max(dp[i], dp[j] + 1);\t}\t\tint res = 0;\tfor (int i = 1; i &lt;= n; i ++ ) res = max(res, dp[i]);\t\tcout &lt;&lt; res &lt;&lt; endl;        return 0;}\n\n\n\n\n\n优化\n容易发现,对于每个,都需要从1开始一一枚举来确定要接在哪个后面\n显然每一轮都浪费了前面得到的一些’信息’\n这样浪费’信息’的行为,在动态规划中往往会有一定的优化方案,把’信息’充分利用起来\n举个例子\n序列: 3\t1 \t 4\t  2 \t 8  \t 6  \t 5\n对前面两项3,1,可视作2个独立的长度为1的上升子序列,\n当遍历到4时，我们会发现对于4，既可以接到3上又可以接到1上，两者都是长度为1的上升子序列\n容易发现，能够接到3上的一定能够接到1上  长度为1的上升子序列，保留1即可，1比3适配性更强\n做了这样的处理之后，我们在遍历到4时，就不用再枚举3了\n所以我们需要做的就是实时维护这样一个前面  项里面各个长度的最优上升子序列的末尾元素，以判断第  项能否接上去\n这步的复杂度仍旧为 ，需要优化，能否用二分优化？\n判断这样一个最优上升子序列末尾元素的值的序列的性质，形如下图：\n\n\n设  代表长度为  的上升子序列的末尾项，假设我们  最优情况下接到长度为 的上升子序列后面\n则必有  ，否则接到  后面更长\n则  必定是一个单调不减的序列  具有二段性，可以二分\n由此，该步复杂度降低至 ，整体复杂度优化到 \n\n代码\n12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int N = 5e3 + 10;int n;int a[N], q[N];int len = 0;int main(){\t\tcin &gt;&gt; n;        memset(q, 0x3f, sizeof q);    q[0] = 0;        for (int i = 1; i &lt;= n; i ++ ) cin &gt;&gt; a[i];        for (int i = 1; i &lt;= n; i ++ )    {    \t// 开始二分\t\tint l = 0, r = len;\t\tint mid;\t\t\t\twhile (l &lt; r)\t\t{\t\t\t// 找到可以接的最大值\t\t\tmid = l + r + 1&gt;&gt; 1;\t\t\tif (q[mid] &lt; a[i]) l = mid;\t\t\telse r = mid - 1;\t\t}\t\t\t\t// 接在长度为l的后面,维护q\t\tq[l + 1] = min(q[l + 1], a[i]);\t\tlen = max(len, l + 1);    }        cout &lt;&lt; len &lt;&lt; endl;        return 0;}\n\n\n\n\n\n思考\n读者看到这里也许会有疑问,为何状态表示方式要这样定?其他的表示方式不行码?\n正如背包问题中对第i件物品有选与不选之分,为何我这里状态表示里第  项必须选呢?\n状态表示:  前  项的里面最长的上升子序列长度\n这样子在动态规划完之后就不需要再定一个  一个个取  来求最大值了,  直接就是答案\n但方便的状态表示带来的代价是难以甚至无法进行状态计算\n在上述状态中,由于的可能选可能没有选,我们根本就找不到子状态来进行状态转移\n 状态表示和状态转移是相互制约的,一个易就会有一个难,当找不到转移方程时,不妨尝试换一种表示方法\n洛谷P1439 【模板】最长公共子序列\n题目\n题目描述\n给出  的两个排列  和  ，求它们的最长公共子序列。\n输入\n第一行是一个数 。\n接下来两行，每行为  个数，为自然数 ​ 的一个排列。\n\n输出\n一个数，即最长公共子序列的长度。\n样例输入 #1\n1235 3 2 1 4 51 2 3 4 5\n\n样例输出 #1\n13\n\n\n\n仍旧是子序列问题,经过前一道题的尝试之后,思考一下这道题要如何进行状态表示和状态计算吧~\n分析\n状态表示: 的前项,的前项的最长公共子序列长度\n状态计算: 子节点包含于选不选不选选选选不选不选\n注意:这里只是包含,各个状态之间囊括的集合可能存在交集,但是并集一定是全集,不影响正确性\n且 一定会包含于 和中,故可以舍去\n复杂度:\n\n代码\n12345678910111213141516171819202122232425262728293031323334// LCS#include &lt;iostream&gt;using namespace std;const int N = 1e5 + 10;int n;int a[N], b[N];int dp[N][N]; // 爆了int main(){\t\tios::sync_with_stdio(false);\tcin.tie(0);\tcout.tie(0);\t\tcin &gt;&gt; n;\t\tfor (int i = 1; i &lt;= n; i ++ ) cin &gt;&gt; a[i];\tfor (int i = 1; i &lt;= n; i ++ ) cin &gt;&gt; b[i];\t\tfor (int i = 1; i &lt;= n; i ++ )\t\tfor (int j = 1; j &lt;= n; j ++ )\t\t{\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);\t\t\tif (a[i] == b[j])\t\t\t\tdp[i][j] = max(dp[i][j], dp[i - 1][j - 1] + 1);\t\t} \t\t\tcout &lt;&lt; dp[n][n] &lt;&lt; endl;\t\treturn 0;}\n\n\n\n嗯?等等! ? hhh 说好的模板呢\n显然这题用朴素的公共子序列方法时间复杂度肯定是过不去的,至少需要优化到\n想不出.jpg 看到的优化做法,恰好也是哎,要是能拿来用就好了! \n\n\n优化\n假设两个序列分别为\n\n\n容易发现最长公共子序列为 \n做这样的处理,把  的元素进行变换，第  项映射为 ,即\n\n\n\n\n\n变换之后序列为\n\n\n最长公共子序列变为了\n 容易发现，变换之后的公共子序列均为  的上升子序列\n由此，问题便转化为了求变换后的  的最长上升子序列，在上一题的优化做法中可以把复杂度优化至\n\n代码\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// LCS → LIS#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int N = 1e5 + 10;int n;int a[N], b[N], c[N];int q[N];int main(){\t\tios::sync_with_stdio(false);\tcin.tie(0);\tcout.tie(0);\t\tcin &gt;&gt; n;\t\tfor (int i = 1; i &lt;= n; i ++ ) cin &gt;&gt; a[i];\tfor (int i = 1; i &lt;= n; i ++ ) cin &gt;&gt; b[i];\t\t// c[i]存储映射关系\tfor (int i = 1; i &lt;= n; i ++ ) c[a[i]] = i;\t\t// b[i]进行变换\tfor (int i = 1; i &lt;= n; i ++ ) b[i] = c[b[i]];\t\t// 开始求最长上升子序列\tmemset(q, 0x3f, sizeof q);\tq[0] = 0;\tint len = 0;\tfor (int i = 1; i &lt;= n; i ++ )\t{\t\tint l = 0, r = len;\t\tint mid;\t\twhile (l &lt; r)\t\t{\t\t\tmid = l + r + 1 &gt;&gt; 1;\t\t\tif (q[mid] &lt; b[i]) l = mid;\t\t\telse r = mid - 1;\t\t}\t\t\t\tq[l + 1] = min(q[l + 1], b[i]);\t\tlen = max(len, l + 1);\t}\t\t\tcout &lt;&lt; len &lt;&lt; endl;\t\treturn 0;}\n\n\n\n既然已经解决了  和  问题，来试试二者的结合吧~\n洛谷 LCIS\n\n再来看看其它情景下的线性DP\n洛谷P1216 数字三角形 Number Triangles\n题目\n题目描述\n观察下面的数字金字塔。\n写一个程序来查找从最高点到底部任意处结束的路径，使路径经过数字的和最大。每一步可以走到左下方的点也可以到达右下方的点。\n\n在上面的样例中，从  的路径产生了最大权值。\n输入\n第一个行一个正整数  ,表示行的数目。\n后面每行为这个数字金字塔特定行包含的整数。\n，所有输入在  范围内\n输出\n单独的一行,包含那个可能得到的最大的和。\n样例输入 #1\n123456573 88 1 02 7 4 44 5 2 6 5\n\n样例输出 #1\n130\n\n\n\n题解\n思路\n直接把三角形拉直，想象为一个正方形被沿对角线对半分了\n状态表示： 走到第  行第  列的最大值\n状态计算：\n代码\n12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;using namespace std;const int N = 1e3 + 10,INF=1e9;int dp[N][N];//存最大值int a[N][N];//存三角形int n;int main(){\tcin &gt;&gt; n;\tfor (int i = 1; i &lt;= n; i++)\t\tfor (int j = 1; j &lt;= i; j++) cin &gt;&gt; a[i][j];\t//初始化边界\tfor (int i = 1; i &lt;= n; i++)\t\tfor (int j = 1; j &lt;= n + 1; j++)\tdp[i][j] = -INF;\tdp[1][1] = a[1][1];\tfor (int i = 2; i &lt;= n; i++)\t\tfor (int j = 1; j &lt;= n; j++) dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - 1]) + a[i][j];\tint maxn = 0;\tfor (int i = 1; i &lt;= n; i++) maxn = max(maxn, dp[n][i]);\tcout &lt;&lt; maxn;\treturn 0;}\n\n\n\n\n进阶一点的数字三角形\n洛谷P1006 传纸条\n题目\n题目描述\n小渊和小轩是好朋友也是同班同学，他们在一起总有谈不完的话题。一次素质拓展活动中，班上同学安排坐成一个  行  列的矩阵，而小渊和小轩被安排在矩阵对角线的两端，因此，他们就无法直接交谈了。幸运的是，他们可以通过传纸条来进行交流。纸条要经由许多同学传到对方手里，小渊坐在矩阵的左上角，坐标 ，小轩坐在矩阵的右下角，坐标 。从小渊传到小轩的纸条只可以向下或者向右传递，从小轩传给小渊的纸条只可以向上或者向左传递。\n在活动进行中，小渊希望给小轩传递一张纸条，同时希望小轩给他回复。班里每个同学都可以帮他们传递，但只会帮他们一次，也就是说如果此人在小渊递给小轩纸条的时候帮忙，那么在小轩递给小渊的时候就不会再帮忙。反之亦然。\n还有一件事情需要注意，全班每个同学愿意帮忙的好感度有高有低（注意：小渊和小轩的好心程度没有定义，输入时用  表示），可以用一个  内的自然数来表示，数越大表示越好心。小渊和小轩希望尽可能找好心程度高的同学来帮忙传纸条，即找到来回两条传递路径，使得这两条路径上同学的好心程度之和最大。现在，请你帮助小渊和小轩找到这样的两条路径。\n输入\n第一行有两个用空格隔开的整数  和 ，表示班里有  行  列。\n接下来的  行是一个  的矩阵，矩阵中第  行  列的整数表示坐在第  行  列的学生的好心程度。每行的 ​ 个整数之间用空格隔开。\n\n输出\n输出文件共一行一个整数，表示来回两条路上参与传递纸条的学生的好心程度之和的最大值。\n样例输入 #1\n12343 30 3 92 8 55 7 0\n\n样例输出 #1\n134\n\n\n\n结语看了这么多道线性DP的题目，容易发现其实线性DP的状态表示还是比较好想到的，基本上都是围绕着题目的问题来设置递推的状态，难点就在一些优化上，尽量把层与层之间暴力枚举的复杂度给消去\n","slug":"动态规划-线性DP","date":"2024-09-26T05:12:20.000Z","categories_index":"算法","tags_index":"动态规划,线性DP","author_index":"Jerry"},{"id":"398687178e2ec3c1a9498d5422c75757","title":"动态规划--背包问题","content":"🎮 背包问题欢迎来到 动态规划的冒险世界！在这趟旅途中，你将化身为一位勇敢的冒险者，面临一个经典而深邃的挑战：如何在有限的资源下获得最大的收益。每一关都充满了挑战，但只要你步步为营，掌握算法精髓，最终你会成为背包问题的 算法大师。准备好了吗？Let’s Go!\n\n前言背包问题是动态规划最经典的问题之一，在这里，我们初步学会如何使用动态规划解决问题\n绝大部分情况下，动态规划步骤如下：\n状态表示：集合描述\n状态计算：划分集合，把当前状态转化为子集状态（注意不重不漏）进而写出状态转移方程\n接下来，让我们到题目中理解这两步的含义吧！\n分类1.01背包\n种物品，体积背包\n物品体积，价值（最多只能用一次）​\n\n洛谷P1048 采药\n洛谷P1060 开心的金明\n2.完全背包\n种物品，体积背包\n物品体积，价值（无限用）\n\n洛谷P1616 疯狂的采药\n洛谷P1853 投资的最大效益\n3.多重背包\n种物品，体积背包\n物品体积，价值（每种最多选个）​\n\n洛谷P1776 宝物筛选\n4.分组背包\n组物品，体积背包\n组内每件物品体积价值每组物品种最多选个\n\n洛谷P1757 通天之分组背包\n洛谷P5322 排兵布阵\n求背包装得下的情况下的最大总价值\n讲解1.01背包\n种物品，体积背包\n物品体积，价值（最多只能用一次）\n\n思路：状态表示：前种物品花费体积得到的最大价值\n状态计算：第种物品选不选\n求最大价值：状态转移方程\n理解：从第种物品一件一件往后选，每一步都求所有体积下的最优解\n全局最优解一定会从前面的某个局部最优解转移过来\n例题：洛谷P1048 采药\n\n题目\n题目描述\n辰辰是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题。医师把他带到一个到处都是草药的山洞里对他说：“孩子，这个山洞里有一些不同的草药，采每一株都需要一些时间，每一株也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。”\n如果你是辰辰，你能完成这个任务吗？\n输入\n第一行有  个整数 （）和 （），用一个空格隔开， 代表总共能够用来采药的时间， 代表山洞里的草药的数目。\n接下来的  行每行包括两个在  到  之间（包括  和 ）的整数，分别表示采摘某株草药的时间和这株草药的价值。\n输出\n输出在规定的时间内可以采到的草药的最大总价值。\n样例输入\n123470 371 10069 11 2\n\n样例输出 \n13\n\n\n\n思路\n翻译题目\n总时间背包体积\n采每种药的时间物品体积\n\n状态表示：前种物品花费体积得到的最大价值\n状态计算：第种物品选不选\n求最大价值：状态转移方程\n\n代码\n1234567891011121314151617181920212223242526272829303132333435363738// 01背包// 状态表示 dp[i][j] 前i种j体积最大价值// 状态计算 dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - v[i]] + w[i])#include &lt;iostream&gt;using namespace std;const int N = 110, M = 1010;int n, V;int dp[N][M];int v[N], w[N]; // 我这里按照自己习惯定义的变量,可能和题目符号有些出入int main (){    cin &gt;&gt; V &gt;&gt; n;        for (int i = 1; i &lt;= n; i ++ )        cin &gt;&gt; v[i] &gt;&gt; w[i];        // 开始动态规划,从前往后一个一个挑    for (int i = 1; i &lt;= n; i ++ )         for (int j = 0; j &lt;= V; j ++ )        {            // 选到第i种,花费j体积            // 第i件没得选, 放不下            if (j &lt; v[i]) dp[i][j] = dp[i - 1][j];                        // 第i件有选或不选的权利            else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - v[i]] + w[i]);\t\t}        // 输出答案    cout &lt;&lt; dp[n][V] &lt;&lt; endl;        return 0;}\n\n\n\n优化还没完！还能再优化！🤭\n观察上面代码，我们发现在挑到第件物品时，我们只会用到第层的数据，而不会用到更前面的数据\n故可以把直接压缩到遍历到第种物品时，在第层的基础上更新到第层\n对于体积的直接保留原本的\n注意为了避免第层更新用的数据已经被更新过，这里体积需要从大到小枚举，读者可以自行体会\n\n代码\n12345678910111213141516171819202122232425// 01背包1维#include &lt;iostream&gt;using namespace std;const int N = 110, M = 1010;int n, V;int dp[M];int v[N], w[N]; int main (){\tios::sync_with_stdio(false);\tcin.tie(0);\tcout.tie(0);        cin &gt;&gt; V &gt;&gt; n;    for (int i = 1; i &lt;= n; i ++ )        cin &gt;&gt; v[i] &gt;&gt; w[i];        for (int i = 1; i &lt;= n; i ++ )         for (int j = V; j &gt;= v[i]; j -- ) // 从大到小枚举,小于v[i]的更新不了        \tdp[j] = max(dp[j], dp[j - v[i]] + w[i]);        cout &lt;&lt; dp[V] &lt;&lt; endl;    return 0;}\n\n\n\n2.完全背包\n种物品，体积背包\n物品体积，价值（无限用）\n\n思路：模仿背包的思路，按照以下步骤\n状态表示：前种花体积的最大价值\n状态计算：背包的子状态是第种选没选完全背包可以无限选，子状态是第种选了个​\n转移方程：\n\n每一层都这样枚举，总体复杂度显然过于复杂了，需要进一步优化转移方程\n类似上面的，\n对比可得\n\n​\n如此一来便化简了许多\n优化：再考虑优化到维：\n第层需要用到第层和第层的数据，这不恰好是体积从小到大枚举得到的效果？\n体积从小到大枚举，第层枚举到时已经被更新为了而仍保留，符合题意\n所以和背包一样，这里也能压缩掉一维，只需体积从小到大枚举即可\n例题：洛谷P1616 疯狂的采药\n\n题目\n题目描述\nLiYuxiang 是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题。医师把他带到一个到处都是草药的山洞里对他说：“孩子，这个山洞里有一些不同种类的草药，采每一种都需要一些时间，每一种也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。”\n如果你是 LiYuxiang，你能完成这个任务吗？\n此题和原题的不同点：\n. 每种草药可以无限制地疯狂采摘。\n. 药的种类眼花缭乱，采药时间好长好长啊！师傅等得菊花都谢了！\n输入\n输入第一行有两个整数，分别代表总共能够用来采药的时间  和代表山洞里的草药的数目 。\n第  到第  行，每行两个整数，第  行的整数  分别表示采摘第  种草药的时间和该草药的价值。\n输出\n输出一行，这一行只包含一个整数，表示在规定的时间内，可以采到的草药的最大总价值。\n样例输入\n123470 371 10069 11 2\n\n样例输出\n1140\n\n\n\n\n代码\n12345678910111213141516171819202122232425// 完全背包1维#include &lt;iostream&gt;using namespace std;const int N = 10010, M = 1e7+10;int n, V;long long int dp[M];long long  v[N], w[N]; int main (){\tios::sync_with_stdio(false);\tcin.tie(0);\tcout.tie(0);        cin &gt;&gt; V &gt;&gt; n;    for (int i = 1; i &lt;= n; i ++ )        cin &gt;&gt; v[i] &gt;&gt; w[i];        for (int i = 1; i &lt;= n; i ++ )         for (int j = v[i]; j &lt;= V; j ++ )        \tdp[j] = max(dp[j], dp[j - v[i]] + w[i]);        cout &lt;&lt; dp[V] &lt;&lt; endl;    return 0;}\n\n\n\n3.多重背包\n种物品，体积背包\n物品体积，价值（每种最多选个）​\n\n思路：状态表示前种花体积的最大价值\n状态计算子状态：第种选了个\n转移方程\n\n\n总体复杂度当非常大时需要优化\n关键是从到枚举第种选了个效率太低了\n\n优化：优化思路：把第个物品用二进制拆成多种组合个个个 \n将每种物品的个单独看作一个物品\n则任意或\n进而再转化为背包问题这样对于每种物品最多只需要讨论个选与不选复杂度优化到\n思考为何这里不能用完全背包类似的优化思路\n例题：洛谷P1776 宝物筛选\n\n题目\n题目描述\n终于，破解了千年的难题。小 FF 找到了王室的宝物室，里面堆满了无数价值连城的宝物。\n这下小 FF 可发财了，嘎嘎。但是这里的宝物实在是太多了，小 FF 的采集车似乎装不下那么多宝物。看来小 FF 只能含泪舍弃其中的一部分宝物了。\n小 FF 对洞穴里的宝物进行了整理，他发现每样宝物都有一件或者多件。他粗略估算了下每样宝物的价值，之后开始了宝物筛选工作：小 FF 有一个最大载重为  的采集车，洞穴里总共有  种宝物，每种宝物的价值为 ，重量为 ，每种宝物有  件。小 FF 希望在采集车不超载的前提下，选择一些宝物装进采集车，使得它们的价值和最大。\n输入格式\n第一行为一个整数  和 ，分别表示宝物种数和采集车的最大载重。\n接下来  行每行三个整数 ​​。\n，，\n输出格式\n输出仅一个整数，表示在采集车不超载的情况下收集的宝物的最大价值。\n样例输入\n123454 203 9 35 9 19 4 28 1 3\n\n样例输出\n147\n\n\n\n\n代码\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 多重背包问题#include &lt;iostream&gt;using namespace std;const int N = 1e5 + 10, M = 4e4 + 10;int n, V;int dp[N];int v[N], w[N];int main(){    ios::sync_with_stdio(false);    cin.tie(0);    cout.tie(0);        cin &gt;&gt; n &gt;&gt; V;        int cnt = 1; // 存储拆分后的物品种数    int v1, w1, s1; // 未拆分    for (int i = 1; i &lt;= n; i ++ )    {        cin &gt;&gt; w1 &gt;&gt; v1 &gt;&gt; s1;                // s1拆成1+2+4+8+……        int k = 1;        while (s1 - k &gt; 0)        {            v[cnt] = v1 * k;            w[cnt ++] = w1 * k;            s1 -= k;            k *= 2;        }                // 拆剩下的        if(s1) v[cnt] = v1 * s1, w[cnt ++] = w1 * s1;\t}        n = cnt - 1;        // 01背包    for (int i = 1; i &lt;= n; i ++ )        for (int j = V; j &gt;= v[i]; j -- )        \tdp[j] = max(dp[j], dp[j - v[i]] + w[i]);        cout &lt;&lt; dp[V] &lt;&lt; endl;        return 0;}\n\n\n\n4.分组背包\n组物品，体积背包\n组内每件物品体积价值每组物品种最多选个​\n\n思路：状态表示前组花费体积的最大值\n状态计算子状态上一组选了哪一个\n状态转移方程\n\n\n优化至一维体积降序枚举略\n例题：洛谷P1757 通天之分组背包\n\n题目\n题目描述\n自  背包问世之后，小 A 对此深感兴趣。一天，小 A 去远游，却发现他的背包不同于  背包，他的物品大致可分为  组，每组中的物品相互冲突，现在，他想知道最大的利用价值是多少。\n输入\n两个数 ，表示一共有  件物品，总重量为 。\n接下来  行，每行  个数 ，表示物品的重量，利用价值，所属组数。\n，，， 在 int 范围内。\n输出\n一个数，最大的利用价值。\n样例输入\n123445 310 10 110 5 150 400 2\n\n样例输出\n110\n\n\n\n\n代码\n123456789101112131415161718192021222324252627282930313233343536373839404142// 1维分组背包#include&lt;iostream&gt;using namespace std;const int N = 1e3 + 10;int dp[N];int n, V;int v[N][N], w[N][N], cnt[N];// cnt[]存每个组的物品数int main(){    ios::sync_with_stdio(false);    cin.tie(0);    cout.tie(0);    \tcin &gt;&gt; V &gt;&gt; n;\tint gm = 0;//存储最大组数    int v1, w1, j;\tfor (int i = 1; i &lt;= n; i ++ )\t{\t\tcin &gt;&gt; v1 &gt;&gt; w1 &gt;&gt; j;\t\tv[j][++ cnt[j]] = v1;\t\tw[j][cnt[j]] = w1;\t\tgm = max(gm, j);\t}    n = gm;    \t// 开始动态规划\tfor (int i = 1; i &lt;= n; i ++ )\t\tfor (int j = V; j &gt;= 0; j -- )\t\t\tfor (int k = 0; k &lt;= cnt[i]; k ++ ) // 判断要选该组的哪件物品\t\t\t\tif(v[i][k] &lt;= j)\t\t\t\t\tdp[j] = max(dp[j], dp[j - v[i][k]] + w[i][k]);\tcout &lt;&lt; dp[V] &lt;&lt; endl;\treturn 0;}\n\n\n\n结语以上便是背包问题最基础的类模型，实际上的题目可能会结合上其他算法状态压缩、贪心、树形\n又或是进行变式求方案数多目标\n篇幅有限，笔者就不多赘述，相信凭借各位的聪明才智，一定可以轻松应付​(ง •_•)ง\n","slug":"动态规划-背包问题","date":"2024-09-26T05:12:09.000Z","categories_index":"算法","tags_index":"动态规划,背包问题","author_index":"Jerry"},{"id":"c3878449dce899402d13b06cc735de00","title":"博弈论--NIM游戏","content":"引入先介绍几个概念\n1.公平组合游戏ICG：\n两名玩家交替行动\n在任意时刻，可执行的行动与玩家本身无关（游戏公平性）\n不能行动的玩家输\n\n2.有向图游戏\n给定一个有向无环图，具有唯一的起点，玩家交替的把棋子沿有向边进行移动，每次移动一步，无法移动者输\n任何ICG均可化为有向图游戏\n\n3.先手必胜与先手必败\n在双方均完全理性的情况下，先手不必胜则必败，先手不必败则必胜\n\nNIM游戏：1.介绍NIM 游戏是一种经典的组合博弈，两名玩家轮流从若干堆石子中选择一堆，并从中取走任意数量的石子。无法继续操作的玩家判负。\n2.结论对于  堆石子 \n\n先手必胜态：\n先手必败态：\n\n3.证明：通过数学归纳，从特殊推向一般。\n\n不能操作时，每堆都是 0，\n\n当 ，任意一步操作之后 \n反证：对任意一步操作使 \n若 ，\n设 \n则 \n则 ，但是 ，矛盾！得证。\n\n当 ，一定存在一步操作之后 \n证明：设 ，设  的最高位 1 在第  位。\n则  中必定存在至少一个  的第  位也为 1，且 \n（若第  位均为 0，则所有异或之后得到  的第  位也只能是 0，不合题意）\n所以可以从  中拿走  个石子（上一步证明了此步的合法性），使得 \n故 ，得证。\n\n所以在双方绝对理性的情况下，某一方拿完之后达到了异或值为 0 的情况后，会一直握住这个状态，保证自己必胜。\n\n\n更详细的思路构造过程及证明请看编程之美_1.11 NIM（1）一排石头的游戏在线阅读\nSG函数1. Mex 运算：设  表示一个非负整数集合，定义 mex(S) 为求出不属于集合  的最小非负整数的运算。\n即：且\n2. SG 函数将游戏的所有状态及其转换关系抽象成一张有向无环图。\n定义 终点，\n示例：\n\n\n图中模拟一堆个数为 10 的石子的状态转移图，每次只能拿 2 个或 5 个石子，蓝色字为石子数，红色字为对应状态的 SG 值。\n由图：任何一个非 0 状态都可以到 0，任何一个 0 状态都到不了 0。\n则  时，先手拿完后 ，对手总有办法后手让 ，先手必败。\n 时，先手总有办法拿完使 ，对手怎么拿都使 ，先手必胜。\n性质：\n对一个含多个图的游戏，取每个图起点  的 SG 值 \n则必胜，当 \n必败，当 \n3.证明：类似一般 NIM 游戏。\n\n当 ，没有必胜的起点，则 ，必败。\n\n存在 ，则我先手一定可以走一步到达 ，此时 ，对方先手必败，即我方必胜。\n\n当  时， 不全为 0 的情况，不管怎么走，，必将落入对方先手必胜局面，即我方必败。\n\n\n分类NIM博弈的内容大致就这么多啦~\n来几道题目练练手，看看题目中是怎么变形的。\n基础变形\n洛谷P1247 取火柴游戏\n洛谷P7589 黑白棋 关键在翻译题目，本质就是简单的 NIM 游戏。\n洛谷P5675 取石子游戏      背包DP + 阶梯NIM，代码不难理解，关键是想明白思路，考思维\n阶梯 Nim\n洛谷P3480 KAM-Pebbles   差分数组的阶梯nim\n洛谷P2575 高手过招\n","slug":"博弈论-NIM游戏","date":"2024-09-26T05:11:45.000Z","categories_index":"算法","tags_index":"博弈论,NIM游戏,SG函数","author_index":"Jerry"},{"id":"9fc7aaa29955e8777b63cdc5e2f3c111","title":"快速幂","content":"快速幂快速计算\n\n朴素计算 \n\n显然当过大时太慢了\n快速幂计算 思路\n即二进制\n所以\n\n\n\n\n而每次往后只需把平方一下就行\n代码123456789101112131415// 快速幂int qmi(int a, int k, int p){\t// 计算 a^k % p    int res = 1;    while (k)    {        // 判断ci是否为1,如果是就需要乘否则跳过        if (k &amp; 1) res = (long long)(res * a) % p; // 取模的乘法运算        k &gt;&gt;= 1;        a = (long long)(a * a) % p;    }        return res;}\n\n\n\n模板题洛谷P1226 快速幂\n应用求逆元\n逆元 除法的取模运算\n定义：若互质满足\n则称逆元记号，不是\n\n思路如下\n同乘约\n由费马定理\n\n模板题\n洛谷P3811 模意义下的乘法逆元\n结语由此，我们便有了乘除法的取模运算法则\n\n\n","slug":"快速幂","date":"2024-09-26T05:11:31.000Z","categories_index":"算法","tags_index":"快速幂,数论","author_index":"Jerry"},{"id":"40241814551b223b651e15683e69d116","title":"数学--约数","content":"约数1.求约数试除法求所有约数  \n枚举\n对 存  \n代码： \n123456789101112vector&lt;int&gt; get_divisors(int x){    vector&lt;int&gt; res;    for (int i = 1; i &lt;= x / i; i ++ )        if (x % i == 0)        {            res.push_back(i);            if (i != x / i) res.push_back(x / i);        }    sort(res.begin(), res.end());    return res;}\n\n\n\n细节：vector存再sort排序比较方便\n2.约数个数与约数之和对于任意自然数 N，可以将其分解为质因数：\n\n其中， 是  的质因数， 是这些质因数对应的指数。\n(1)约数个数公式每个约数可以表示为：\n\n其中 ，表示对每个质数  的指数从  到  进行选择。因此，约数的个数为：\n\n代码\n(2) 约数之和公式每个质数  对应的指数可以形成等比数列：\n\n因此，约数之和为：\n\n代码\n","slug":"数学-约数","date":"2024-09-26T05:10:57.000Z","categories_index":"算法","tags_index":"数论,约数","author_index":"Jerry"},{"id":"6390ac85391cd221383c57783115e1e4","title":"数学--质数","content":"质数\n\n\n\n\n\n\n\n\n&gt;1 只包含1和本身两个约数\n1.判断质数试除法，只需枚举即可\n代码：\n12345678bool is_prime(int n){    if (n &lt; 2) return false;    for (int i = 2; i &lt;= n / i; i ++ )        if (x % i == 0)            return false;    return true;}\n\n细节\n①不推荐写要调用函数，太慢\n②不推荐写当太大时有可能溢出\n2.分解质因数最多只含一个的质因子，还是试除法，遇到约数就约掉\n如果约掉了所有的质因子之后仍，则约剩下的数必是质因子，单独处理即可\n代码：\n12345678910111213void divide(int n){    for (int i = 2; i &lt;= n / i; i ++ )        if (n % i == 0)        {            // 约掉所有因子，易证从小到大约掉的因子必是质因子            int s = 0;            while (x % i == 0) x /= i, s ++ ;            cout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; s &lt;&lt; endl; // 输出质因子及其个数        }    if (x &gt; 1) cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; 1 &lt;&lt; endl; // 单独处理最后一个因子    cout &lt;&lt; endl;}\n\n\n\n3.筛质数给一个范围筛掉范围内所有的质数\n朴素筛法思路：\n从枚举，依次筛掉倍数，倍数，倍数，\n例题\n洛谷P5736 【深基7.例2】质数筛 \n埃氏筛法优化：\n只筛掉质数的倍数，如在中枚举到，已经在的时候就被筛了，就跳过不再筛的倍数了\n显然，如果枚举到某个数，在前面没被筛掉则必是质数 \n缺点：仍旧还是有些数被重复筛了，如会被和同时筛掉，效率仍待提高\n线性筛法优化：每个数只会被自己最小质因子筛掉，如在上面只会被筛掉\n伪代码：\n①一定是最小质因子一定是最小质因子\n②一定小于的所有质因子也一定是最小质因子\n③按照此逻辑来决定一个数一个数筛\n代码：\n123456789101112131415int primes[N], cnt;     // primes[]存储所有素数bool st[N];         // st[x]存储x是否被筛掉void get_primes(int n){    for (int i = 2; i &lt;= n; i ++ )    {        if (!st[i]) primes[cnt ++ ] = i;        for (int j = 0; primes[j] &lt;= n / i; j ++ )        {            st[primes[j] * i] = true;            if (i % primes[j] == 0) break;        }    }}\n\n例题\n洛谷P3383 【模板】线性筛素数\n","slug":"数学-质数","date":"2024-09-26T05:10:48.000Z","categories_index":"算法","tags_index":"数论,质数","author_index":"Jerry"},{"id":"23e5ccb93b471aba058840eff980504f","title":"图论--最短路","content":"最短路先贴张总体图：\n\n\n最短路问题有以下性质：\n对于边权为正的图，任意两个结点之间的最短路，不会经过重复的结点。\n对于边权为正的图，任意两个结点之间的最短路，不会经过重复的边。\n对于边权为正的图，任意两个结点之间的最短路，任意一条的结点数不会超过  ，边数不会超过  。\n1.单源最短路(1)边权均为正数①朴素Dijkstra算法思路：\ndist[i]存到起点的最短距离（在执行过程更新），st[i]存是否已确定最短距离\n集合S已经确定最短距离的点集（实际上就是st[]为true的点）\n初始化所有点到起点距离均为无穷大，将起点到起点距离设置为0\n找当前所有未定最短距的点中的最近点t，用t更新其他点最短距离，并将t丢进集合S里\n迭代n次，即可确定所有点最短路\n\n证明：下面用数学归纳法证明，所有有边权为非负的情况下，Dijkstra 算法的正确性。\n简单来说，我们要证明的，就是在执行第 1 操作时，取出的一点  是最短的已经被确定，即满足 。\n初始时 ，假设成立。\n接下来用反证法。\n设  为算法中第一个加入  集合时不满足  的点。因为  点一定满足 ，且一定是第一个加入  集合的点，因此  加入  集合前，，如果不存在  的路径，则 ，假设不满足。\n于是一定存在路径 ，其中  为路径上的节点，而  为  的前驱结点（显然 ）。需要注意的是，可能存在  或  可能是空节点。\n因为在结点  加入前的 ，所以在  加入到  集合时，有 ，此时通过反证法，构造出的路径 ，一定有 ，使得  点加入到 。\n下面证明 ，在路径中，假设  点所有边权为负，因此 ，从而  加入  集合后被取出时才会终止。\n因此，Dijkstra 算法是正确的，算法终止时 ​ 完成。\n步骤：下面用一个具体的例子来辅助解释这个过程\n\n初始化  \n\n\n\n\n起点到起点的距离为 0，即 \n\n\n\n\n遍历 dist 数组，找到一个节点，这个节点是：没有确定最短路的节点中距离起点最近的点。\n假设该节点编号为   ，此时就找到了起点到该节点的最短距离，   置为  \n\n\n\n\n\n遍历  所有可以到达的节点 ，如果  大于  加上  的距离\n即 （ 为  的距离） ，则更新 \n\n\n\n\n\n\n\n一直重复上面的步骤直至所有点的最短路均被确定\n\n\n\n\n此时起点到所有点的最短路均被确定\n\n\n\n\n\n注意事项：\n\n复杂度： 遍历  次  遍历  个点找最近点 \n\n稠密图，邻接矩阵存有向图\n\n当前情况需要每个点要求第一次出队的时候就已经确定最短路，所以要求图内不能有负权边 （否则第一次出队可能不是最短路，则当前算法失效）\n\n朴素dijkstra用的比较少\n\n\n伪代码：\n12345678int dist[n],state[n];dist[1] = 0, state[1] = 1;for(i:1 ~ n){    t &lt;- 没有确定最短路径的节点中距离源点最近的点;    state[t] = 1;    更新 dist;}\n\n\n\n代码模板：\n123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;int n;\t\t  // 点数int d[N][N];  // 邻接矩阵存有向图int dist[N];  // 存储1号点到每个点的最短距离bool st[N];   // 存储每个点的最短路是否已经确定// 求1号点到n号点的最短路，如果不存在则返回-1int dijkstra(){    memset(dist, 0x3f, sizeof dist);    dist[1] = 0;    for (int i = 0; i &lt; n - 1; i ++ )    {        int t = -1;     // 在还未确定最短路的点中，寻找距离最小的点        for (int j = 1; j &lt;= n; j ++ )            if (!st[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j]))                t = j;        // 用t更新其他点的距离        for (int j = 1; j &lt;= n; j ++ )            dist[j] = min(dist[j], dist[t] + d[t][j]);        st[t] = true;    }    if (dist[n] == 0x3f3f3f3f) return -1;    return dist[n];}\n\n\n\n②堆优化版Dijkstra算法思路：\n容易发现在朴素Dijkstra算法中，通过枚举来找最近点的操作值得优化，这里采用小根堆来存所有点当前离起点的最短路，堆顶即为最近点，这步操作的复杂度仅为 \n其余仍与朴素Dijkstra一样\n\n注意事项：\n复杂度：\n稀疏图，邻接表存有向图\n\n代码模板：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;typedef pair&lt;int, int&gt; PII;int n;      \t\t\t\t\t\t// 点的数量int h[N], w[N], e[N], ne[N], idx;   // 邻接表存储所有边int dist[N];        \t\t\t\t// 存储所有点到1号点的距离bool st[N];    \t\t\t\t\t \t// 存储每个点的最短距离是否已确定// 初始化邻接表void init(){    memset(h, -1, sizeof h);}// 连接有向边a→bvoid add(int a, int b, int c){    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;}// 求1号点到n号点的最短距离，如果不存在，则返回-1int dijkstra(){    memset(dist, 0x3f, sizeof dist); // 初始化距离为无穷大    dist[1] = 0;    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap; // 小根堆    heap.push({0, 1});      // first存储距离，second存储节点编号    while (heap.size())    {        auto t = heap.top(); // 取出最近点        heap.pop();        int ver = t.second, distance = t.first;        if (st[ver]) continue;        st[ver] = true;        for (int i = h[ver]; i != -1; i = ne[i])        {            int j = e[i];            if (dist[j] &gt; distance + w[i])            {                dist[j] = distance + w[i];                heap.push({dist[j], j});            }        }    }    if (dist[n] == 0x3f3f3f3f) return -1;    return dist[n];}\n\n\n\n！思考：为何Dijkstra只对非负权边有效，能举出例子证明吗？\n例题洛谷P4779 【模板】单源最短路径（标准版）\n洛谷P1144 最短路计数\n洛谷P1948 Telephone Lines S\n\n题目\n题目描述\n多年以后，笨笨长大了，成为了电话线布置师。由于地震使得某市的电话线全部损坏，笨笨是负责接到震中市的负责人。该市周围分布着  根据  顺序编号的废弃的电话线杆，任意两根线杆之间没有电话线连接，一共有  对电话杆可以拉电话线。其他的由于地震使得无法连接。\n第i对电线杆的两个端点分别是  ，，它们的距离为 。数据中每对  只出现一次。编号为  的电话杆已经接入了全国的电话网络，整个市的电话线全都连到了编号  的电话线杆上。也就是说，笨笨的任务仅仅是找一条将  号和  号电线杆连起来的路径，其余的电话杆并不一定要连入电话网络。\n电信公司决定支援灾区免费为此市连接  对由笨笨指定的电话线杆，对于此外的那些电话线，需要为它们付费，总费用决定于其中最长的电话线的长度（每根电话线仅连接一对电话线杆）。如果需要连接的电话线杆不超过  对，那么支出为 。\n请你计算一下，将电话线引导震中市最少需要在电话线上花多少钱？\n输入\n输入文件的第一行包含三个数字 。\n第二行到第  行，每行分别都为三个整数 。\n输出\n一个整数，表示该项工程的最小支出，如果不可能完成则输出 -1。\n样例输入 #1\n123456785 7 11 2 53 1 42 4 83 2 35 2 93 4 74 5 6\n\n样例输出 #1\n14\n\n\n\n\n题解\n思路：\n题目大概意思是这样子，给一个双向图，要找第到的最短路。对于任意一条路径，其费用为第条边的费用，其实就是在找第最短路。\n只需要二分判断某个费用能否满足即可\n大概流程是这样：对于费用，大于  的边边权为  ，代表免费修建的道路条数；其余边权为 ，这样子求出来的最短路其实就是最少免费修建的道路的条数，如果总条数 则满足不了，否则可以满足，判断更小的费用能否满足，直至找到最小的费用\n代码：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117// 第k+1短路// 稀疏图,堆优化dijkstra#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#define x first#define y secondusing namespace std;typedef pair&lt;int, int&gt; PII;const int N = 1e3 + 10, M = 2e4 + 10;int n, m, k;int h[N], ne[M], e[M], w[M], idx;int dist[N];bool st[N];int l, r, mid;void add(int a, int b, int c){\te[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;}bool check_connect(){\tmemset(dist, 0x3f, sizeof dist);\tmemset(st, false, sizeof st);\tpriority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; q;\tq.push({ 0, 1 });\twhile (q.size())\t{\t\tauto t = q.top();\t\tq.pop();\t\tint p = t.y, d = t.x;\t\tif (st[p]) continue;\t\tst[p] = true;\t\tfor (int i = h[p]; ~i; i = ne[i])\t\t{\t\t\tint j = e[i];\t\t\tif (dist[j] &gt; d + w[i])\t\t\t{\t\t\t\tdist[j] = d + w[i];\t\t\t\tq.push({ dist[j], j });\t\t\t}\t\t}\t}\treturn dist[n] &lt; 0x3f3f3f3f &gt;&gt; 1;}bool check(int x){\tmemset(dist, 0x3f, sizeof dist);\tmemset(st, false, sizeof st);\tpriority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; q;\tq.push({ 0, 1 });\twhile (q.size())\t{\t\tauto t = q.top();\t\tq.pop();\t\tint p = t.y, d = t.x;\t\tif (st[p]) continue;\t\tst[p] = true;\t\tfor (int i = h[p]; ~i; i = ne[i])\t\t{\t\t\tint j = e[i], d1 = w[i] &gt; x ? 1 : 0;\t\t\tif (dist[j] &gt; d + d1)\t\t\t{\t\t\t\tdist[j] = d + d1;\t\t\t\tq.push({ dist[j], j });\t\t\t}\t\t}\t}\treturn dist[n] &lt;= k;}int main(){\tcin &gt;&gt; n &gt;&gt; m &gt;&gt; k;\t// 初始化邻接表\tmemset(h, -1, sizeof h);\tfor (int i = 0, a, b, c; i &lt; m; i++)\t{\t\tcin &gt;&gt; a &gt;&gt; b &gt;&gt; c;\t\tadd(a, b, c), add(b, a, c);\t\tr = max(r, c);\t}\t// 先判断是否联通\tif (!check_connect())\t{\t\tputs(\"-1\");\t\treturn 0;\t}\t// 开始二分\twhile (l &lt; r)\t{\t\t// 能满足的最小值\t\tmid = l + r &gt;&gt; 1;\t\tif (check(mid)) r = mid;\t\telse l = mid + 1;\t}\tcout &lt;&lt; l &lt;&lt; endl;\treturn 0;}\n\n\n\n(2)存在负权边①Bellman-Ford算法思路：\n在Dijkstra算法中，每个点第一次出队时最短路已经被确定\n但在存在负权边的情况下，这一性质被改变，故Dijkstra失效\n对于边  ，需要用到松弛操作，松弛操作对应下面的式子：。\n这么做的含义是显然的：我们尝试用 （其中  的路径取最短路）这条路径去更新  点最短路的长度，如果这条路径更优，就进行更新。\nBellman–Ford 算法所做的，就是不断尝试对图上每一条边进行松弛。我们每进行一轮循环，就对图上所有的边都尝试进行一次松弛操作，当一次循环中没有成功的松弛操作时，算法停止。\n每次循环是  的，那么最多会循环多少次呢？\n在最短路存在的情况下，由于一次松弛操作会使最短路的边数至少+1，而最短路的边数最多为 ，因此整个算法最多执行  轮松弛操作。故总时间复杂度为 。\n但还有一种情况，如果从  点出发，抵达一个负环时，松弛操作会无休止地进行下去。注意到前面的论证中已经说明了，对于最短路存在的图，松弛操作最多只会执行  轮，因此如果第  轮循环时仍然存在能松弛的边，说明从  点出发，能够抵达一个负环。\n注意事项：\n复杂度: ​\n用的比较少\n\n代码模板：123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;int n, m;       // n表示点数，m表示边数int dist[N];        // dist[x]存储1到x的最短路距离struct Edge     // 边，a表示出点，b表示入点，w表示边的权重{    int a, b, w;}edges[M];// 求1到n的最短路距离，如果无法从1走到n，则返回-1。int bellman_ford(){    memset(dist, 0x3f, sizeof dist);    dist[1] = 0;    // 如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。    for (int i = 0; i &lt; n; i ++ )    {        for (int j = 0; j &lt; m; j ++ )        {            int a = edges[j].a, b = edges[j].b, w = edges[j].w;            if (dist[b] &gt; dist[a] + w)                dist[b] = dist[a] + w;        }    }    if (dist[n] &gt; 0x3f3f3f3f / 2) return -1;    return dist[n];}\n\n\n\n②SPFA算法思路：很多时候我们并不需要那么多无用的松弛操作。\n很显然，只有上一次被松弛的结点，所连接的边，才有可能引起下一次的松弛操作。\n那么我们用队列来维护「哪些结点可能会引起松弛操作」，就能只访问必要的边了。\nSPFA 也可以用于判断  点是否能抵达一个负环，只需记录最短路经过了多少条边，当经过了至少  条边时，说明 ​ 点可以抵达一个负环。\n注意事项：\n复杂度:一般  ，最多 \n代码短，非负权边的情况一般也能用，但是容易被卡，建议还是在存在负权边时才用  参考文献—「笔记」如何优雅地卡 Spfa\n要求一定不含负环！！！！！\n\n代码模板：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;int n;      \t\t\t\t\t\t\t// 总点数int h[N], w[N], e[N], ne[N], idx;       // 邻接表存储所有边int dist[N];        \t\t\t\t\t// 存储每个点到1号点的最短距离bool st[N];     \t\t\t\t\t\t// 存储每个点是否在队列中void init(){    memset(h, -1, sizeof h);}// 连接a→b的有向边void add(int a,int b, int c){    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;}// 求1号点到n号点的最短路距离，如果从1号点无法走到n号点则返回-1int spfa(){    memset(dist, 0x3f, sizeof dist);    dist[1] = 0;    queue&lt;int&gt; q;    q.push(1);    st[1] = true;    while (q.size())    {        auto t = q.front();        q.pop();        st[t] = false;        for (int i = h[t]; i != -1; i = ne[i])        {            int j = e[i];            if (dist[j] &gt; dist[t] + w[i])            {                dist[j] = dist[t] + w[i];                if (!st[j])     // 如果队列中已存在j，则不需要将j重复插入                {                    q.push(j);                    st[j] = true;                }            }        }    }    if (dist[n] == 0x3f3f3f3f) return -1;    return dist[n];}\n\n\n\n例题：洛谷P1144 最短路计数\n洛谷P3385 【模板】负环\n2.多源最短路Floyd算法思路：就是暴力枚举所有的边，不断更新最短路\n注意事项：\n是用来求任意两个结点之间的最短路的（多源最短路）。\n\n复杂度  ，但是常数小，容易实现（只有三个 for）。\n\n适用于任何图，不管有向无向，边权正负，但是最短路必须存在。（不能有个负环）\n\n\n代码：1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int INF = 0x3f3f3f3f;int d[N][N]; // 邻接矩阵存距离// 初始化void init(){\tfor (int i = 1; i &lt;= n; i ++ )        for (int j = 1; j &lt;= n; j ++ )            if (i == j) d[i][j] = 0;            else d[i][j] = INF;}// 算法结束后，d[a][b]表示a到b的最短距离void floyd(){    for (int k = 1; k &lt;= n; k ++ )        for (int i = 1; i &lt;= n; i ++ )            for (int j = 1; j &lt;= n; j ++ )                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);}\n\n\n\n例题：洛谷P1119 灾后重建\n","slug":"图论-最短路","date":"2024-09-26T05:09:40.000Z","categories_index":"算法","tags_index":"最短路,图论,Dijkstra,SPFA,Bellman-Ford,Floyd","author_index":"Jerry"},{"id":"708fa6adfa46361c793158b58a61f772","title":"bfs","content":"宽度优先搜索\n待整理…………\n模型\nFlood Fill\n多源bfs\n双端队列bfs\n双向广搜\nA*\n","slug":"bfs","date":"2024-09-26T05:09:28.000Z","categories_index":"","tags_index":"","author_index":"Jerry"},{"id":"c0864a7ed82c2e6dd4eb8a34dacd4941","title":"dfs","content":"深度优先搜索\n想了一下dfs还是挺杂的，近期可能暂时整理不完啦，丢几个关键词，后续计划更新\n判断连通性\n剪枝\n\n可行性\n最优性\n估测性-预测未来\n\n迭代加深—早回头\n双向DFS\nIDA*\n","slug":"dfs","date":"2024-09-26T05:09:23.000Z","categories_index":"","tags_index":"","author_index":"Jerry"},{"id":"f897c3d44f1ea027302ceab6694fc628","title":"单调队列与单调栈","content":"\n  .image-grid {\n    display: grid;\n    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); /* 自动适应屏幕宽度 */\n    gap: 10px; /* 图片间距 */\n  }\n  .image-grid img {\n    width: 100%;\n    height: auto; /* 保持图片比例 */\n    border-radius: 8px; /* 图片圆角 */\n    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1); /* 添加阴影效果 */\n  }\n\n\n\n单调栈与单调队列引言单调栈和单调队列，顾名思义，就是在原本的基础上加上单调性的栈和队列。\n它们是为了解决高效获取极值问题而设计的特殊数据结构，核心思想是利用数据的单调性（递增或递减顺序），减少不必要的比较操作，显著提升算法效率。\n在许多问题中，比如滑动窗口最大值、寻找数组中相邻的更大或更小元素，传统方法每一层迭代均遍历之前每个元素来求最值的思路实际上是浪费了之前迭代所得到的’信息’，导致复杂度高达  ，而单调栈和单调队列恰好使得后面的迭代可以用上之前迭代留下来的’信息’，减少不必要的遍历，从而使复杂度优化到 。\n\n单调栈适合用于处理相邻元素的比较，常用于寻找左右两侧的更大或更小值。\n单调队列适合用于连续范围内的极值查询，如滑动窗口问题。\n\n单调栈1.介绍单调栈分为单调递增栈和单调递减栈\n通过在元素入栈时弹出栈顶不符合单调性的元素\n示例：\n\n  \n  \n  \n  \n  \n  \n\n\n\n2.例题洛谷P5788 【模板】单调栈\n题目\n题目描述\n给出项数为  的整数数列 。\n定义函数  代表数列中第  个元素之后第一个大于  的元素的下标，即 。若不存在，则 。\n试求出 。\n输入\n第一行一个正整数 。\n第二行  个正整数 。\n，\n输出\n一行  个整数表示  的值。\n样例输入 #1\n1251 4 2 3 5\n\n样例输出 #1\n12 5 4 5 0\n\n\n\n\n题解\n思路\n对数组两项 \n如果，显然  不可能有机会被用上\n用栈来存有可能被用上的元素，对于不可能被用上的直接丢掉，则栈中任意元素满足  ，是个单调递增栈\n所以只需要从右到左一个个元素遍历\n不断出栈到栈顶元素大小比自己大，此时栈顶元素的下标就是答案，再把当前元素入栈\n每个元素入栈一次出栈一次，复杂度 \n代码\n12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;stack&gt;using namespace std;typedef pair&lt;int, int&gt; PII; // 要多一维存下标const int N = 3e6 + 10;int n;int a[N];stack&lt;PII&gt; stk;int main(){\tios::sync_with_stdio(false);\tcin.tie(0);\tcout.tie(0);\tcin &gt;&gt; n;\tfor (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i];\tfor (int i = n; i &gt;= 1; i--)\t{\t\tPII t = { a[i], i };\t\twhile (!stk.empty() &amp;&amp; stk.top().first &lt;= a[i])\t\t\tstk.pop();\t\t// 没有比自己大的\t\tif (stk.empty()) a[i] = 0;\t\telse a[i] = stk.top().second;\t\tstk.push(t); // 入栈\t}\tfor (int i = 1; i &lt;= n; i++) cout &lt;&lt; a[i] &lt;&lt; \" \";\treturn 0;}\n\n\n\n\n\n进阶一点\n洛谷P2701 巨大的牛棚Big Barn单调队列1. 介绍单调队列分为单调递增队列和单调递减队列\n其基本原理是通过在队列中维护一个单调性的顺序，使得可以在 O(1) 的时间内获取队列的极值。\n在处理滑动窗口问题时，我们通常会维护一个队列，使得队列中元素的顺序始终是单调的。这样，我们可以在每次滑动窗口时，通过简单的队列操作来获取当前窗口的最大或最小值。\n2. 例题洛谷P1886 滑动窗口 /【模板】单调队列\n题目\n题目描述\n有一个长为  的序列 ，以及一个大小为  的窗口。现在这个从左边开始向右滑动，每次滑动一个单位，求出每次滑动后窗口中的最大值和最小值。\n例如，对于序列  以及 ，有如下过程：\nMisplaced \\hline \\def\\arraystretch{1.2} \\begin{array}{|c|c|c|}\\hline \\textsf{窗口位置} &amp; \\textsf{最小值} &amp; \\textsf{最大值} \\ \\hline \\verb![1   3  -1] -3   5   3   6   7 ! &amp; -1 &amp; 3 \\ \\hline \\verb! 1  [3  -1  -3]  5   3   6   7 ! &amp; -3 &amp; 3 \\ \\hline \\verb! 1   3 [-1  -3   5]  3   6   7 ! &amp; -3 &amp; 5 \\ \\hline \\verb! 1   3  -1 [-3   5   3]  6   7 ! &amp; -3 &amp; 5 \\ \\hline \\verb! 1   3  -1  -3  [5   3   6]  7 ! &amp; 3 &amp; 6 \\ \\hline \\verb! 1   3  -1  -3   5  [3   6   7]! &amp; 3 &amp; 7 \\ \\hline \\end{array} \n输入\n输入一共有两行，第一行有两个正整数 。第二行  个整数，表示序列 \n，\n输出\n输出共两行，第一行为每次窗口滑动的最小值第二行为每次窗口滑动的最大值\n样例输入 #1\n128 31 3 -1 -3 5 3 6 7\n\n样例输出 #1\n12-1 -3 -3 -3 3 33 3 5 5 6 7\n\n\n\n\n题解\n思路\n利用单调递减队列来维护当前滑动窗口的最大值。\n\n使用队列存储元素的索引，并在每次新元素进入窗口时，弹出队列中小于当前元素的索引（因为这些元素不会成为最大值）。\n确保队列的头部始终是当前窗口的最大值的索引。\n在每次移动窗口时，移除超出窗口的元素。\n\n最小值类似\n代码\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;const int N = 1e6 + 10;int n, k;int a[N];deque&lt;int&gt; q;int main(){    ios::sync_with_stdio(false);    cin.tie(0);    cout.tie(0);        cin &gt;&gt; n &gt;&gt; k;         for (int i = 1; i &lt;= n; i ++ ) cin &gt;&gt; a[i];        // 第一遍维护最小值    for (int i = 1; i &lt;= n; i ++ )    {        // 窗口外的出队        while (q.size() &amp;&amp; q.front() &lt; i - k + 1) q.pop_front();                // 维护新队列\t\twhile (q.size() &amp;&amp; a[q.back()] &gt;= a[i]) q.pop_back();        q.push_back(i);                // 判断是否要输出        if (i &gt;= k) cout &lt;&lt; a[q.front()] &lt;&lt; \" \";\t}    cout &lt;&lt; endl;        // 第二遍维护最大值    while (q.size()) q.pop_back();    for (int i = 1; i &lt;= n; i ++ )    {        while (q.size() &amp;&amp; q.front() &lt; i - k + 1) q.pop_front();        while (q.size()  &amp;&amp; a[q.back()] &lt;= a[i]) q.pop_back();        q.push_back(i);                if (i &gt;= k) cout &lt;&lt; a[q.front()] &lt;&lt; \" \";         \t}        return 0;}\n\n\n\n\n\n进阶一点\n洛谷P2216  理想的正方形洛谷P3422 LOT-A Journey to Mars洛谷P2627 Mowing the Lawn G ","slug":"单调队列与单调栈","date":"2024-09-26T05:09:03.000Z","categories_index":"数据结构","tags_index":"单调队列,单调栈","author_index":"Jerry"},{"id":"c18469ab20e7b093d36b4a61728d07eb","title":"并查集","content":"并查集（Union-Find）概述并查集是一种高效的数据结构，以多棵树的形式存储，每棵树有一个被打上标记的根节点\n主要用途：\n\n合并两个集合\n查询元素所属的集合\n\n常见题型：\n\n朴素并查集\n带权并查集\n维护size并查集\n\n结构并查集通常使用三个数组实现：\n\np[] (parent)数组：记录每个元素的父节点。\nd[] (distanse)数组：记录每个元素到父节点距离\nsize[]数组：记录每个并查集的大小\n\nps:虽然并查集在逻辑结构上是一棵棵在同一集合的树，但是存储结构仍可以用普通的数组实现\n操作1.建立初始化并查集\n并查集根节点root:的标记方式p[root] = root\n表示根节点的父节点就是自己\n123456void init()&#123;\t// 一开始每个节点各自为营\tfor (int i = 1; i &lt;= n; i ++ )\t\tp[i] = i;&#125; \n\n2.查找查找元素 x 所在集合的根节点：\n这里有个优化，利用递归在查找的时候就直接把每个节点的父节点压缩向了祖宗节点，此时距离d也更新为了到父节点(祖宗节点)的距离\n1234567891011int find(int x)&#123;    if (p[x] != x) p[x] = find(p[x]);    // p[x]效果为找x的祖宗节点    // 这里调用p[x] = find(p[x])直接让x的父节点指向了p[x]的祖宗节点    // 经过层层递归会最终指向整棵树的根节点    int root = find(p[x]);     // 先要存root是因为只有先跑find()才能让d[p[x]]变为p[x]到祖宗节点的距离    d[x] += d[p[x]];    return root;&#125;\n\n\n\n3.合并合并两棵树：\n12345678910111213void merge(int x, int y)&#123;\t// 找出两棵树的根节点\tint px = find(x), py = find(y);\t\t// 根节点不同才需要合并\tif (px != py)     &#123;\t\tp[px] = py;        size[py] += size[px];        // 可能还需要对d[px]进行操作,具体情形依题目而定\t&#125;&#125;\n\n至此，并查集的基本操作均已介绍完毕，操作简洁作用大，用处这么大的数据结构上哪里找呀~\n来几道例题尝试尝试~\n例题朴素并查集\n洛谷 P3367 【模板】并查集\n\n\n维护size的并查集\n洛谷P1455 搭配购买\n\n\n维护到祖宗节点距离的并查集(带权并查集)\n 洛谷P1196 银河英雄传说\n 洛谷P2024食物链 \n","slug":"并查集","date":"2024-09-26T05:08:52.000Z","categories_index":"数据结构","tags_index":"并查集","author_index":"Jerry"},{"id":"a448dfd8ebb4408d1633f0dff8411f1c","title":"线段树","content":"线段树（Segment Tree）概述线段树是一种高效的数据结构，用于解决区间查询和更新问题。它能够在 (O(\\log n)) 时间复杂度内完成以下操作：\n\n查询区间和\n更新区间元素\n\n线段树特别适用于需要频繁处理区间查询和动态更新的场景。\n数据结构线段树通常使用完全二叉树的形式存储，节点表示数组的不同区间。假设原数组为 A，线段树为 ST，则每个节点 ST[node] 表示数组 A 的某个区间的值。\n操作1. 建树操作构建线段树的过程如下：\npythondef build(A, ST, node, start, end):\n    if start == end:\n        ST[node] = A[start]  # 叶子节点\n    else:\n        mid = (start + end) // 2\n        build(A, ST, 2 * node + 1, start, mid)  # 构建左子树\n        build(A, ST, 2 * node + 2, mid + 1, end)  # 构建右子树\n        ST[node] = ST[2 * node + 1] + ST[2 * node + 2]  # 计算节点值","slug":"线段树","date":"2024-09-26T05:05:40.000Z","categories_index":"数据结构","tags_index":"线段树","author_index":"Jerry"},{"id":"7ff326fdf142ec1868a8e7b87c57157c","title":"基础数据结构","content":"基础数据结构前言本文旨在帮助读者理解几种基本数据结构的原理,并能将数据结构充分的运用到算法题目当中\n介绍的数据结构均会以数组的形式模拟 \n 相对于传统用类/结构体的形式书写,这样虽然会导致一部分空间的浪费,但避免了复杂的指针处理并且各种操作的速度更快,在算法题中具有相当的优势\n闲言少叙,让我们开始吧!\n一、链表1.单链表介绍在算法题中,单链表常以邻接表的形式,用来存储图和树\n此外,拉链法创建哈希表也是以单链表的形式组织起来的\n结构 存当前节点的值\n  存当前节点的下一个节点的序号(相当于地址),当指向链表尾时为-1\n 总节点数量(包括被删除的) \n  存头节点的序号(相当于地址)\n操作1.初始化 \t\n12345void init(){\thead = -1; // 头节点为空\tidx = 0;   // 当前链表节点数为0}\n\n2.把新结点插到最前面 \t\n12345678// 头插xvoid add_to_head(int x){\te[idx] = x; \t\t// 建立新节点,唯一序号为idx(第idx+1个点序号为idx)→这个唯一序号等价于地址\tne[idx] = head;\t\t// 指向原本的头\thead = idx; \t\t// 换头\tidx ++ ; \t\t\t// 总节点数量+1}\n\n3.把新结点放到第k个插入的节点后 \t\n12345678// 中间插void add(int k, int x){\te[idx] = x;\tne[idx] = ne[k];\tne[k] = idx;    idx ++ ;}\n\n4.删除第  个插入节点 \t\n1234void remove(int k){\tne[k - 1] = ne[k];}\n\n有些题目描述的插入删除操作可能这里的不一样\n实际上这些具体操作并不会直接考出来，在算法题中数据结构的根本是用来帮助存储并尽可能降低时间复杂度，不会作为算法本身来考,关键是要理解运用\n2.双链表结构头节点占第  格,尾节点占第  格\n 当前节点的值\n 当前节点前一个节点的序号\n  当前节点后一个节点的序号\n 总节点数量(包括被删除的)\n  头节点序号\n操作1.初始化 \t\n123456void init(){\t// 头节点0,尾节点1\tr[0] = 1, l[1] = 0;\tidx = 2; // 初始链表就有头尾2个节点}\n\n2.在第  个插入的节点右端插入   \t\n1234567void insert(int k, int x){    e[idx] = x;    l[idx] = k, r[idx] = r[a];    l[r[a]] = idx, r[a] = idx;    idx ++ ;}\n\n2.删除第  个插入的节点 \t\n12345void remove(int k){    l[r[k]] = l[a];    r[l[a]] = r[a];}\n\n\n\n二、栈和队列1.栈介绍先进后出\n常在  (深搜)用于存储一组可行解\n拓展  单调栈\n结构  栈本身\n 栈顶 \n操作12345678910111213int stk[N], tt = 0; // tt表示栈顶// pushstk[ ++ tt] = x;// poptt -- ;//top;stk[tt];// isEmpty;return tt &lt;= 0;\n\n\n\n例题洛谷P1739 表达式括号匹配\n洛谷P1981表达式求值\n洛谷P1175 表达式的转换\n\n代码\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120// 中缀转后缀,从左往右扫,操作数直接输出,操作符弹出优先级更高的再入栈#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;cmath&gt;using namespace std;const int N = 1e3 + 10;string s;stack&lt;char&gt; ops;map&lt;char, int&gt; mp = { {'+', 1}, {'-', 1}, {'*', 2}, {'/', 2}, {'^', 3} };void cal(string s){\t// 进行一次运算\tint num[N], tt = 0;\tstring str = \"\";\tfor (int i = 0; i &lt; s.size(); i++)\t{\t\tif (isdigit(s[i]))\t\t{\t\t\tint j = i, res = 0;\t\t\twhile (isdigit(s[j]))\t\t\t{\t\t\t\tres = res * 10 + s[j] - '0';\t\t\t\tj++;\t\t\t}\t\t\ti = j - 1, num[tt++] = res;\t\t}\t\telse if (s[i] !=  ' ')\t\t{\t\t\t// 进行计算\t\t\tint a = num[tt - 2], b = num[tt - 1];\t\t\ttt -= 2;\t\t\tif (s[i] == '+') num[tt++] = a + b;\t\t\telse if (s[i] == '-') num[tt++] = a - b;\t\t\telse if (s[i] == '*') num[tt++] = a * b;\t\t\telse if (s[i] == '/') num[tt++] = a / b;\t\t\telse num[tt++] = pow(a, b);\t\t\tfor (int j = 0; j &lt; tt; j++)\t\t\t\tcout &lt;&lt; num[j] &lt;&lt; \" \";\t\t\tfor (int j = i + 2; j &lt; s.size(); j++)\t\t\t\tcout &lt;&lt; s[j];\t\t\tcout &lt;&lt; endl;\t\t}\t}}int main(){\tcin &gt;&gt; s;\t\tstring res = \"\"; // 存储转换结果\tfor (int i = 0; i &lt; s.size(); i++)\t{\t\tif (isdigit(s[i]))\t\t{\t\t\tint j = i;\t\t\twhile (isdigit(s[j])) res += s[j], j ++ ;\t\t\ti = j - 1, res += \" \";\t\t}\t\telse\t\t{\t\t\tif (s[i] == '(') ops.push(s[i]);\t\t\telse if (s[i] == ')')\t\t\t{\t\t\t\t// 开始计算\t\t\t\twhile (ops.top() != '(')\t\t\t\t{\t\t\t\t\tres += ops.top();\t\t\t\t\tres += \" \";\t\t\t\t\tops.pop();\t\t\t\t}\t\t\t\tops.pop();\t\t\t}\t\t\telse\t\t\t{\t\t\t\tif (s[i] != '^')\t\t\t\t\twhile (ops.size() &amp;&amp; mp[ops.top()] &gt;= mp[s[i]])\t\t\t\t\t{\t\t\t\t\t\tres += ops.top();\t\t\t\t\t\tres += \" \";\t\t\t\t\t\tops.pop();\t\t\t\t\t}\t\t\t\t\t\t\t\telse\t\t\t\t\twhile (ops.size() &amp;&amp; mp[ops.top()] &gt; mp[s[i]])\t\t\t\t\t{\t\t\t\t\t\tres += ops.top();\t\t\t\t\t\tres += \" \";\t\t\t\t\t\tops.pop();\t\t\t\t\t}\t\t\t\tops.push(s[i]);\t\t\t}\t\t}\t}\twhile (ops.size())\t{\t\tres += ops.top();\t\tres += \" \";\t\tops.pop();\t}\tcout &lt;&lt; res &lt;&lt; endl;\tcal(res);\treturn 0;}\n\n\n\n2.队列介绍先进先出\n常在  (宽搜)里用于存储一整层甚至多层节点\n拓展  单调队列\n结构 队列本身\n 队头\n  队尾\n操作12345678910111213int q[N], hh = 0, tt = -1; // hh表示队头, tt表示队尾// pushq[ ++ tt] = x;// pophh ++ ;// frontq[hh];// isEmptyreturn tt &lt; hh;\n\n\n\n例题洛谷B3616 【模板】队列\n三、堆为节约篇幅，这里以小根堆为例,大根堆性质相反\n性质1.是一棵二叉树,除最下一层节点其他全满,最下一层从左排到右\n2.每个点均  左右子节点\n4.3.根节点一定为堆中最小的节点\n如图\n\n\n\n\n结构堆也可以用数组来存\n 堆本身\n 第  个插入的点在堆中的序号\n  堆中序号为k的点是第几个插入的\n  堆中节点数\n建堆时,默认  的左子节点序号  ,  的右子节点序号 \n操作最关键只有2个操作,其余操作均可由这两个操作’拼’出来 \n说明:由于小根堆要求父节点&gt;=左右子节点,当子节点,当子节点的值发生改变,可能会违背这一性质,则需要将修改后的节点上放/下放 \n\n上放第  点 \t\n下放第  点 \t\n123456789101112131415161718192021222324252627282930313233// 交换两个点,及其映射关系void heap_swap(int a, int b){\t    // 交换堆中序号为a,b的点    swap(ph[hp[a]], ph[hp[b]]);    swap(hp[a], hp[b]);    swap(h[a], h[b]);}void up(int x){    // 子节点x&lt;父节点,需要上放x    while (x / 2 &amp;&amp; h[x] &lt; h[x / 2])    {        // 一直和父节点交换直至满足要求        heap_swap(x, x / 2);        x &gt;&gt;= 1;\t}}void down(int x){    int t = x;    if (x * 2 &lt;= size &amp;&amp; h[x * 2] &lt; h[t]) t = x * 2;    if (x * 2 + 1 &lt;= size &amp;&amp; h[x * 2 + 1] &lt; h[t]) t = x * 2 + 1;    if (x != t)    {        // 不满足规则,需要和子节点交换        heap_swap(u, t);        // 有可能还要继续下放        down(t);\t}}\n\n\n1.插入   \t\n123456// 先插到最下一层,然后往上放void insert(int x){\theap[++size] = x;\tup(size);}\n\n2.求最小值   \n3.删除最小值 \t\n12345// 把堆顶换成堆尾的值,然后把它下放,size-1void delete(){    heap[1] = heap[size], size --, down(1);}\n\n删除第个节点\n12345// 思路同上,只不过换完之后可能需要上可能需要下,两个都做一遍保险一点void remove(int k){    heap[k] = heap[size], size --, down(k), up(k);}\n\n修改第个节点\n123456// 改,上放一遍,下放一遍void modify(int k, int x){\theap[k] = x;\tup(k), down(k);}\n\n\n\n例题洛谷P3378 堆\n","slug":"基础数据结构","date":"2024-09-26T05:01:20.000Z","categories_index":"数据结构","tags_index":"链表,栈,队列,堆","author_index":"Jerry"},{"id":"36ef81d64d1d0edc64820d5afd16a0b4","title":"树状数组","content":"树状数组（Fenwick Tree）概述树状数组是一种用于高效处理动态数组中前缀和查询的数据结构。它能够在  时间复杂度内完成以下操作：\n\n更新数组中的元素O(logn)\n查询数组前缀和O(logn)\n\n数组： O(1) 更新，O(n) 前缀和\n前缀和数组：  O(n) 更新，O(1) 前缀和\n如果问题同时要大量更新和求前缀和，上述两种数据结构均会寄掉\n树状数组则采取折中思路，把整体复杂度降低至O(logn)\n数据结构先放张整体结构图：\n\n\n\n\n核心思想：二进制\n对任意数x可将其二进制分解\n其中\n从而将区间(0, x]分为以下几个部分：\n长度\n长度\n长度\n长度\n容易发现，对于任意一段区间(L,R]\n区间长度为lowbit(x),区间左端点L = R - lowbit(R)\n则在上述规则下，只要确定右端点，左端点的信息也唯一确定\n\n树状数组用一个数组来存储序列的信息:\ntr[x]：存储序列在[x - lowbit(x) + 1, x]之间的数的片段和\n则按照前面的区间划分规则\n\n看到公式的第三行，很容易想到可以用递归来实现，只需每层往下不断-lowbit(t)就行\nx最多只有logx位1，所以树状数组求前缀和的操作复杂度是O(logn)\n类似的，若要实现在原数组第x位上添加c均需添加c(可能这个结论不是那么明显，读者可自行思考其中的原理，后续笔者将补充上证明)\n当然这里不会无穷往后面加，我们只需用到1~n的数据，当加到超过n就可以停了，故整该操作的复杂度仍旧为O(logn)（分析同求和\n一个更容易理解的视频讲解\n操作1. lowbit运算复杂度：O(1)\n代码如下，大家可以自行找几个数验证一下\n12345int lowbit(int x){    // 取出x的最后一位1    return x &amp; -x;}\n\n\n\n2.添加复杂度：O(logn)\n123456int add(int x, int c){\t// 向第x位添加c,c可正可负\t// 对所有含第x位的树节点均加上c\tfor (int i = X; i &lt;= n; i += lowbit(i)) tr[i] += c;}\n\n\n\n3.前缀和复杂度：O(logn)\n1234567int sum(int x){\t// 对第1~x位求和\t// 计算当前数存的值,然后迭代求剩余节点的值\tif (!x) return 0;\treturn tr[x] + sum(x - lowbit(x));}\n\n\n\n\n\n例题洛谷 P10589 楼兰图腾\n\n题目\n题目描述\n在完成了分配任务之后，西部 314 来到了楼兰古城的西部。相传很久以前这片土地上（比楼兰古城还早）生活着两个部落，一个部落崇拜尖刀（V），一个部落崇拜铁锹（∧），他们分别用 V 和 ∧ 的形状来代表各自部落的图腾。\n西部 314 在楼兰古城的下面发现了一幅巨大的壁画，壁画上被标记出了  个点，经测量发现这  个点的水平位置和竖直位置是两两不同的。西部 314 认为这幅壁画所包含的信息与这  个点的相对位置有关，因此不妨设坐标分别为 ，其中  是  到  的一个排列。\n\n如图，图中的 ，，，，。\n西部 314 打算研究这幅壁画中包含着多少个图腾，其中 V 图腾的定义如下（注意：图腾的形式只和这三个纵坐标的相对大小排列顺序有关） 且 , ；\n而崇拜 ∧ 的部落的图腾被定义为  且 ，；\n西部 314 想知道，这  个点中两个部落图腾的数目。因此，你需要编写一个程序来求出 V 的个数和 ∧ 的个数。\n输入\n第一行一个正整数 ；\n第二行是  个正整数，分别代表 ​。\n，答案不超过 。\n输出\n输出两个数，中间用空格隔开，依次为 V 的个数和 ∧ 的个数\n样例输入 #1\n1251 5 3 2 4\n\n样例输出 #1\n13 4\n\n\n\n\n题解\n思路\n对字形图腾，只需要知道每个点前后各有多少个比它高的字形反之\n朴素思路是枚举到第个点，再一一枚举前后比它高的元素复杂度需要优化\n想象有这么一个的数轴我从左往右一一读取每个点读完一个点就在数轴上标记 \n则每个点左边比自己高的点数量其实就是前缀和\n而右边的只需从右往左一一读取再来一遍就行\n\n然而这个前缀数组需要一直修改尽管我们可以用的时间读出高点但是需要的时间去维护它\n复杂度仍旧是这就让我们想到了树状数组更新和求和复杂度均为\n树状数组优化后复杂度变为满足要求\n代码如下\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// 利用树状数组存储某个数左/右 大于/小于它自己的数的数量#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;const int N = 2e5 + 10;int n;int a[N];int tr[N];int gre[N], low[N]; // 存储LL res1, res2;inline int lowbit(int x){    return x &amp; (-x);}inline int sum(int x){    // 求前x项的和    if (!x) return 0;    return tr[x] + sum(x - lowbit(x));}inline void add(int x, int c){    for (int i = x; i &lt;= n; i += lowbit(i)) tr[i] += c;}int main(){    scanf(\"%d\", &amp;n);        for (int i = 1; i &lt;= n; i ++ )        scanf(\"%d\", &amp;a[i]);            // 从左到右来一遍    for (int i = 1; i &lt;= n; i ++ )    {        int y = a[i];        gre[i] = sum(n) - sum(y); // 统计在i左边y + 1到n的数的数量        low[i] = sum(y - 1); // 统计在i左边1到y - 1的数的数量        add(y, 1); // 插入这个数    }        memset(tr, 0, sizeof tr);        // 从右到左再来一遍    for (int i = n; i; i --)    {        int y = a[i];        res1 += (LL)gre[i] * (sum(n) - sum(y));        res2 += (LL)low[i] * (sum(y - 1));        add(y, 1);    }            printf(\"%lld %lld\", res1, res2);        return 0;    }\n\n\n\nPOJ 2182 迷路的奶牛  从后往前慢慢确定每头牛高度树状数组前缀和二分\nPOJ 3468  A Simple Problem with Integers  维护两个前缀和数组的树状数组\n","slug":"树状数组","date":"2024-09-26T04:54:35.000Z","categories_index":"数据结构","tags_index":"前缀和,lowbit,树状数组","author_index":"Jerry"},{"id":"8038215b5c2b5aa82664c7d7c50d2cdc","title":"二分","content":"二分\n\n\n\n\n\n\n注意\n❗❗❗❗二分查找的前提是被查找的数据必须有二段性\n\n如何理解这句话呢？\n举个例子，在数组[1, 5 , 8, 9, 23, 25, 40]里找9\n我可以让check标准为&lt;=9，则转化为找数组中&lt;=9最大值\n对于9左边的数，均小于等于9,而对于9右边的数，均大于9\n目标答案的两边一边满足check一边不满足check，这便是二段性的含义\n绝大多数时候，二段性均不明显，需要通过自行定义check标准把二段性弄出来，需要积累一定的题量\n核心思想二分查找通过不断缩小查找范围，每次将范围缩小一半，最终定位目标元素的位置。\n算法思路\n初始化边界\n\n进入二分，check(mid)\n\n重复操作\n\n\n核心：不断折半折半查找的关键在于通过不断折半查找区间，可以大幅度减少查找次数，效率为 O(log n)\n代码模板：二分的模板不唯一，关键就是要判断好循环终止条件和划分好折半区间的边界，避免死循环\n这里放一个我一直在用的模板\n整数二分\n123456789101112131415161718192021// 模板1：check选左bool check(int x){\t// 定义check标准\tif (……) return false;\treturn true;}int main(){    int l = L, r = R; // 初始化边界    int mid;    while (l &lt; r)    {        mid = l + r &gt;&gt; 1;        if (check(mid)) r = mid;        else l = mid + 1;    }    cout &lt;&lt; l &lt;&lt; endl;}\n\n123456789101112131415161718192021// 模板2: check选右bool check(int x){\t// 定义check标准\tif (……) return false;\treturn true;}int main(){    int l = L, r = R;    int mid;    while (l &lt; r)    {        mid = l + r + 1 &gt;&gt; 1;        if (check(mid)) l = mid;        else r = mid - 1;    }    cout &lt;&lt; l &lt;&lt; endl;}\n\n\n\n小数二分\n12345678910111213141516171819bool check(double x){\t// 定义check标准\tif (……) return false;\treturn true;}int main(){\tconst double eps = 1e-6; // 设置精度\tdouble l = L, r = R;\tdouble mid;\twhile (r - l &gt; eps)    {    \tmid = (l + r) / 2;    \tif (check(mid)) r = mid;    \telse l = mid;    }}\n\n\n\n例题洛谷P1083 借教室\n\n题目\n题目描述\n在大学期间，经常需要租借教室。大到院系举办活动，小到学习小组自习讨论，都需要向学校申请借教室。教室的大小功能不同，借教室人的身份不同，借教室的手续也不一样。\n面对海量租借教室的信息，我们自然希望编程解决这个问题。\n我们需要处理接下来  天的借教室信息，其中第  天学校有  个教室可供租借。共有  份订单，每份订单用三个正整数描述，分别为 ，表示某租借者需要从第  天到第  天租借教室（包括第  天和第  天），每天需要租借  个教室。\n我们假定，租借者对教室的大小、地点没有要求。即对于每份订单，我们只需要每天提供  个教室，而它们具体是哪些教室，每天是否是相同的教室则不用考虑。\n借教室的原则是先到先得，也就是说我们要按照订单的先后顺序依次为每份订单分配教室。如果在分配的过程中遇到一份订单无法完全满足，则需要停止教室的分配，通知当前申请人修改订单。这里的无法满足指从第  天到第  天中有至少一天剩余的教室数量不足  个。\n现在我们需要知道，是否会有订单无法完全满足。如果有，需要通知哪一个申请人修改订单。\n输入格式\n第一行包含两个正整数 ，表示天数和订单的数量。\n第二行包含  个正整数，其中第  个数为 ，表示第  天可用于租借的教室数量。\n接下来有  行，每行包含三个正整数 ，表示租借的数量，租借开始、结束分别在第几天。\n每行相邻的两个数之间均用一个空格隔开。天数与订单均用从  开始的整数编号。\n\n输出格式\n如果所有订单均可满足，则输出只有一行，包含一个整数 。否则（订单无法完全满足）\n输出两行，第一行输出一个负整数 ，第二行输出需要修改订单的申请人编号。\n样例输入 #1\n123454 3 2 5 4 3 2 1 3 3 2 4 4 2 4\n\n样例输出 #1\n12-1 2\n\n\n\n题解\n思路\n题目给的变量比较多，大致是这个意思：\n已知天的课室数量分布，份订单每份订单交代了天需要个课室\n从第份订单往后处理，判断哪个订单开始满足不了​\n\n朴素想法是枚举第份订单，然后判断加了订单之后天有没有哪天是满足不了的\n复杂度显然需要优化\n刚好二分可以带来一个的优化，刚好在允许范围内\n\n二分思路：无法满足的最早的一笔订单 \n这份订单前的订单都可以满足包括这份订单之后的都无法满足符合二段性\n这里可以用差分组优化来存储前份订单的数据\n代码如下：\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;typedef long long LL;const int N = 1e6 + 10;int n, m;LL R[N]; // 每天的课室数LL b[N]; // n天需要教室数量的差分数组struct {\tLL d;\tint s, t;} T[N]; // 订单bool check(int x){\t// 判断前x份订单是否能满足\t// 重置差分数组\tmemset(b, 0, sizeof b);\tfor (int i = 1; i &lt;= x; i++)\t\tb[T[i].s] += T[i].d, b[T[i].t + 1] -= T[i].d;\t// 差分数组求前缀和得每天需求量\tfor (int i = 1; i &lt;= n; i++) b[i] += b[i - 1];\t// 检测是否哪天完不成\tfor (int i = 1; i &lt;= n; i++)\t\tif (b[i] &gt; R[i]) return true;\treturn false;}int main(){\tios::sync_with_stdio(false);\tcin.tie(0);\tcout.tie(0);\tcin &gt;&gt; n &gt;&gt; m;\tfor (int i = 1; i &lt;= n; i++) cin &gt;&gt; R[i];\tfor (int i = 1; i &lt;= m; i++) cin &gt;&gt; T[i].d &gt;&gt; T[i].s &gt;&gt; T[i].t;\t// 开始二分\tint l = 1, r = m + 1;\tint mid;\twhile (l &lt; r)\t{\t\t// 找到无法满足的订单里最小的一笔\t\tmid = l + r &gt;&gt; 1;\t\tif (check(mid)) r = mid;\t\telse l = mid + 1;\t}\t// 都可满足\tif (l == m + 1) puts(\"0\");\telse cout &lt;&lt; -1 &lt;&lt; endl &lt;&lt; l &lt;&lt; endl;\treturn 0;}\n\n\n\n\n洛谷P3743 小鸟的设备\n\n题目\n题目描述\n小鸟有  个可同时使用的设备。第  个设备每秒消耗  个单位能量。能量的使用是连续的，也就是说能量不是某时刻突然消耗的，而是匀速消耗。也就是说，对于任意实数，在  秒内消耗的能量均为  单位。在开始的时候第  个设备里存储着  个单位能量。\n同时小鸟又有一个可以给任意一个设备充电的充电宝，每秒可以给接通的设备充能  个单位，充能也是连续的，不再赘述。你可以在任意时间给任意一个设备充能，从一个设备切换到另一个设备的时间忽略不计。\n小鸟想把这些设备一起使用，直到其中有设备能量降为  。所以小鸟想知道，在充电器的作用下，她最多能将这些设备一起使用多久。\n输入\n第一行给出两个整数 。\n接下来  行，每行表示一个设备，给出两个整数，分别是这个设备的  和 ​。\n，，。\n输出格式\n如果小鸟可以无限使用这些设备，输出 。\n否则输出小鸟在其中一个设备能量降为  之前最多能使用多久。\n设你的答案为 ，标准答案为 ，只有当  满足 的时候，你能得到本测试点的满分。\n样例输入 #1\n1232 12 22 1000\n\n样例输出 #1\n12.0000000000\n\n样例输入 #2\n121 1001 1\n\n样例输出 #2\n1-1\n\n样例输入 #3\n12343 54 35 26 1\n\n样例输出 #3\n10.5000000000\n\n\n\n\n题解\n思路\n能量连续使用，提醒我们这是小数二分\n二分思路找到无法使用的最短时间\n代码如下\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const double eps = 1e-6; //设置精度const int N = 1e5 + 10;int n;double p;double a[N], b[N];bool check(double x){    // 不能完成返回真,能完成返回假    double res = 0;    for (int i = 1; i &lt;= n; i++)    {        res -= min(b[i] - a[i] * x, 0.0);    }    return res &gt; p * x;}int main(){    ios::sync_with_stdio(false);    cin.tie(0);    cout.tie(0);    cin &gt;&gt; n &gt;&gt; p;    for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i] &gt;&gt; b[i];    double l = 0, r = 10000000001; // 设置最大边界,估一下大概在10^10量级    double mid;    while (r - l &gt; eps)    {        // 二分无法使用的最小值        mid = (l + r) / 2;        if (check(mid)) r = mid;        else l = mid;    }    if (r &gt; 10000000000) puts(\"-1\");    else cout &lt;&lt; l &lt;&lt; endl;    return 0;}\n\n\n\n洛谷P9240 冶炼金属 \n\n\n进阶一点\n洛谷P1314 聪明的质监员\n洛谷P1948 Telephone Lines S 找一条连接起点终点的路径，使得第长的边最小分\n","slug":"二分","date":"2024-09-26T02:50:13.000Z","categories_index":"算法","tags_index":"基础算法,二分","author_index":"Jerry"},{"id":"2a1893ca085cc0c5b7d1cdcd8c0b1c91","title":"排序","content":"1.快速排序对数组 q 在下标 l 到 r 的范围内进行升序排序。\n快速排序通过多次的比较和交换，在一趟排序之中确定好选择的基准应该在的位置。这个位置满足的条件是：\n\n它的左边的数都小于它。\n它的右边的数都大于它。\n\n之后对左右的区间进行递归排序，最后所有的数都位于它应该在的地方，排序完成。\n排序思路\n确定分界点 x ：\n\n选择 x 为 q[l]、q[r] 或 q[(l + r) / 2] 中的任意一个。\nps: x可以任取，一般取为q[ l + r &gt;&gt; 1]\n\n\n\n调整数组：\n\nq[l] 到 q[x-1] 中的元素都小于 x，\nq[x+1] 到 q[r] 中的元素都大于或等于 x。\n\n\n递归处理子区间：\n\n\n核心操作双指针：\n\n设置两个指针，i 和 j，分别指向当前区间的头和尾。\n两个指针向中间移动，遇到不满足条件的元素(需要交换)时停止。\n交换这两个指针指向的元素，然后继续移动指针，直到它们相遇。\n\n注意事项\n在判断条件时要确保准确，避免死循环→注意前面的最前面的return判断\n确定好每次递归的区间，确保排序的完整性。\n时间复杂度O(nlogn)\n\n代码：12345678910111213141516void quick_sort(int q[], int l, int r)&#123;\tif (l &gt;= r) return; // 排序完成,返回\tint x = q[l + r &gt;&gt; 1], i = l - 1, j = r + 1;\twhile (i &lt; j)    &#123;\t\t// 当两个指针未相遇时,一直移动直至需要交换    \tdo i ++; while(q[i] &lt; x);    \tdo j --; while(q[j] &gt; x);    \tif (i &lt; j) swap(q[i], q[j]); // 交换    \t    \t// 分治子区间    \tquick_sort(q, l, j);    \tquick_sort(q, j + 1, r);    &#125;&#125;\n\n直接理解可能还是有点抽象，也许你会觉得好像寻找分界点让左小又大能有一定的排序作用，但是get不到为什么这样一通操作能保证全体点都严格排好序，找到了张动态图给大家参考一下~\n\n2.归并排序对数组 q 在下标 l 到 r 的范围内进行升序排序。\n核心思想分治\n排序思路\n确定分界点mid：\n\nmid = (l + r) / 2，将数组分为两部分。\n\n\n递归排序：\n\n递归地对 q[l] ~ q[mid] 和 q[mid+1] ~ q[r] 两部分进行排序，此时两部分已各自有序→当前需要进行的操作仅为归并已经排好的两段区间\n\n\n合并：\n\n\n核心操作双指针：\n\n指针分别指向两部分的头部。\n比较两部分当前指针指向的元素，将较小的复制到一个新的数组中。\n当其中一部分复制完后，将另一部分剩余的元素全部复制到新数组。\n将合并后的新数组复制回原数组。\n\n注意事项\n递归时需要确保左右部分的区间划分正确。\n时间复杂度O(nlogn)\n\n代码：12345678910111213141516171819202122232425262728const int N = 1e6 + 10; // 根据具体题目定数量级int tmp[N]; // 用来临时存归并完的数组void merge_sort(int q[], int l, int r)&#123;\tif (l &gt;= r) return; // 排序完成,返回\t\tint mid = l + r &gt;&gt; 1;\t\t// 排序好子区间\tmerge_sort(q, l, mid), merge_sort(q, mid + 1, r);\t\t// 合并\tint i = l, j = mid + 1, k = 0;\tint tmp[N];\twhile (i &lt;= mid &amp;&amp; j &lt;= r)\t&#123;\t\tif (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ];\t\telse tmp[k ++ ] = q[j ++ ];\t&#125;\t\twhile (i &lt;= mid) tmp[k ++ ] = q[i ++ ];\twhile (j &lt;= r) tmp[k ++ ] = q[j ++ ];\t\t// 把排完序的数组拷贝回去\tfor (i = l, k = 0; i &lt;= r;) q[i ++ ] = q[k ++ ];&#125;\n\n归并排序在大一的程设中也有出现喔，这里贴个图模拟一下排序的流程~\n\n排序模板题：洛谷 P1177 归并排序\n洛谷P1908 逆序对\n","slug":"排序","date":"2024-09-26T02:05:17.000Z","categories_index":"算法","tags_index":"基础算法,快速排序,归并排序","author_index":"Jerry"},{"id":"b70cb6e2fe5cd3e70bacd823f6f633fc","title":"近期规划","content":"欢迎来到我的小天地！🎉嘿，欢迎来到我的小天地！这是一个属于技术与灵感碰撞的角落，无论你是路过还是驻足，都希望这儿能给你带来点什么有趣的东西。\n关于这个博客这个博客就像是我脑海里的“小宇宙”——技术、算法、科研，以及生活里的灵感火花。我想在这里和大家分享自己的探索，可能会有些前端、后端的技术总结，算法题目挑战的记录，项目笔记及日常随笔。\n你可以期待什么？未来这里会不断更新关于技术的思考、算法题的解题策略，也许还会时不时出现一些歌曲推荐 🎸 或者跑步训练随笔 🏃。你可以期待这里每一篇文章都带来一点灵感和乐趣！\n一起互动吧！如果你对某个技术话题感兴趣，或者也喜欢讨论算法问题，随时留言！我非常期待与你的互动。别害羞，我的评论区永远欢迎你！🙌\n\n好了，不多剧透了，先看文章吧！希望你每次来访都能有所收获，并愿意常来坐坐 😊。\n","slug":"近期规划","date":"2024-09-26T01:49:54.000Z","categories_index":"公告","tags_index":"","author_index":"Jerry"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post1$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server1$ hexo server\n\nMore info: Server\nGenerate static files1$ hexo generate\n\nMore info: Generating\nDeploy to remote sites1$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2024-09-25T08:52:32.921Z","categories_index":"博客","tags_index":"博客部署","author_index":"Jerry"}]