[{"id":"b1af6f6437b58f6d156f800c63cd3640","title":"数据结构与算法--week2","content":"1.链表反转\n题目\n题目描述：\n   下面所给的是链表节点的结构，你的任务是写一个函数将链表反转。\n12345678910struct ListNode {    int val;    ListNode *next;    ListNode(){        val=0;        next=NULL;    }    ListNode(int x) : val(x), next(NULL) {}    ~ListNode(){}};\n\n   上述结构定义在头文件ListNode.h中，而你所需实现的函数为：\n1ListNode* reverseList(ListNode* head);\n\n提示：请记得将头文件包含进去，即#include\"ListNode.h\" 。\nListNode.h\n1234567891011121314151617#ifndef ListNode_h#define ListNode_h#include&lt;iostream&gt;using namespace std;struct ListNode { int val; ListNode *next; ListNode(){  val=0;  next=NULL; } ListNode(int x) : val(x), next(NULL) {} ~ListNode(){}};#endif\n\n\n\n思路\n其实就是把链表指向的箭头反过来\n3个指针 一个一个来换方向\n注意判断边界\n代码\n123456789101112131415161718192021#include \"ListNode.h\"ListNode* reverseList(ListNode* head){\t// 至少有2个节点才需要反转\tif (head == NULL || head-&gt;next == NULL) return head;\t\tListNode* pre = NULL;\tListNode* cur = head;\tListNode* next = head-&gt;next;\t\twhile (cur != NULL)\t{\t\tcur-&gt;next = pre;\t\tpre = cur;\t\tcur = next;        if (next != NULL) next = next-&gt;next; // 防止越界\t}\t\treturn pre;}\n\n\n\n\n\n2.飞盘高手\n题目\n题目描述\n杰克是美国某小镇有名的飞盘高手。他掷飞盘的时候有一个习惯，在一叠飞盘中，从第一个飞盘（即位于顶端的飞盘）开始，从上往下依次编号为。当至少还有两个飞盘的时候，杰克通常会掷出一个飞盘，然后把新的第一个飞盘放到所有飞盘的最后。输入  ，输出每次扔掉的飞盘，以及最后剩下的飞盘。\n输入描述\n第一行为一个整数t（），表示测试用例个数。以下  行每行包含一个整数 （）,为一个测试用例的飞碟数。\n输出描述\n为每个测试用例单独输出一行，该行中依次输出每次掷出的飞盘编号以及最后剩下飞盘，每个飞盘后跟着一个空格。\n输入样例\n123274\n\n输出样例\n121 3 5 7 4 2 61 3 2 4\n\n\n\n思路\n直接用STL队列来模拟丢飞盘的过程就行了\n代码\n1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;int t; // 测试用例int n; // 飞盘数int main(){\tcin &gt;&gt; t;\t\twhile (t -- )\t{\t\tcin &gt;&gt; n;\t\tqueue&lt;int&gt; q; // 模拟丢飞盘过程\t\t\t\t// 初始化\t\tfor (int i = 1; i &lt;= n; i ++ ) q.push(i);\t\t\t\twhile (q.size())\t\t{\t\t\tauto s = q.front();\t\t\tq.pop();\t\t\t\t\t\tif (q.size() &gt;= 1) // 丢一个,移一个\t\t\t{\t\t\t\tcout &lt;&lt; s &lt;&lt; \" \";\t\t\t\t\t\t\t\tq.push(q.front());\t\t\t\tq.pop();\t\t\t}\t\t\telse cout &lt;&lt; s &lt;&lt; \" \"; // 直接丢\t\t}\t\t\t\tcout &lt;&lt; endl;\t}}\n\n\n\n\n\n3.简单字符串匹配\n题目\n题目描述\n给定两个字符串  和  ，要求判定  是否能够被  做循环移位（  ）得到的字符串包含。说明：字符串  和  中不包含空格，每个字符串至少包含一个字符。例如：给定 ，，则返回  ；给定  ，，则返回  \n输入描述\n第一行为整数 （），第  到  行为  个输入数据，每行包括两个字符串，字符串  和字符串  。字符串的长度不超过  。\n输出描述\n针对每个例子，如果  能够被  做循环移位得到的字符串包含，输出  ，否则输出  ；每个输出结果为独立的一行。\n输入样例\n1232AABCD CDAAABCD ACBD\n\n输出样例\n12TrueFalse\n\n\n\n思路\n设，容易发现，对于任意  循环移位后的串，必定是  的子串\n所以原题等价于判断  是否为 子串，直接用  函数就行\n代码\n123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;using namespace std;int t;string s1, s2;int main(){\tcin &gt;&gt; t;\t\twhile (t -- )\t{\t\tcin &gt;&gt; s1 &gt;&gt; s2;\t\t\t\tif (s1.size() &lt; s2.size())\t\t{\t\t\tputs(\"False\");\t\t\tcontinue;\t\t}\t\t\t\ts1 += s1;\t\t\t\tif (s1.find(s2) != -1) puts(\"True\");\t\telse puts(\"False\");\t}\t\treturn 0;}\n\n\n\n\n\n4.赛马问题\n题目\n问题描述\nA与B之间将进行一场赛马比赛，C为裁判。A与B分别拥有n匹马，这2n匹马中每匹马拥有的能力值都不相同。比赛前，参赛的两人先决定自己的马的出场顺序；比赛时，A的第一匹马将对战B的第一匹马，A的第二匹马将对战B的第二匹马，以此类推。在每一轮的比赛当中，能力值较高的马将获得胜利，并记其拥有者加1分。进行过n轮比赛之后，得分较高的人将获得最终的胜利，并赢得所有的马。当然，可能存在平局的情况，此时算作裁判C胜利，并获得所有的马。\n问：给定每一匹马的能力值，裁判C能否通过重新调整马匹参赛顺序而获得胜利？\n输入描述\n第一行输入一个整数n (1 &lt;= n &lt;= 100)。\n第二行输入n个整数，代表选手A所有马匹的能力值。\n第二行输入n个整数，代表选手B所有马匹的能力值。\n输出描述\n如果可以平局的话，则输出\"YES\"，否则输出\"NO\"。\n输入样例\n123456741 2 7 83 4 5 621 23 4\n\n输出样例\n12YESNO\n\n\n\n思路\n第一步先A，B的所有马能力从小到大排序\n目标是合理分配尽可能平局，我们有几种配对思路：\n①强对强\n②弱对弱\n③强对弱\n贪心：平局的条件是控制对局结果使A，B各赢一半，而我们最有可能能直接掌控局面的是强对弱的搭配（强对强和弱对弱双方势均力敌，而强对弱往往强方会赢\n接下来就是如何匹配强和弱了\n考虑A的第1匹马，我应该派B的哪匹马应战才最有利呢？\n派B的第n匹马  太浪费了\n派B的第1匹马  可能打不过\n结论是  派第匹最好\n类似的A的第  匹马匹配B的第 ​ 匹马是最优的情况\n平局要求A的前一半均输于B的后一半，而A的后一半均赢B的前一半\n也许你会问为什么一定是这样一一对应，下面证明这种匹配即为最优解\n只需证明倘若当前方案无法平局，其他方案也无法一定平局\n\n\n\n\n代码\n12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 110;int n;int a[N], b[N];int main(){\twhile (cin &gt;&gt; n)\t{\t\tcin &gt;&gt; n;\t\t\t\tfor (int i = 1; i &lt;= n; i ++ ) cin &gt;&gt; a[i];\t\tfor (int i = 1; i &lt;= n; i ++ ) cin &gt;&gt; b[i];\t\t\t\tif (n % 2)\t\t{\t\t\tputs(\"NO\");\t\t\tcontinue;\t\t}\t\t\t\t// 排序\t\tsort(a + 1, a + 1 + n);\t\tsort(b + 1, b + 1 + n);\t\t\t\tbool fact = true;\t\tfor (int i = 1; i &lt;= n / 2; i ++ )\t\t\tif (a[i] &gt;= b[i + n / 2] || b[i] &gt;= a[i + n / 2])\t\t\t{\t\t\t\tfact = false;\t\t\t\tbreak;\t\t\t}\t\t\t\t\tif (fact) puts(\"YES\");\t\telse puts(\"NO\");\t}\t\treturn 0;}\n\n\n\n\n\n5.放鸡蛋\n题目\n题目描述\n把M个同样的鸡蛋放在N个同样的篮子里，允许有的篮子空着不放，求共有多少种不同的放法？（用K表示）5，1，1和1，5，1 是同一种分法。请写一个程序来输出每一种放记鸡蛋的方法。\n输入格式\n第一行是一个数字t，表示有t个测试用例接下来的t行每一行有两个数字M和N，中间用空格隔开，表示有M个鸡蛋和N个篮子\n输出格式\n对于每一个用例，输出它不同的放法，每种放法占一行，格式是每个篮子的鸡蛋数量，按照数量降序排序。不同方法之间也是 降序排序。\n样例输入\n1217 3\n\n样例输出\n12345678700610520511430421331322\n\n\n\n思路\ndfs，明确几个约束：\n\n序列降序排序 得记住上一个放的数的值\n允许不放鸡蛋枚举到0\n\n代码\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int N = 1e3 + 10;int t;int n, m; // n个鸡蛋m个篮子int q[N]; // 存储方案void dfs(int cnt, int la, int u){\t// 已经放好了cnt个篮子,上一个放的是la,当前放了u个鸡蛋\tif (cnt == m)\t{\t\tif (u == n)\t\t{            // 合法放完了,直接输出\t\t\tfor (int i = 0; i &lt; m; i ++ ) cout &lt;&lt; q[i];\t\t\tcout &lt;&lt; endl;\t\t}\t\treturn;\t}\t    // 后面放的不能比前面多\tfor (int i = la; i &gt;= 0; i -- )\t\tif (u + i &lt;= n)\t\t{\t\t\tq[cnt] = i;\t\t\tdfs(cnt + 1, i, u + i);\t\t}}int main(){\tcin &gt;&gt; t;\t\twhile (t -- )\t{\t\tcin &gt;&gt; n &gt;&gt; m;\t\t        // 已经放好了0个篮子,上一个放的是n(使第一项从n开始枚举),已经放了0个鸡蛋\t\tdfs(0, n, 0);\t\t\t\tcout &lt;&lt; endl;\t}\t\treturn 0;}\n\n\n\n类似题目洛谷P10483 小猫爬山\n洛谷P2404 自然数的拆分问题\n洛谷P1120 小木棍\n","slug":"数据结构与算法-week2","date":"2024-10-05T11:16:27.000Z","categories_index":"算法","tags_index":"链表,队列,字符串,贪心,dfs","author_index":"Jerry"},{"id":"52118211d89fd171196f274fe2d94d19","title":"html+css+js笔记","content":"1.html1.1 文件结构html 文件以树的形式组织\n1.2 基本标签\n&lt;html&gt;: 根节点\n\n&lt;head&gt;: 规定文档相关的配置信息：标题、引用的文档样式、脚本\n\n设置 icon:\n\n\n\n\n\n\n\n&lt;body&gt;: 表示文档的内容，document.body 树形可以访问 body 元素脚本\n\n&lt;title&gt;: 定义文档标题，显示在浏览器标题栏上，只能包含文本，包含的任何标签的会被忽略\n\n\n\n\n&lt;meta&gt;: 剩余的均用 &lt;meta&gt; 标签表示\n常见属性：\n\ncharset\nname\n\n\n\n1.3 注释格式如下：\n123&lt;!-- this is a 注释--&gt;\n\n\n\n1.4 文本标签绝大部分标签本质都是一样的，只不过有些标签是根据大多数用户的需求进行了标准化\n\n&lt;div&gt;: 通用型流行内容容器，块状元素\n&lt;span&gt;: 行内元素\n\n比较：\n\n\n&lt;div&gt;自带前后回车&lt;span&gt;不带回车\n\n&lt;h1&gt;~&lt;h6&gt;:六级标题\n\n&lt;p&gt;: 文本的一段，块级元素，自带回车\n其实就是加了前后行间距，自动过滤空格和回车\n\n\n\n\n&lt;pre&gt;：预定义格式文本，不会过滤换行和空格\n\n&gt;用&amp;gt\n&lt;用&amp;lt\n空格用nbsp\n\n\n&lt;br&gt;：在文本生成一个换行，在写诗和写地址的时候有用\n\n&lt;hr&gt; ：表示段落及元素之间主题转换（一个故事中场景的改变或一个章节主题的改变） 在可视化浏览器表现为水平线\n\n&lt;i&gt; ：区分普通文本的一系列文本，一般为斜体\n\n&lt;b&gt; ：加粗，替代方案是用 CSS font-weight 来创建粗体文字\n\n&lt;del&gt;： 表示一些被从文档中删除的文字内容，一般用于显示修改记录或者源代码差异的情况\n\n&lt;ins&gt;： 与 del 相反，表示加入的内容\n\n\n1.5 图片\nsrc：路径/地址\n\nalt：对文本表述，非强制性，当图片无法正常显示时展示\n\n\nheight：高度，单位是 CSS 像素\n\nwidth：宽度，单位是 CSS 像素\n\n\n1.6 音频与视频\n&lt;audio&gt;：嵌入音频，src 表示地址\n\n1234567891011&lt;!--自动播放--&gt;&lt;audio src=\"/audios/林俊杰 - 愿与愁.mp3\" autoplay&gt;\"/audios/愿与愁.mp3\"无法播放&lt;/audio&gt;&lt;!--手动播放--&gt;&lt;audio controls src=\"/audios/林俊杰 - 愿与愁.mp3\"&gt;\"/audios/愿与愁.mp3\"无法播放&lt;/audio&gt;&lt;!--一次存多个音源，前面不行就放后面的--&gt;&lt;audio controls&gt;        &lt;source src=\"/audios/林俊杰 - 愿与愁.mp3\" type=\"audio/mpeg\"&gt;\"/audios/愿与愁.mp3\"无法播放&lt;/source&gt;        &lt;source src=\"/audios/郭采洁 - 你在不在.mp3\" type=\"audio/mpeg\"&gt;\"/audios/你在不在.mp3\"无法播放&lt;/source&gt;&lt;/audio&gt;\n\n\n\n\n&lt;video&gt;：嵌入视频，src 表示地址\n\n1234567891011&lt;!--自动播放--&gt;&lt;video src=\"/videos/video1.mp4\" autoplay&gt;&lt;/video&gt;&lt;!--手动播放--&gt;&lt;video controls src=\"/videos/video1.mp4\"&gt;&lt;/video&gt;&lt;!--一次存好几个视频--&gt;&lt;video controls&gt;        &lt;source src=\"/videos/video1.mp4\" type=\"video/mp4\"&gt;\"/videos/video1.mp4\"无法播放&lt;/source&gt;        &lt;source src=\"/videos/video2.mp4\" type=\"video/mp4\"&gt;\"/videos/video2.mp4\"无法播放&lt;/source&gt;&lt;/video&gt;\n\n\n\n\n\n1.7 超链接&lt;a&gt;&lt;/a&gt;\n格式：\n12345678910111213&lt;!--href+地址,标签中间放显示内容--&gt;&lt;a href=\"https://www.baidu.com\"&gt;百度&lt;/a&gt;&lt;!--相对路径--&gt;&lt;a href=\"/about.html\"&gt;About&lt;/a&gt;&lt;!--内嵌其他标签--&gt;&lt;!--内嵌图片，则整个图片就是一个超链接--&gt;&lt;!--target的作用是新开一个页面，没有target的话就是在原界面跳转--&gt;&lt;a href=\"\\about.html\" target=\"_blank\"&gt;        &lt;img height=\"800\" width=\"1650\" src=\"/images/picture2.jpg\" alt=\"about\"&gt;        关于&lt;/a&gt;\n\n\n\n\n1.8 表单\n&lt;input&gt;\ntype=\"text\"：基础的单行文字\ntype=\"number\"：只能是数字\ntype=\"email\"：合法的邮箱地址\ntype=\"password\"：密码\ntype=\"radio\"：选择，同样 name 的 radio 只能选一个，要多选就得每个都命不同的名字\n\n\n\n\n\n12345678&lt;form&gt;        &lt;!--表头--&gt;        &lt;label for=\"username\"&gt;用户名&lt;/label&gt;        &lt;!--把输入数据绑定进来--&gt;        &lt;input type=\"text\" name=\"username\" id=\"username\"&gt;        &lt;!--加一个按钮--&gt;        &lt;button type=\"submit\"&gt;提交&lt;/button&gt;&lt;/form&gt;\n\n\n\n\n\n+action=””实现超链接功能  获取数据并跳转到下一个网页\n\n常见属性：\n\nname：名称\nid：唯一 id\nmaxlength：最大长度\nminlength：最小长度\nrequired：是否必填\nplaceholder：背景填充\n\n\n&lt;textarea&gt;：多行的框框，一个块区域\n\n\n\n\n\n&lt;select&gt;+&lt;option&gt;：选择框+选项\n\n\n\n默认选项： selected value\n1.9 列表&lt;ul&gt;&lt;li&gt;无序\n\n\n\n\n\n\n\n\n\n&lt;ol&gt;&lt;li&gt;有序\n1.\n2.\n3.\n1.10 表格\n\n\n\n1.11 语义标签\n\n\n\n1.12 特殊符号\n\n\n2.CSS理解 html 与 css：\nhtml 是素颜，css 是化妆\n一个是底层，一个是装饰\n2.1 样式定义方式\n行内样式表：只对当前标签作用\n\n加多一个 style 属性，里面存储所有样式\n12345678&lt;!--设置宽度--&gt;&lt;!--html--&gt;&lt;img width=\"300\" src=\"\"&gt;&lt;!--css--&gt;&lt;img src=\"\" style=\"width: 300px;\"&gt;&lt;!--一些例子--&gt;&lt;div style=\"width: 100%;height: 100%;background-color: black;\"&gt;&lt;/div&gt;\n\n\n内部样式表：对同个页面多个元素产生影响\n\n单独写一个 style 标签，对某些标签的样式专门定义一个类\n\n对于同一种标签，用 class 来区别不同种样式，class 可以叠加\n\n\n\n\n\n外部样式表\n\n在一般的网站制作过程，有很多样式不可能在一个界面完成设计，需要写在额外的文件中，这时候在&lt;head&gt;标签底下就要用&lt;link&gt;方式引入进来以使用样式\n\n\n注：style 里面的注释只能用/* */\n2.2 选择器\n标签选择器\n\n123456&lt;!--选择所有div标签--&gt;div {    width: 200px;    height: 200px;    backfground-color: gray;}\n\n\n\n\nID 选择器\n\n对 id 属性选择\n123456&lt;!--选择ID为rect-1的标签--&gt;#rect-1 {    width: 200px;    height: 200px;    background-color: red;}\n\n\n\n\n类选择器\n\n对 class 属性选择\n123456&lt;!--选择所有rectangle类的标签--&gt;.rectangle {    width: 200px;    height: 200px;    background-color: green; }\n\n\n\n\n伪类选择器\n\n就是一个后缀，在前面几类的基础上加上一些特殊情况\n→如当鼠标悬停在这时、长按时……\n\n\n\n\n\n复合选择器\n\n\n\n\n\n\n通配符选择器\n\n\n\n\n\n\n伪元素选择器\n\n\n\n\n\n2.3 颜色\n\n\n\n2.4 文本\ntext-align：center,left,right,justify \n\n定义行内元素（如文字）如何相对其块状父元素对齐，text-align 不控制块元素自己对齐，只控制他的行内内容的对齐\n\n子标签继承父标签的对齐方式\n\n\n\n\n\nline-height：设置多行元素的空间量，如多行文本的间距，对于块级元素，指定元素行盒（line boxes）的最小高度，对于非替代的 inline 元素，它用于计算行盒（line box）的高度\n补充：长度单位\n\n\n\n\n\n\ntips：通过设置行高可以竖直居中\n\nletter-space：文本字符的间距\n\n\n\n\n\ntext-indent：块元素首行文本内容之前的缩进量\n\n\n\n\ntext-decoration：设置修饰线外观→在 MDN 上直接搜用法就行\ntext-decoration-line\ntext-decoration-style\ntext-decoration-thickness\n\n\n\n删除一条链接的任何修饰：\n\n\n\n\n\ntext-shadow：为文字添加阴影\n\n4 个参数：坐标（2）+阴影模糊半径+颜色\n\n模糊半径越大字体模糊\n\n坐标方向：\n\n\n\n\n\n\n\n\n\n\n2.5 字体\nfont-size：设置字体大小\nfont-weight：设置字体粗细程度\n\n\n\nfont-family：设置字体类型（楷体、黑体、宋体……）\n\n通过一个有先后顺序的，由字体名或者字体族名组成的列表来为选定的元素设置字体，属性之间用逗号隔开，浏览器会选择列表中第一个该计算机上有安装的字体，或者是通过@font-face 指定的可以直接下载的字体\n\nserif→带衬线字体      sans-serif→不带衬线字体\n\n\n\n\nmonospace→等宽字体\n\ncursive→草书字体\n\nfantasy→艺术字体\n\n\n\nfont-style：选择 font-family 底下的 italic 或 oblique 样式\n\n\n\n2.6 背景\nbackground-color：设置背景颜色，置于最底层\n\nbackground-image：设置背景图像\n\n渐变色 linear-gradient（rgba（0， 0， 255， 0.5）， rgba（255， 255， 0， 0.5））\n\n多个图：中间用逗号隔开，越靠前的优先级越高\n123background-image: url('./images/p1.ipg),url('./images/p2.jpg');/* p1优先级高于p2 */backgrount-size: 100px 200px, 200px 100px;\n\n\n\n\n\n\n\nbackground-size：设置背景图片大小\n\n50% 50% 横纵比例\n200px 300px 大小\n\n\nbackground-repeat：设置背景图像沿水平轴、竖直轴，两个轴重复，或者根本不重复\n\nbackground-position：设置背景图片初始位置\n\ncenter     …px\n\n\nbackground-attachment：设置背景图像的位置实在视口内固定或者随着区块滚动\n\n\n2.7 边框可以四条边独立设置样式\n\nborder-style：CSS 简写属性，用来设定元素所有边框的样式\n\n12345678910111213141516/* Apply to all four sides */border-style: dashed;/* horizontal | vertical */border-style: dotted solid;/* top | horizontal | bottom */border-style: hidden double dashed;/* top | right | bottom | left */border-style: none solid dotted dashed;/* Global values */border-style: inherit;border-style: initial;border-style: unset;\n\n\nborder-width：设置盒子模型的边框宽度\nborder-color：设置元素四个边框颜色的快捷属性\nborder-top-color\nborder-right-color\nborder-bottom-color\nborder-left-color\n\n\nborder-radius：设置矩形边框 4 个角的样式\n可以用来设置非常神奇的样式\n\n\nborder-collapse：设置相邻格子是否共享边框，设置在&lt;table&gt;标签里\n\n2.8 元素展示格式\ndisplay: \nblock: &lt;div&gt;\n独占一行\nwidth、height、margin（外边距）、padding（内边距）均可控制\nwidth 默认 100%\n\n\ninline: &lt;span&gt;\n可以共占一行\nwidth 与 height 无效，水平方向的 margin 与 padding 有效，竖直方向的 margin 与 padding 无效\nwidth 默认为本身内容宽度\n\n\ninline-block: &lt;img&gt;\n可以共占一行\nwidth、height、margin、padding 均可控制\nwidth 默认为本身内容宽度\n\n\n\n\nwhite-space：设置如何处理元素中的空白\nnowrap：不自动换行，多的直接溢出\npre：保留文本里的换行（原格式）？\n\n\ntext-overflow：设置文本溢出文本框部分的处理\nhidden：截断，不显示\nellipsis：超出部分用省略号代替\n\n\noverflow：设置内容显示是否有滚轮，分为 overflow-x，overflow-y\nhidden：不显示滚轮\nauto：自动设置滚轮\n\n\n\n2.9 内外边距边距：最小距离\n\nmargin：外边距\n\n直接设定 4 个值（上右下左）\n\n分别指明 4 个方向：\n\nmargin-top\nmargin-right\nmargin-bottom\nmargin-left  \n\n\n可取值：\n\nlength：固定值→xxpx\npercentage：相对于包含块的宽度的百分比\nauto：让浏览器自己选\n\n\n\n\n\npadding：内边距，用法和 padding 同\n\n元素最后大小=初始大小+内边距大小+边界大小\nwidth=content+padding+border\n\n\n\n2.10 盒子模型\nBox-sizing:\n设置元素总宽度和总高度，锁死\ncontent-box：默认值，设置 border，padding 均会增加元素的宽高\nborder-box：设置 border 和 padding 不会改变元素的宽高，而是挤占内容区域\n\n\n\n2.11 位置position：指定一个元素在文档中的定位方式\n\n2.11 浮动float: \nclear: \n2.12 flex 布局设置弹性项目如何增大或缩小以适应其弹性容器中可用的空间→更好布局各个模块\n\n主轴→    交叉轴↓    优先沿主轴方向，摆满后沿交叉轴方向延伸\n\n\n\n\n\n\n没有 flex\n\n\n加了 flex\n\n\n\n可见 flex 可以改变内部元素排列方式\n当内部元素总宽度/长度大于当前元素时，会自动压缩\n\n\nflex-direction: \n\nrow：默认摆放方式，从左往右，从上往下\nrow-reverse：从右往左，从上往下\ncolumn：从上往下，从左往右\ncolumn：从下往上，从左往右\n\n\nflex-wrap:\n\n设置换行\nnowrap：默认，不换行\nwrap：换行，第一行在上\nwrap-reverse：换行，第一行在下\n\n\nflex-flow:\n\ndirection 和 wrap 一起设置\n\n\n\n\njustify-content: \n\n定义了浏览器之间如何分配顺着弹性容器主轴的元素之间及其周围的空前\n\nflex-start：默认，左对齐\n\n\nflex-end：右对齐\n\n\ncenter：居中\n\n\n\nspace-between：左右两端对齐，紧贴边缘\n\n\nspace-around：每行均匀分配元素，相邻元素距离相同，每行第一个元素到行首的距离和每行最后一个元素到行尾的距离会是相邻元素之间距离的一半\n\n\nspace-evenly：flex 项都沿着主轴均匀分布在指定的对齐容器中。相邻 flex 项之间的间距，主轴起始位置到第一个 flex 项的间距，主轴结束位置到最后一个 flex 项的间距，都完全一样\n\n\n\n\nalign-items:\n\n\n将所有直接子节点上的 align-self 值设置为一个组。 align-self 属性设置项目在其包含块中在交叉轴方向上的对齐方式。\n\nflex-start：元素向交叉轴起点对齐。\n\n\n\nflex-end：元素向交叉轴终点对齐。\n\n\n\n\n\ncenter：元素在侧轴居中，沿交叉轴居中。\n\nstretch：当没有设置高度时，弹性元素被在侧轴方向被拉伸到与容器相同的高度或宽度。\n\n\n\n\n\nalign-content: \n\n设置了浏览器如何沿着弹性盒子布局的纵轴和网格布局的主轴在内容项之间和周围分配空间。\n\nalign-items行在整个容器内均匀分布； 有行距，align-content没行距\n\nflex-start：所有行从垂直轴起点开始填充。第一行的垂直轴起点边和容器的垂直轴起点边对齐。接下来的每一行紧跟前一行。\n\nflex-end：所有行从垂直轴末尾开始填充。最后一行的垂直轴终点和容器的垂直轴终点对齐。同时所有后续行与前一个对齐。\n\ncenter：所有行朝向容器的中心填充。每行互相紧挨，相对于容器居中对齐。容器的垂直轴起点边和第一行的距离相等于容器的垂直轴终点边和最后一行的距离。\n\nstretch：拉伸所有行来填满剩余空间。剩余空间平均地分配给每一行。\n\norder\n\n\n决定元素展示顺序，值越小越靠前\n\nflex-grow:\n\n设置 flex 项主尺寸的 flex 增长系数，默认 0，负值无效\n\nflex-shrink:\n\n指定了 flex 元素的收缩规则。flex 元素仅在默认宽度之和大于容器的时候才会发生收缩，其收缩的大小是依据 flex-shrink 的值，负值无效，默认为 1。\n\nflex-basis:\nwidth 值可以是 &lt;length&gt;； 该值也可以是一个相对于其父弹性盒容器主轴尺寸的百分数 。负值是不被允许的。默认为 auto。\n\n\n\n2.13 响应式布局适配不同设备的布局\n\nmedia 查询\n\n在特定屏幕宽度应用特定 CSS→在不同环境写不同 CSS\n\n设备大小：\nxs:极小\nsm:小\nmd:中等\nlg:大\nxl:极大\n\n\n可以用 bootstrap 包来设计响应式布局，class 里面多叠几个就行\n\n3.JS绝大部分在前端执行，后端 JS 要用 NodeJS，有更多选择方案所以一般不用 JS\n3.1 调用和执行方式\n使用方式：\n在 html 页面任意位置上加上&lt;script type=\"module\"&gt;&lt;/script&gt;标签\n\n\n\n（ECMAScript6 写法）\n\n直接引入文件：\n1&lt;script type=\"module\" src=\"/static/js/index.js\"&gt;&lt;/script&gt;\n\n将所需的代码通过import关键字引入到当前作用域\n\n执行顺序：\n\n类似于 html 和 css，从上向下\n\n事件驱动执行\n\n\n\nhtml、css、js 之间的关系：\n\ncss 控制 html\njs 控制 html 和 css\n为了方便开发和维护，尽量按照上述顺序写代码，不要再 html 中调用 js 里面的函数\n\n\n\n3.2 变量与运算符\nlet和const：let 变量，const 常量，不需要声明类型，js 里面类型是动态的\n\n变量类型：\n\nnumber：数值\n\nstring：字符串，不区分单双引号；每一位都是只读变量，不允许改变，要改变只能创建新的字符串来存，例如：\n123let s1 = \"acwing\";let s2 = s1.substr(0, 1) + 'x' + s1.substr(2); // s2 = \"axwing\"\n\n\n\nboolean：布尔\n\nobject：对象，类似于 C++里面的指针，例如：[1, 2, 3]，{name: \"lgj\", age: 18}\n12345678910111213141516171819let d = {    name: 'jerry', // 前面的name可加可不加引号    age: 18,};console.log(d[\"name\"]); // map输出，必须加引号，同时这里允许动态变值console.log(d.name); // 点输出let key = \"name\";console.log(d[key]); // 允许console.log(d.key); // 不允许// 字典允许动态添加属性d.school = \"sysu\"; // 添加school属性// 遍历字典for (let key in d) {    console.log(d[key]);}\n\nundefined：未定义的变量\n\n输出变量类型：\n\nconsole.log(typeof x)\n\n\n\n3.3 输入与输出\n输入：\n从 html 与用户的交互中输入信息，例如通过input，textarea等标签获取用户键盘输入，通过click，hover等事件获取用户鼠标输入\n通过ajax与websocket从服务器端获取输入\n标准输入\n\n\n输出：\n调试用console.log，输出到浏览器控制台\n改变当前页面的 html 和 css\n通过ajax与websocket将结果返回到服务器\n\n\n格式化字符串：\n\n\n\n\n\n3.4 判断和循环语句同 C++\n3.5 对象一个字典，类似于 map，由key:value对构成\nkey均为字符串，但是可以不加引号\nvalue可以是字符串、数组、数值、函数…………\n\nvalue可以是变量，数组，对象，函数等\n函数中的this用来引用该函数的拥有者\n\n例如：\n12345678let person = {    name: \"yxc\";      age: 18,    money: 0,    add_money: function (x) {        this.money += x;    }}\n\n对象属性与函数的调用方式：\n\nperson.name、person.add_money(): \n简洁，但是关键字不可动态变化\n\n\nperson[\"name\"]、person[\"add_money\"]()\n繁琐，但是关键字可以动态变化\n\n\n\n3.6 数组\n特殊的对象，元素的变量类型是动态的\n\n如：\n\nlet a = ['lgj', 18, 175, 65]\n&lt;!--code￼15--&gt;\n\n可以通过这种访问方式动态赋值，甚至允许改变元素的类型\n\njs 里面没有下标越界概念，遇到没有定义的位置直接返回undefined，不会报错，甚至允许负下标的存在\n\n数组的长度：最大下标 + 1\n\n\n\n常用api\n\nlength：返回数组长度，注意是属性，不加()\n\npush()：添加元素\n\npop()：弹出元素\n\nsplice(a, b)：删除从 a 开始的 b 个元素\n\nsort()：默认从小到大排序，对整个数组排序\n\n自定义比较函数：array.sort(cmp)函数cmp输入两个比较的元素，返回一个实数\n\n例：\n1234567891011121314151617// 给数组降序排序let a = [5, 3, 2, 4, 1];let main = function() {    console.log(a);        a.sort(function(x, y) {        x = parseInt(x), y = parseInt(y);        return y - x;    });        console.log(a);};export {    main};\n\n\n\n\n\n\n\n\n\n\n\n3.7 函数类型为function，依靠对象实现\n\n定义方式：一共有 3 种\n\n1234567891011121314// 直接定义函数function add (a, b) {    return a + b;};// 声明函数变量let add = function (a, b) {        return a + b;};// 第二种方法的等价写法，如果只有一个参数可以不加括号let add = (a, b) =&gt; {    return a + b;};\n\n\n可以不按照函数的定义格式传入参数，没有传入的参数默认为undefined，由于这样 js 里面应该是不存在函数重载的，太随意了吧\n函数返回值默认是undefined\n\n3.8 类与C++的class类似，但是不存在私有成员\n一般用驼峰命名法，即每个单词首字母大写\n\n定义\n\n123456789101112131415161718192021222324252627class Point {    // 构造函数    constructor(x, y) {        this.x = x;        this.y = y;    }        // 类内函数不用加function关键字    init() {        this.sum = this.x + this.y;    }        toString() {        return `(${this.x}, ${this.y})`;    }}let main = function () {    // 生成类对象    let p = new Point(3, 4);    console.log(p.x, p.y);    console.log(p.toString());}export {    main}\n\n\n继承：用extends关键字\n\n123456789101112clsss ColorPoint extends Point {    constructor(x, y, color) {        // 必须先调用基类构造函数        super(x, y); // 这里的super是一个函数，特指基类的构造函数        this.color = color;    }        // 派生类的成员函数会覆盖基类的成员函数    toString() {        return `${this.color} ${super.toString()}`; // 这里的super代表的是基类对象    }}  \n\n\n静态方法：加static关键字\n和C++类似，属于所有类对象的共有成员\n静态方法不会被类的实例继承，需要通过类名访问\n\n\n\n1234567891011121314151617181920212223class Point {    // 构造函数    constructor(x, y) {        this.x = x;        this.y = y;    }        // 类内函数不用加function关键字    init() {        this.sum = this.x + this.y;    }        static print_class_name() {        console.log(\"Point\");    }}let main = function() {    let p = new Point(3, 4);        console.log(p.print_class_name());     // 错误，静态对象不允许直接访问    console.log(Point.print_class_name()); // 正确，用类名调用静态对象   }\n\n\n静态变量：\n和静态对象类似，和类本身绑定\n\n\n\n1234567891011121314151617class Point {    // 构造函数    constructor(x, y) {        this.x = x;        this.y = y;                Point.cnt ++ ;    }        // 类内函数不用加function关键字    init() {        this.sum = this.x + this.y;    }}// 静态变量定义：在类外Point.cnt = 0;\n\n\n\n3.9 事件js 代码一般通过事件触发，即通过事件实现对 CSS 和 html 的操控\n可以通过addEventListener函数为元素绑定事件的触发函数\n常见的触发函数有：\n\n鼠标\n\nclick：左键点击\ndblclick：左键双击\ncontextmenu：右键点击\nmousedown：鼠标按下，包括左键、滚轮、右键\nevent.button：0 表示左键，1 表示中键，2 表示右键\nevent.clientX：鼠标按下的位置\n其余的属性可以上 MDN 上搜索\n\n\nmouseup：鼠标弹起，包括左键、滚轮、右键\nevent.button：同上\n\n\n\n\n键盘\n\nkeydown：某个键是否被按住，事件会连续触发\nevent.code：返回被按住的键\nevent.altKey，event.ctrlKey，event.shiftKey分别表示alt，ctrl，shift是否被按住\n\n\nkeyup：某个键是否被释放\nevent：同上\n\n\nkeypress：紧跟在keydown事件后触发，只有按下字符键时触发\n\n\n\n表单\n\nfocus：聚焦某个元素\nblur：取消聚焦某个元素\nchange：某个元素的内容发生改变\n\n\n窗口\n\n需要作用到window元素上\nresize：窗口大小发生变化\nscroll：滚动指定的元素\nload：元素加载完成\n\n\n\n3.10 常用库3.10.1 jQuery让 js 更方便联系前端元素\n\n使用方式\n\n在元素中添加：\n\n按 jQuery 官网提示下载\n\n\n选择器\n\n$(selector) ，例如：\n123$('div');$('.big-div');$('div &gt; p');\n\n\n\n\n\nselector类似于 CSS 选择器\n\n事件\n\n$(selector).on(event, func)绑定事件，例如：\n123$('div').on('click', function(e) {    console.log(\"click div\");});\n\n$(selector).on(event, func)解绑事件，例如：\n12345$('div').on('click', function(e) {        console.log(\"click div\");    $('div').off('click');});\n\n当存在多个相同类型的事件触发函数时，可以通过click.name来区分，例如：\n12345$('div').on('click.first', function (e) {    console.log(\"click div\");    $('div').off('click.first');});\n\n在事件触发的函数中的return false等价于同时执行：\n\ne.stopPropagation()：阻止事件向上传递\ne.preventDefault()：阻止事件的默认行为\n\n\n\n\n元素的隐藏、展现\n\n$A.hide()：隐藏，参数表示消失时间\n$A.show()：展现，参数表示出现时间\n$A.fadeOut()：慢慢消失，参数表示消失时间\n$A.fadeIn()：慢慢出现，参数表示出现时间 \n\n\n元素的添加、删除\n\n$('&lt;div class=\"mydiv\"&gt;&lt;span&gt;Hello World&lt;/span&gt;&lt;/div&gt;')构造一个jQuery对象\n$A.append($B)：将$B添加到$A的末尾\n$A.prepend($B)：将$B添加到$A的前面\n$A.remove()：删除元素$A\n$A.empty()：清空元素$A的所有儿子\n\n\n对类的操作\n\n$A.addClass(class_name)：添加某个类\n$A.removeClass(class_name)：删除某个类\n$A.hasClass(class_name)：判断某个类是否存在\n\n\n对 CSS 操作\n\n$(\"div\").css(\"background-color\")：获取某个 CSS 的属性\n\n$(\"div\").css(\"background-color\",\"yellow\")：设置某个 CSS 的属性\n\n同时设置多个 CSS 的属性：\n12345$('div').css({    width: \"200px\",    height: \"200px\",    \"background-color\": \"orange\",});\n\n\n\n对标签属性的操作\n\n\n$('div').attr('id')：获取属性\n$('div').attr('id', 'ID')：设置属性\n\n对 HTML 内容、文本的操作\n\n不需要背每个标签该用哪种，用到的时候 Google 或者百度即可。\n$A.html()：获取、修改 HTML 内容\n$A.text()：获取、修改文本信息\n$A.val()：获取、修改文本的值，常用在&lt;input&gt;上\n\n查找\n\n$(selector).parent(filter)：查找父元素\n$(selector).parents(filter)：查找所有祖先元素\n$(selector).children(filter)：在子元素中查找\n$(selector).find(filter)：在所有后代元素中查找\n\n\najax\n\n\n从服务器端获取JSON数据，不用刷新界面\n\nGET 方法：\n\n12345678910$.ajax({    url: url, // 后端链接    type: \"GET\",    data: {    },    dataType: \"json\",    success: function (resp) {    },});\n\n\nPOST 方法：\n\n12345678910$.ajax({    url: url,    type: \"POST\",    data: {    },    dataType: \"json\",    success: function (resp) {    },});\n\n3.10.2 setTimeout与setInterval返回number型数据，代表当前函数的唯一ID\n1setTimeout(func, delay)`：`delay`毫秒之后执行函数`func()\n\nclearTimeout()：关闭定时器，如：\n12345let timeout_id = setTimeout(() =&gt; {    console.log(\"Hello World!\");}, 2000);    // 2秒之后输出\"Hello World!\"clearTimeout(timeout_id);     // 清除定时器\n\nsetInterval(func, delay)：每隔delay毫秒执行func()，第一次在第delay毫秒执行\nclearInterval()：关闭周期执行的函数，如：\n12345let interval_id = setInterval(() =&gt; {    console.log(\"Hello World!\");}, 2000);    // 每隔2秒输出一次\"Hello World!\"clearInterval(interval_id);    // 清除周期执行的函数\n\n3.10.3 requestAnimationFramerequestAnimationFrame(func):\n在下次浏览器刷新(重新渲染之前)执行一次，通胀会用递归写法使其每秒执行60次func函数\n1234567let step = (timestamp) =&gt; {  // 每帧将div的宽度增加1像素    let div = document.querySelector('div');    div.style.width = div.clientWidth + 1 + 'px';    requestAnimationFrame(step);};requestAnimationFrame(step);\n\n与setTimeout和setInterval的区别：\n\nrequestAnimationFrame渲染动画的效果更好，性能更佳。\n\n该函数可以保证每两次调用之间的时间间隔相同，但setTimeout与setInterval不能保证这点。setTmeout两次调用之间的间隔包含回调函数的执行时间；setInterval只能保证按固定时间间隔将回调函数压入栈中，但具体的执行时间间隔仍然受回调函数的执行时间影响。\nsetTimeout：\n\n\nsetInterval:\n\n\n当页面在后台时，因为页面不再渲染，因此requestAnimationFrame不再执行。但setTimeout与setInterval函数会继续执行。\n\ncancelAnimationFrame：停止requestAnimationFrame\n\n\n3.10.4 Map与Set\nMap：保存键值对,不能排序\n\n用for...of或者forEach可以按插入顺序遍历\n\n// for...of\nfor (let [key, value] of map) {\n    console.log(key, value);\n}\n\n// forEach\nmap.forEach(function(value, key) {\n    console.log(key, value);\n}) \n&lt;!--code￼33--&gt;\n\n\n\n\n\n3.10.7 日期返回值为整数的API，数值为1970-1-1 00:00:00 UTC（世界标准时间）到某个时刻所经过的毫秒数：\n\nDate.now()：返回现在时刻。\nDate.parse(\"2022-04-15T15:30:00.000+08:00\")：返回北京时间2022年4月15日 15:30:00的时刻。\n\n与Date对象的实例相关的API：\n\nnew Date()：返回现在时刻。\nnew Date(\"2022-04-15T15:30:00.000+08:00\")：返回北京时间2022年4月15日 15:30:00的时刻。\n两个Date对象实例的差值为毫秒数\ngetDay()：返回星期，0表示星期日，1-6表示星期一至星期六\ngetDate()：返回日，数值为1-31\ngetMonth()：返回月，数值为0-11\ngetFullYear()：返回年份\ngetHours()：返回小时\ngetMinutes()：返回分钟\ngetSeconds()：返回秒\ngetMilliseconds()：返回毫秒\n\n3.10.8 WebSocket与服务器建立全双工连接。\n常用API：\n\nnew WebSocket('ws://``localhost:8080``');：建立ws连接。\nsend()：向服务器端发送一个字符串。一般用JSON将传入的对象序列化为字符串。\nonopen：类似于onclick，当连接建立时触发。\nonmessage：当从服务器端接收到消息时触发。\nclose()：关闭连接。\nonclose：当连接关闭后触发。\n\n","slug":"html-css-js","date":"2024-09-30T09:19:16.000Z","categories_index":"前端","tags_index":"html,css,js","author_index":"Jerry"},{"id":"d6ffd179ab68b0daa56addeeaeb71166","title":"GPT获取sso信息出错","content":"尝试登陆GPT账号发现报错rt\n\n\n解决\n在网址的“auth”中加个0，改成https://auth0.openai.com//authorize?client这种形式再登录。\n\n\n正常登录\n","slug":"GPT获取sso信息出错","date":"2024-09-30T08:43:11.000Z","categories_index":"","tags_index":"GPT","author_index":"Jerry"},{"id":"bbe13304b560081099040d9e49fec292","title":"初级实训作业1-贪吃蛇","content":"\n\n\n\n\n\n\n\n\nQt实现，为避免雷同，展示大致的思路及部分效果图~\n其实之前已经写过一个贪吃蛇小游戏网站了，可惜当时重心放在后端的匹配系统和贪吃蛇bot的代码运行上，前端做的稍微简陋了一点\n这次恰好利用Qt，把整体游戏界面做的更丰满一些o(￣▽￣)ブ\n1.安装Qt参考教程\n2.创建项目\n\n\n\n\n\n\n构建系统—qmake\nDetails—Base class—QWidget\n\n\n\n\n新项目创建完毕\n\n\n运行效果—白框框\n3.整体设计蛇身 + 地图 + 道具掉落（种类多设计一点） +生命值 + 计分板 + 难度调节器（调节速度）\n设计：初始设定：积分 0\n道具：\n①food：长度+1，积分+10\n②wall：障碍物 碰到停止\n③咬到自己：死\n基本流程：①调节难度，开始游戏\n②读取键盘输入\n②处理方向更新\n③处理蛇身更新\n④处理道具更新\n⑤判断是否死亡\n⑥全体布局确定，渲染地图\n最初版效果图如下：\n\n\n4.Code(1)基本API待更新……\n","slug":"初级实训大作业1-贪吃蛇","date":"2024-09-29T15:18:32.000Z","categories_index":"小游戏","tags_index":"Qt","author_index":"Jerry"},{"id":"e9c911dbfeb3b82e631b7a70a15f2cf2","title":"动态规划--区间DP","content":"区间DP引入区间DP主要用于解决涉及区间分割与合并的动态规划问题。\n在这类问题中，我们往往会关注一段区间上的某种性质（方案数、组合数、最大值……）\n而区间DP的状态转移则是枚举区间划分的最后一步，把区间一分为二，利用小的区间求得的值求得整个区间的值\n由于大区间依赖小区间，所以长度都是从小遍历到大\n一起到例题中看看吧~\n例题洛谷P1880 石子合并\n题目\n题目描述\n在一个圆形操场的四周摆放  堆石子，现要将石子有次序地合并成一堆，规定每次只能选相邻的  堆合并成新的一堆，并将新的一堆的石子数，记为该次合并的得分。\n试设计出一个算法,计算出将  堆石子合并成  堆的最小得分和最大得分。\n输入\n数据的第  行是正整数 ，表示有  堆石子。\n第  行有  个整数，第  个整数  表示第  堆石子的个数。\n，\n输出\n输出共  行，第  行为最小得分，第  行为最大得分。\n样例输入 #1\n1244 5 9 4\n\n样例输出 #1\n124354\n\n\n\n分析\n\n\n\n代码\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//区间dp#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N = 210, INF = 0x3f3f3f3f;int dp[N][N];int n;int a[N];int main(){\tcin &gt;&gt; n;\tfor (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i];\tfor (int i = 1; i &lt;= n; i++) a[i + n] = a[i];\tfor (int i = 1; i &lt;= 2 * n; i++) a[i] += a[i - 1];\tfor (int len = 2; len &lt;= n; len++)\t\tfor (int i = 1; i + len - 1 &lt; 2 * n; i++)\t\t{\t\t\tint j = i + len - 1;\t\t\tdp[i][j] = INF;\t\t\tfor (int k = i; k + 1 &lt;= j; k++)\t\t\t\tdp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] + a[j] - a[i - 1]);\t\t}\tint mint = INF;\tfor (int i = 1; i &lt;= n; i++) mint = min(mint, dp[i][i + n - 1]);\tcout &lt;&lt; mint &lt;&lt; endl;\tfor (int len = 2; len &lt;= n; len++)\t\tfor (int i = 1; i + len - 1 &lt; 2 * n; i++)\t\t{\t\t\tint j = i + len - 1;\t\t\tdp[i][j] = 0;\t\t\tfor (int k = i; k + 1 &lt;= j; k++)\t\t\t\tdp[i][j] = max(dp[i][j], dp[i][k] + dp[k + 1][j] + a[j] - a[i - 1]);\t\t}\tint maxt = 0;\tfor (int i = 1; i &lt;= n; i++) maxt = max(maxt, dp[i][i + n - 1]);\tcout &lt;&lt; maxt &lt;&lt; endl;\treturn 0;}\n\n\n\n洛谷P4342  Polygon\n题目\n题目描述\n多边形是一个玩家在一个有  个顶点的多边形上的游戏，如图所示，其中 ＝ 。每个顶点用整数标记，每个边用符号 （加）或符号  （乘积）标记。\n\n第一步，删除其中一条边。随后每一步： \n选择一条边连接的两个顶点  和  ，用边上的运算符计算  和  得到的结果来替换这两个顶点。 \n游戏结束时，只有一个顶点，没有多余的边。\n如图所示，玩家先移除编号为3的边。之后，玩家选择计算编号为1的边，然后计算编号为4的边，最后，计算编号为2的边。结果是0。\n\n（翻译者友情提示：这里每条边的运算符旁边的数字为边的编号，不拿来计算）\n编写一个程序，给定一个多边形，计算最高可能的分数。\n输入\n输入描述一个有  个顶点的多边形，它包含两行。第一行是数字  ，为总边数。\n第二行描述这个多边形，一共有  个读入，每两个读入中第一个是字符，第二个是数字。\n第一个字符为第一条边的计算符号(  代表相加， 代表相乘)，第二个代表顶点上的数字。首尾相连。 \n\n对于任何一系列的操作，顶点数字都在  的范围内。\n输出\n第一行，输出最高的分数。在第二行，它必须写出所有可能的被清除后的边仍能得到最高得分的列表，必须严格递增。\n样例输入 #1\n124t -7 t 4 x 2 x 5\n\n样例输出 #1\n12331 2\n\n\n\n\n题解\n思路\n\n\n\n\n\n\n代码\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;const int N = 110, INF = 32768;int n;char c[N];int a[N];int f[N][N], g[N][N];int main(){    cin &gt;&gt; n;        // 破环成链    for (int i = 1; i &lt;= n; i ++ )    {        cin &gt;&gt; c[i] &gt;&gt; a[i];        c[i + n] = c[i];        a[i + n] = a[i];    }        for (int len = 1; len &lt;= n; len ++ )        for (int i = 1; i + len - 1 &lt;= 2 * n; i ++ )        {            int j = i + len - 1;                        // 只有一个数,不用操作            if (len == 1)            {                f[i][j] = g[i][j] = a[i];                continue;            }                        // 枚举分界点            f[i][j] = -INF, g[i][j] = INF; // 初始化            for (int k = i; k &lt; j; k ++ )            {                char op = c[k + 1]; // 取操作符                int lm = g[i][k], lM = f[i][k], rm = g[k + 1][j], rM = f[k + 1][j];                                if (op == 't') f[i][j] = max(f[i][j], lM + rM), g[i][j] = min(g[i][j], lm + rm);                else                 {                    int m = lm * rm, M = lm * rm;                                        m = min(m, lm * rM);                    m = min(m, lM * rm);                    m = min(m, lM * rM);                                        M = max(M, lm * rM);                    M = max(M, lM * rm);                    M = max(M, lM * rM);                                        f[i][j] = max(f[i][j], M), g[i][j] = min(g[i][j], m);                }            }                    }            int res = -INF; // 最大值    vector&lt;int&gt; segs; // 方案    for (int i = 1; i &lt;= n; i ++ ) res = max(res, f[i][i + n - 1]);    for (int i = 1; i &lt;= n; i ++ )        if (f[i][i + n - 1] == res)            segs.push_back(i);            cout &lt;&lt; res &lt;&lt; endl;    for (auto i : segs)        cout &lt;&lt; i &lt;&lt; \" \";        return 0;}\n\n\n\n洛谷P10956 金字塔\n题目\n题目描述\n虽然探索金字塔是极其老套的剧情，但是有一队探险家还是到了某金字塔脚下。\n经过多年的研究，科学家对这座金字塔的内部结构已经有所了解。\n首先，金字塔由若干房间组成，房间之间连有通道。\n如果把房间看作节点，通道看作边的话，整个金字塔呈现一个有根树结构，节点的子树之间有序，金字塔有唯一的一个入口通向树根。\n并且，每个房间的墙壁都涂有若干种颜色的一种。\n探险队员打算进一步了解金字塔的结构，为此，他们使用了一种特殊设计的机器人。\n这种机器人会从入口进入金字塔，之后对金字塔进行深度优先遍历。\n机器人每进入一个房间（无论是第一次进入还是返回），都会记录这个房间的颜色。\n最后，机器人会从入口退出金字塔。\n显然，机器人会访问每个房间至少一次，并且穿越每条通道恰好两次（两个方向各一次）， 然后，机器人会得到一个颜色序列。\n但是，探险队员发现这个颜色序列并不能唯一确定金字塔的结构。\n现在他们想请你帮助他们计算，对于一个给定的颜色序列，有多少种可能的结构会得到这个序列。\n因为结果可能会非常大，你只需要输出答案对 取模之后的值。\n输入\n输入仅一行，包含一个字符串 ，长度不超过 ，表示机器人得到的颜色序列。\n输出\n输出一个整数表示答案。\n样例输入 #1\n1ABABABA\n\n样例输出 #1\n15\n\n\n\n\n题解\n思路\n\n\n代码\n123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;using namespace std;typedef long long LL;const int mod = 1e9, N = 310;int n;string s;int dp[N][N];int main(){    cin &gt;&gt; s;    int n = s.size();        if (n % 2 == 0) puts(\"0\"); // 无解    else     {        for (int len = 1; len &lt;= n; len ++ )            for (int i = 0; i + len - 1 &lt; n; i ++ )            {                int j = i + len - 1;                if (len == 1) dp[i][j] = 1; // 边界                else if (s[i] == s[j]) // 两端相等才有解                    // 找符合条件的                    for (int k = i; k &lt; j; k ++ )                        if (s[k] == s[i])                            dp[i][j] = (dp[i][j] + (LL)dp[i][k] * dp[k + 1][j - 1]) % mod;            }                    cout &lt;&lt; dp[0][n - 1] &lt;&lt; endl;    }        return 0;}\n\n\n\n结语区间DP其实思路基本大体都相似，基本上推出来子状态到当前状态的状态更新就都能做了\n","slug":"动态规划-区间DP","date":"2024-09-26T05:12:32.000Z","categories_index":"算法","tags_index":"动态规划,区间DP","author_index":"Jerry"},{"id":"62555a6f14b066c1f526e128e3c72f4d","title":"动态规划--线性DP","content":"线性DP引入线性DP就是指状态的转移具有线性递推关系，每个状态只依赖之前的状态，按照线性顺序一步步递推下去。\n正如之前在背包问题中所写到的，仍旧可以用状态表示和状态计算来解决\n\n\n\n\n\n\n\n注意\n对于不同类的动态规划问题,核心解题步骤均为状态表示+状态计算,而如何在不同的题型中均捕捉到状态表示和状态计算的方法,才是需要通过刷题慢慢理解体会的\n\n\n例题洛谷B3637 最长上升子序列\n题目\n题目描述\n这是一个简单的动规板子题。\n给出一个由  个不超过  的正整数组成的序列。请输出这个序列的最长上升子序列的长度。\n最长上升子序列是指，从原序列中按顺序取出一些数字排在一起，这些数字是逐渐增大的。\n输入\n第一行，一个整数 ，表示序列长度。\n第二行有  个整数，表示这个序列。\n输出格式\n一个整数表示答案。\n样例输入 #1\n1261 2 4 1 3 4\n\n样例输出 #1\n14\n\n\n\n分析\n线性DP的经典问题\n状态表示：   前  项且以第  项结尾的上升子序列的最大长度\n状态计算： 子状态：枚举倒数第二项 且\n复杂度：\n\n代码\n1234567891011121314151617181920212223242526272829303132// LIS#include &lt;iostream&gt;using namespace std;const int N = 5e3 + 10;int n;int a[N], dp[N];int main(){\tcin &gt;&gt; n;\t\tfor (int i = 1; i &lt;= n; i ++ ) cin &gt;&gt; a[i];\t\t// 开始DP\tfor (int i = 1; i &lt;= n; i ++ )\t{\t\tdp[i] = 1;\t\tfor (int j = 1; j &lt; i; j ++ )\t\t\tif (a[j] &lt; a[i])\t\t\t\tdp[i] = max(dp[i], dp[j] + 1);\t}\t\tint res = 0;\tfor (int i = 1; i &lt;= n; i ++ ) res = max(res, dp[i]);\t\tcout &lt;&lt; res &lt;&lt; endl;        return 0;}\n\n\n\n\n\n优化\n容易发现,对于每个,都需要从1开始一一枚举来确定要接在哪个后面\n显然每一轮都浪费了前面得到的一些’信息’\n这样浪费’信息’的行为,在动态规划中往往会有一定的优化方案,把’信息’充分利用起来\n举个例子\n序列: 3    1      4      2      8       6       5\n对前面两项3,1,可视作2个独立的长度为1的上升子序列,\n当遍历到4时，我们会发现对于4，既可以接到3上又可以接到1上，两者都是长度为1的上升子序列\n容易发现，能够接到3上的一定能够接到1上  长度为1的上升子序列，保留1即可，1比3适配性更强\n做了这样的处理之后，我们在遍历到4时，就不用再枚举3了\n所以我们需要做的就是实时维护这样一个前面  项里面各个长度的最优上升子序列的末尾元素，以判断第  项能否接上去\n这步的复杂度仍旧为 ，需要优化，能否用二分优化？\n判断这样一个最优上升子序列末尾元素的值的序列的性质，形如下图：\n\n\n设  代表长度为  的上升子序列的末尾项，假设我们  最优情况下接到长度为 的上升子序列后面\n则必有  ，否则接到  后面更长\n则  必定是一个单调不减的序列  具有二段性，可以二分\n由此，该步复杂度降低至 ，整体复杂度优化到 \n\n代码\n12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int N = 5e3 + 10;int n;int a[N], q[N];int len = 0;int main(){\t\tcin &gt;&gt; n;        memset(q, 0x3f, sizeof q);    q[0] = 0;        for (int i = 1; i &lt;= n; i ++ ) cin &gt;&gt; a[i];        for (int i = 1; i &lt;= n; i ++ )    {    \t// 开始二分\t\tint l = 0, r = len;\t\tint mid;\t\t\t\twhile (l &lt; r)\t\t{\t\t\t// 找到可以接的最大值\t\t\tmid = l + r + 1&gt;&gt; 1;\t\t\tif (q[mid] &lt; a[i]) l = mid;\t\t\telse r = mid - 1;\t\t}\t\t\t\t// 接在长度为l的后面,维护q\t\tq[l + 1] = min(q[l + 1], a[i]);\t\tlen = max(len, l + 1);    }        cout &lt;&lt; len &lt;&lt; endl;        return 0;}\n\n\n\n\n\n思考\n读者看到这里也许会有疑问,为何状态表示方式要这样定?其他的表示方式不行码?\n正如背包问题中对第i件物品有选与不选之分,为何我这里状态表示里第  项必须选呢?\n状态表示:  前  项的里面最长的上升子序列长度\n这样子在动态规划完之后就不需要再定一个  一个个取  来求最大值了,  直接就是答案\n但方便的状态表示带来的代价是难以甚至无法进行状态计算\n在上述状态中,由于的可能选可能没有选,我们根本就找不到子状态来进行状态转移\n 状态表示和状态转移是相互制约的,一个易就会有一个难,当找不到转移方程时,不妨尝试换一种表示方法\n洛谷P1439 【模板】最长公共子序列\n题目\n题目描述\n给出  的两个排列  和  ，求它们的最长公共子序列。\n输入\n第一行是一个数 。\n接下来两行，每行为  个数，为自然数 ​ 的一个排列。\n\n输出\n一个数，即最长公共子序列的长度。\n样例输入 #1\n1235 3 2 1 4 51 2 3 4 5\n\n样例输出 #1\n13\n\n\n\n仍旧是子序列问题,经过前一道题的尝试之后,思考一下这道题要如何进行状态表示和状态计算吧~\n分析\n状态表示: 的前项,的前项的最长公共子序列长度\n状态计算: 子节点包含于选不选不选选选选不选不选\n注意:这里只是包含,各个状态之间囊括的集合可能存在交集,但是并集一定是全集,不影响正确性\n且 一定会包含于 和中,故可以舍去\n复杂度:\n\n代码\n12345678910111213141516171819202122232425262728293031323334// LCS#include &lt;iostream&gt;using namespace std;const int N = 1e5 + 10;int n;int a[N], b[N];int dp[N][N]; // 爆了int main(){\t\tios::sync_with_stdio(false);\tcin.tie(0);\tcout.tie(0);\t\tcin &gt;&gt; n;\t\tfor (int i = 1; i &lt;= n; i ++ ) cin &gt;&gt; a[i];\tfor (int i = 1; i &lt;= n; i ++ ) cin &gt;&gt; b[i];\t\tfor (int i = 1; i &lt;= n; i ++ )\t\tfor (int j = 1; j &lt;= n; j ++ )\t\t{\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);\t\t\tif (a[i] == b[j])\t\t\t\tdp[i][j] = max(dp[i][j], dp[i - 1][j - 1] + 1);\t\t} \t\t\tcout &lt;&lt; dp[n][n] &lt;&lt; endl;\t\treturn 0;}\n\n\n\n嗯?等等! ? hhh 说好的模板呢\n显然这题用朴素的公共子序列方法时间复杂度肯定是过不去的,至少需要优化到\n想不出.jpg 看到的优化做法,恰好也是哎,要是能拿来用就好了! \n\n\n优化\n假设两个序列分别为\n\n\n容易发现最长公共子序列为 \n做这样的处理,把  的元素进行变换，第  项映射为 ,即\n\n\n\n\n\n变换之后序列为\n\n\n最长公共子序列变为了\n 容易发现，变换之后的公共子序列均为  的上升子序列\n由此，问题便转化为了求变换后的  的最长上升子序列，在上一题的优化做法中可以把复杂度优化至\n\n代码\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// LCS → LIS#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int N = 1e5 + 10;int n;int a[N], b[N], c[N];int q[N];int main(){\t\tios::sync_with_stdio(false);\tcin.tie(0);\tcout.tie(0);\t\tcin &gt;&gt; n;\t\tfor (int i = 1; i &lt;= n; i ++ ) cin &gt;&gt; a[i];\tfor (int i = 1; i &lt;= n; i ++ ) cin &gt;&gt; b[i];\t\t// c[i]存储映射关系\tfor (int i = 1; i &lt;= n; i ++ ) c[a[i]] = i;\t\t// b[i]进行变换\tfor (int i = 1; i &lt;= n; i ++ ) b[i] = c[b[i]];\t\t// 开始求最长上升子序列\tmemset(q, 0x3f, sizeof q);\tq[0] = 0;\tint len = 0;\tfor (int i = 1; i &lt;= n; i ++ )\t{\t\tint l = 0, r = len;\t\tint mid;\t\twhile (l &lt; r)\t\t{\t\t\tmid = l + r + 1 &gt;&gt; 1;\t\t\tif (q[mid] &lt; b[i]) l = mid;\t\t\telse r = mid - 1;\t\t}\t\t\t\tq[l + 1] = min(q[l + 1], b[i]);\t\tlen = max(len, l + 1);\t}\t\t\tcout &lt;&lt; len &lt;&lt; endl;\t\treturn 0;}\n\n\n\n既然已经解决了  和  问题，来试试二者的结合吧~\n洛谷 LCIS\n\n再来看看其它情景下的线性DP\n洛谷P1216 数字三角形 Number Triangles\n题目\n题目描述\n观察下面的数字金字塔。\n写一个程序来查找从最高点到底部任意处结束的路径，使路径经过数字的和最大。每一步可以走到左下方的点也可以到达右下方的点。\n\n在上面的样例中，从  的路径产生了最大权值。\n输入\n第一个行一个正整数  ,表示行的数目。\n后面每行为这个数字金字塔特定行包含的整数。\n，所有输入在  范围内\n输出\n单独的一行,包含那个可能得到的最大的和。\n样例输入 #1\n123456573 88 1 02 7 4 44 5 2 6 5\n\n样例输出 #1\n130\n\n\n\n题解\n思路\n直接把三角形拉直，想象为一个正方形被沿对角线对半分了\n状态表示： 走到第  行第  列的最大值\n状态计算：\n代码\n12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;using namespace std;const int N = 1e3 + 10,INF=1e9;int dp[N][N];//存最大值int a[N][N];//存三角形int n;int main(){\tcin &gt;&gt; n;\tfor (int i = 1; i &lt;= n; i++)\t\tfor (int j = 1; j &lt;= i; j++) cin &gt;&gt; a[i][j];\t//初始化边界\tfor (int i = 1; i &lt;= n; i++)\t\tfor (int j = 1; j &lt;= n + 1; j++)\tdp[i][j] = -INF;\tdp[1][1] = a[1][1];\tfor (int i = 2; i &lt;= n; i++)\t\tfor (int j = 1; j &lt;= n; j++) dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - 1]) + a[i][j];\tint maxn = 0;\tfor (int i = 1; i &lt;= n; i++) maxn = max(maxn, dp[n][i]);\tcout &lt;&lt; maxn;\treturn 0;}\n\n\n\n\n进阶一点的数字三角形\n洛谷P1006 传纸条\n题目\n题目描述\n小渊和小轩是好朋友也是同班同学，他们在一起总有谈不完的话题。一次素质拓展活动中，班上同学安排坐成一个  行  列的矩阵，而小渊和小轩被安排在矩阵对角线的两端，因此，他们就无法直接交谈了。幸运的是，他们可以通过传纸条来进行交流。纸条要经由许多同学传到对方手里，小渊坐在矩阵的左上角，坐标 ，小轩坐在矩阵的右下角，坐标 。从小渊传到小轩的纸条只可以向下或者向右传递，从小轩传给小渊的纸条只可以向上或者向左传递。\n在活动进行中，小渊希望给小轩传递一张纸条，同时希望小轩给他回复。班里每个同学都可以帮他们传递，但只会帮他们一次，也就是说如果此人在小渊递给小轩纸条的时候帮忙，那么在小轩递给小渊的时候就不会再帮忙。反之亦然。\n还有一件事情需要注意，全班每个同学愿意帮忙的好感度有高有低（注意：小渊和小轩的好心程度没有定义，输入时用  表示），可以用一个  内的自然数来表示，数越大表示越好心。小渊和小轩希望尽可能找好心程度高的同学来帮忙传纸条，即找到来回两条传递路径，使得这两条路径上同学的好心程度之和最大。现在，请你帮助小渊和小轩找到这样的两条路径。\n输入\n第一行有两个用空格隔开的整数  和 ，表示班里有  行  列。\n接下来的  行是一个  的矩阵，矩阵中第  行  列的整数表示坐在第  行  列的学生的好心程度。每行的 ​ 个整数之间用空格隔开。\n\n输出\n输出文件共一行一个整数，表示来回两条路上参与传递纸条的学生的好心程度之和的最大值。\n样例输入 #1\n12343 30 3 92 8 55 7 0\n\n样例输出 #1\n134\n\n\n\n","slug":"动态规划-线性DP","date":"2024-09-26T05:12:20.000Z","categories_index":"算法","tags_index":"动态规划,线性DP","author_index":"Jerry"},{"id":"398687178e2ec3c1a9498d5422c75757","title":"动态规划--背包问题","content":"🎮 背包问题欢迎来到 动态规划的冒险世界！在这趟旅途中，你将化身为一位勇敢的冒险者，面临一个经典而深邃的挑战：如何在有限的资源下获得最大的收益。每一关都充满了挑战，但只要你步步为营，掌握算法精髓，最终你会成为背包问题的 算法大师。准备好了吗？Let’s Go!\n\n前言背包问题是动态规划最经典的问题之一，在这里，我们初步学会如何使用动态规划解决问题\n绝大部分情况下，动态规划步骤如下：\n状态表示：集合描述\n状态计算：划分集合，把当前状态转化为子集状态（注意不重不漏）进而写出状态转移方程\n接下来，让我们到题目中理解这两步的含义吧！\n分类1.01背包\n种物品，体积背包\n物品体积，价值（最多只能用一次）​\n\n洛谷P1048 采药\n洛谷P1060 开心的金明\n2.完全背包\n种物品，体积背包\n物品体积，价值（无限用）\n\n洛谷P1616 疯狂的采药\n洛谷P1853 投资的最大效益\n3.多重背包\n种物品，体积背包\n物品体积，价值（每种最多选个）​\n\n洛谷P1776 宝物筛选\n4.分组背包\n组物品，体积背包\n组内每件物品体积价值每组物品种最多选个\n\n洛谷P1757 通天之分组背包\n洛谷P5322 排兵布阵\n求背包装得下的情况下的最大总价值\n讲解1.01背包\n种物品，体积背包\n物品体积，价值（最多只能用一次）\n\n思路：状态表示：前种物品花费体积得到的最大价值\n状态计算：第种物品选不选\n求最大价值：状态转移方程\n理解：从第种物品一件一件往后选，每一步都求所有体积下的最优解\n全局最优解一定会从前面的某个局部最优解转移过来\n例题：洛谷P1048 采药\n\n题目\n题目描述\n辰辰是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题。医师把他带到一个到处都是草药的山洞里对他说：“孩子，这个山洞里有一些不同的草药，采每一株都需要一些时间，每一株也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。”\n如果你是辰辰，你能完成这个任务吗？\n输入\n第一行有  个整数 （）和 （），用一个空格隔开， 代表总共能够用来采药的时间， 代表山洞里的草药的数目。\n接下来的  行每行包括两个在  到  之间（包括  和 ）的整数，分别表示采摘某株草药的时间和这株草药的价值。\n输出\n输出在规定的时间内可以采到的草药的最大总价值。\n样例输入\n123470 371 10069 11 2\n\n样例输出 \n13\n\n\n\n思路\n翻译题目\n总时间背包体积\n采每种药的时间物品体积\n\n状态表示：前种物品花费体积得到的最大价值\n状态计算：第种物品选不选\n求最大价值：状态转移方程\n\n代码\n1234567891011121314151617181920212223242526272829303132333435363738// 01背包// 状态表示 dp[i][j] 前i种j体积最大价值// 状态计算 dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - v[i]] + w[i])#include &lt;iostream&gt;using namespace std;const int N = 110, M = 1010;int n, V;int dp[N][M];int v[N], w[N]; // 我这里按照自己习惯定义的变量,可能和题目符号有些出入int main (){    cin &gt;&gt; V &gt;&gt; n;        for (int i = 1; i &lt;= n; i ++ )        cin &gt;&gt; v[i] &gt;&gt; w[i];        // 开始动态规划,从前往后一个一个挑    for (int i = 1; i &lt;= n; i ++ )         for (int j = 0; j &lt;= V; j ++ )        {            // 选到第i种,花费j体积            // 第i件没得选, 放不下            if (j &lt; v[i]) dp[i][j] = dp[i - 1][j];                        // 第i件有选或不选的权利            else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - v[i]] + w[i]);\t\t}        // 输出答案    cout &lt;&lt; dp[n][V] &lt;&lt; endl;        return 0;}\n\n\n\n优化还没完！还能再优化！🤭\n观察上面代码，我们发现在挑到第件物品时，我们只会用到第层的数据，而不会用到更前面的数据\n故可以把直接压缩到遍历到第种物品时，在第层的基础上更新到第层\n对于体积的直接保留原本的\n注意为了避免第层更新用的数据已经被更新过，这里体积需要从大到小枚举，读者可以自行体会\n\n代码\n12345678910111213141516171819202122232425// 01背包1维#include &lt;iostream&gt;using namespace std;const int N = 110, M = 1010;int n, V;int dp[M];int v[N], w[N]; int main (){\tios::sync_with_stdio(false);\tcin.tie(0);\tcout.tie(0);        cin &gt;&gt; V &gt;&gt; n;    for (int i = 1; i &lt;= n; i ++ )        cin &gt;&gt; v[i] &gt;&gt; w[i];        for (int i = 1; i &lt;= n; i ++ )         for (int j = V; j &gt;= v[i]; j -- ) // 从大到小枚举,小于v[i]的更新不了        \tdp[j] = max(dp[j], dp[j - v[i]] + w[i]);        cout &lt;&lt; dp[V] &lt;&lt; endl;    return 0;}\n\n\n\n2.完全背包\n种物品，体积背包\n物品体积，价值（无限用）\n\n思路：模仿背包的思路，按照以下步骤\n状态表示：前种花体积的最大价值\n状态计算：背包的子状态是第种选没选完全背包可以无限选，子状态是第种选了个​\n转移方程：\n\n每一层都这样枚举，总体复杂度显然过于复杂了，需要进一步优化转移方程\n类似上面的，\n对比可得\n\n​\n如此一来便化简了许多\n优化：再考虑优化到维：\n第层需要用到第层和第层的数据，这不恰好是体积从小到大枚举得到的效果？\n体积从小到大枚举，第层枚举到时已经被更新为了而仍保留，符合题意\n所以和背包一样，这里也能压缩掉一维，只需体积从小到大枚举即可\n例题：洛谷P1616 疯狂的采药\n\n题目\n题目描述\nLiYuxiang 是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题。医师把他带到一个到处都是草药的山洞里对他说：“孩子，这个山洞里有一些不同种类的草药，采每一种都需要一些时间，每一种也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。”\n如果你是 LiYuxiang，你能完成这个任务吗？\n此题和原题的不同点：\n. 每种草药可以无限制地疯狂采摘。\n. 药的种类眼花缭乱，采药时间好长好长啊！师傅等得菊花都谢了！\n输入\n输入第一行有两个整数，分别代表总共能够用来采药的时间  和代表山洞里的草药的数目 。\n第  到第  行，每行两个整数，第  行的整数  分别表示采摘第  种草药的时间和该草药的价值。\n输出\n输出一行，这一行只包含一个整数，表示在规定的时间内，可以采到的草药的最大总价值。\n样例输入\n123470 371 10069 11 2\n\n样例输出\n1140\n\n\n\n\n代码\n12345678910111213141516171819202122232425// 完全背包1维#include &lt;iostream&gt;using namespace std;const int N = 10010, M = 1e7+10;int n, V;long long int dp[M];long long  v[N], w[N]; int main (){\tios::sync_with_stdio(false);\tcin.tie(0);\tcout.tie(0);        cin &gt;&gt; V &gt;&gt; n;    for (int i = 1; i &lt;= n; i ++ )        cin &gt;&gt; v[i] &gt;&gt; w[i];        for (int i = 1; i &lt;= n; i ++ )         for (int j = v[i]; j &lt;= V; j ++ )        \tdp[j] = max(dp[j], dp[j - v[i]] + w[i]);        cout &lt;&lt; dp[V] &lt;&lt; endl;    return 0;}\n\n\n\n3.多重背包\n种物品，体积背包\n物品体积，价值（每种最多选个）​\n\n思路：状态表示前种花体积的最大价值\n状态计算子状态：第种选了个\n转移方程\n\n\n总体复杂度当非常大时需要优化\n关键是从到枚举第种选了个效率太低了\n\n优化：优化思路：把第个物品用二进制拆成多种组合个个个 \n将每种物品的个单独看作一个物品\n则任意或\n进而再转化为背包问题这样对于每种物品最多只需要讨论个选与不选复杂度优化到\n思考为何这里不能用完全背包类似的优化思路\n例题：洛谷P1776 宝物筛选\n\n题目\n题目描述\n终于，破解了千年的难题。小 FF 找到了王室的宝物室，里面堆满了无数价值连城的宝物。\n这下小 FF 可发财了，嘎嘎。但是这里的宝物实在是太多了，小 FF 的采集车似乎装不下那么多宝物。看来小 FF 只能含泪舍弃其中的一部分宝物了。\n小 FF 对洞穴里的宝物进行了整理，他发现每样宝物都有一件或者多件。他粗略估算了下每样宝物的价值，之后开始了宝物筛选工作：小 FF 有一个最大载重为  的采集车，洞穴里总共有  种宝物，每种宝物的价值为 ，重量为 ，每种宝物有  件。小 FF 希望在采集车不超载的前提下，选择一些宝物装进采集车，使得它们的价值和最大。\n输入格式\n第一行为一个整数  和 ，分别表示宝物种数和采集车的最大载重。\n接下来  行每行三个整数 ​​。\n，，\n输出格式\n输出仅一个整数，表示在采集车不超载的情况下收集的宝物的最大价值。\n样例输入\n123454 203 9 35 9 19 4 28 1 3\n\n样例输出\n147\n\n\n\n\n代码\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 多重背包问题#include &lt;iostream&gt;using namespace std;const int N = 1e5 + 10, M = 4e4 + 10;int n, V;int dp[N];int v[N], w[N];int main(){    ios::sync_with_stdio(false);    cin.tie(0);    cout.tie(0);        cin &gt;&gt; n &gt;&gt; V;        int cnt = 1; // 存储拆分后的物品种数    int v1, w1, s1; // 未拆分    for (int i = 1; i &lt;= n; i ++ )    {        cin &gt;&gt; w1 &gt;&gt; v1 &gt;&gt; s1;                // s1拆成1+2+4+8+……        int k = 1;        while (s1 - k &gt; 0)        {            v[cnt] = v1 * k;            w[cnt ++] = w1 * k;            s1 -= k;            k *= 2;        }                // 拆剩下的        if(s1) v[cnt] = v1 * s1, w[cnt ++] = w1 * s1;\t}        n = cnt - 1;        // 01背包    for (int i = 1; i &lt;= n; i ++ )        for (int j = V; j &gt;= v[i]; j -- )        \tdp[j] = max(dp[j], dp[j - v[i]] + w[i]);        cout &lt;&lt; dp[V] &lt;&lt; endl;        return 0;}\n\n\n\n4.分组背包\n组物品，体积背包\n组内每件物品体积价值每组物品种最多选个​\n\n思路：状态表示前组花费体积的最大值\n状态计算子状态上一组选了哪一个\n状态转移方程\n\n\n优化至一维体积降序枚举略\n例题：洛谷P1757 通天之分组背包\n\n题目\n题目描述\n自  背包问世之后，小 A 对此深感兴趣。一天，小 A 去远游，却发现他的背包不同于  背包，他的物品大致可分为  组，每组中的物品相互冲突，现在，他想知道最大的利用价值是多少。\n输入\n两个数 ，表示一共有  件物品，总重量为 。\n接下来  行，每行  个数 ，表示物品的重量，利用价值，所属组数。\n，，， 在 int 范围内。\n输出\n一个数，最大的利用价值。\n样例输入\n123445 310 10 110 5 150 400 2\n\n样例输出\n110\n\n\n\n\n代码\n123456789101112131415161718192021222324252627282930313233343536373839404142// 1维分组背包#include&lt;iostream&gt;using namespace std;const int N = 1e3 + 10;int dp[N];int n, V;int v[N][N], w[N][N], cnt[N];// cnt[]存每个组的物品数int main(){    ios::sync_with_stdio(false);    cin.tie(0);    cout.tie(0);    \tcin &gt;&gt; V &gt;&gt; n;\tint gm = 0;//存储最大组数    int v1, w1, j;\tfor (int i = 1; i &lt;= n; i ++ )\t{\t\tcin &gt;&gt; v1 &gt;&gt; w1 &gt;&gt; j;\t\tv[j][++ cnt[j]] = v1;\t\tw[j][cnt[j]] = w1;\t\tgm = max(gm, j);\t}    n = gm;    \t//开始动态规划\tfor (int i = 1; i &lt;= n; i ++ )\t\tfor (int j = V; j &gt;= 0; j -- )\t\t\tfor (int k = 0; k &lt;= cnt[i]; k ++ ) // 判断要选该组的哪件物品\t\t\t\tif(v[i][k] &lt;= j)\t\t\t\t\tdp[j] = max(dp[j], dp[j - v[i][k]] + w[i][k]);\tcout &lt;&lt; dp[V] &lt;&lt; endl;\treturn 0;}\n\n\n\n结语以上便是背包问题最基础的类模型，实际上的题目可能会结合上其他算法状态压缩、贪心、树形\n又或是进行变式求方案数多目标\n篇幅有限，笔者就不多赘述，相信凭借各位的聪明才智，一定可以轻松应付​(ง •_•)ง\n\n\n如果文中有任何错误之处，欢迎大家在评论区批评指正！🙏\n\n","slug":"动态规划-背包问题","date":"2024-09-26T05:12:09.000Z","categories_index":"算法","tags_index":"动态规划,背包问题","author_index":"Jerry"},{"id":"c3878449dce899402d13b06cc735de00","title":"博弈论--NIM游戏","content":"引入先介绍几个概念\n1.公平组合游戏ICG：\n两名玩家交替行动\n在任意时刻，可执行的行动与玩家本身无关（游戏公平性）\n不能行动的玩家输\n\n2.有向图游戏\n给定一个有向无环图，具有唯一的起点，玩家交替的把棋子沿有向边进行移动，每次移动一步，无法移动者输\n任何ICG均可化为有向图游戏\n\n3.先手必胜与先手必败\n在双方均完全理性的情况下，先手不必胜则必败，先手不必败则必胜\n\nNIM游戏：1.介绍NIM 游戏是一种经典的组合博弈，两名玩家轮流从若干堆石子中选择一堆，并从中取走任意数量的石子。无法继续操作的玩家判负。\n2.结论对于  堆石子 \n\n先手必胜态：\n先手必败态：\n\n3.证明：通过数学归纳，从特殊推向一般。\n\n不能操作时，每堆都是 0，\n\n当 ，任意一步操作之后 \n反证：对任意一步操作使 \n若 ，\n设 \n则 \n则 ，但是 ，矛盾！得证。\n\n当 ，一定存在一步操作之后 \n证明：设 ，设  的最高位 1 在第  位。\n则  中必定存在至少一个  的第  位也为 1，且 \n（若第  位均为 0，则所有异或之后得到  的第  位也只能是 0，不合题意）\n所以可以从  中拿走  个石子（上一步证明了此步的合法性），使得 \n故 ，得证。\n\n所以在双方绝对理性的情况下，某一方拿完之后达到了异或值为 0 的情况后，会一直握住这个状态，保证自己必胜。\n\n\n更详细的思路构造过程及证明请看编程之美_1.11 NIM（1）一排石头的游戏在线阅读\nSG函数1. Mex 运算：设  表示一个非负整数集合，定义 mex(S) 为求出不属于集合  的最小非负整数的运算。\n即：且\n2. SG 函数将游戏的所有状态及其转换关系抽象成一张有向无环图。\n定义 终点，\n示例：\n\n\n图中模拟一堆个数为 10 的石子的状态转移图，每次只能拿 2 个或 5 个石子，蓝色字为石子数，红色字为对应状态的 SG 值。\n由图：任何一个非 0 状态都可以到 0，任何一个 0 状态都到不了 0。\n则  时，先手拿完后 ，对手总有办法后手让 ，先手必败。\n 时，先手总有办法拿完使 ，对手怎么拿都使 ，先手必胜。\n性质：\n对一个含多个图的游戏，取每个图起点  的 SG 值 \n则必胜，当 \n必败，当 \n3.证明：类似一般 NIM 游戏。\n\n当 ，没有必胜的起点，则 ，必败。\n\n存在 ，则我先手一定可以走一步到达 ，此时 ，对方先手必败，即我方必胜。\n\n当  时， 不全为 0 的情况，不管怎么走，，必将落入对方先手必胜局面，即我方必败。\n\n\n分类NIM博弈的内容大致就这么多啦~\n来几道题目练练手，看看题目中是怎么变形的。\n基础变形\n洛谷P1247 取火柴游戏\n洛谷P7589 黑白棋 关键在翻译题目，本质就是简单的 NIM 游戏。\n洛谷P5675 取石子游戏      背包DP + 阶梯NIM，代码不难理解，关键是想明白思路，考思维\n阶梯 Nim\n洛谷P3480 KAM-Pebbles   差分数组的阶梯nim\n洛谷P2575 高手过招\n\n\n如果文中有任何错误之处，欢迎大家在评论区批评指正！🙏\n\n","slug":"博弈论-NIM游戏","date":"2024-09-26T05:11:45.000Z","categories_index":"算法","tags_index":"博弈论,NIM游戏,SG函数","author_index":"Jerry"},{"id":"9fc7aaa29955e8777b63cdc5e2f3c111","title":"快速幂","content":"快速幂快速计算\n\n朴素计算 \n\n显然当过大时太慢了\n快速幂计算 思路\n即二进制\n所以\n\n\n\n\n而每次往后只需把平方一下就行\n代码123456789101112131415// 快速幂int qmi(int a, int k, int p){\t// 计算 a^k % p    int res = 1;    while (k)    {        // 判断ci是否为1,如果是就需要乘否则跳过        if (k &amp; 1) res = (long long)(res * a) % p; // 取模的乘法运算        k &gt;&gt;= 1;        a = (long long)(a * a) % p;    }        return res;}\n\n\n\n模板题洛谷P1226 快速幂\n应用求逆元\n逆元 除法的取模运算\n定义：若互质满足\n则称逆元记号，不是\n\n思路如下\n同乘约\n由费马定理\n\n模板题\n洛谷P3811 模意义下的乘法逆元\n结语由此，我们便有了乘除法的取模运算法则\n\n\n","slug":"快速幂","date":"2024-09-26T05:11:31.000Z","categories_index":"算法","tags_index":"快速幂,数论","author_index":"Jerry"},{"id":"40241814551b223b651e15683e69d116","title":"数学--约数","content":"约数1.求约数试除法求所有约数\n枚举\n对存\n代码：\n123456789101112vector&lt;int&gt; get_divisors(int x){    vector&lt;int&gt; res;    for (int i = 1; i &lt;= x / i; i ++ )        if (x % i == 0)        {            res.push_back(i);            if (i != x / i) res.push_back(x / i);        }    sort(res.begin(), res.end());    return res;}\n\n细节：存再排序比较方便\n2.约数个数 + 约数之和对任意自然数均可分解质因数为若干质数之积，即\n\n更新ing……\n","slug":"数学-约数","date":"2024-09-26T05:10:57.000Z","categories_index":"算法","tags_index":"数论,约数","author_index":"Jerry"},{"id":"6390ac85391cd221383c57783115e1e4","title":"数学--质数","content":"质数\n\n\n\n\n\n\n\n\n&gt;1 只包含1和本身两个约数\n1.判断质数试除法，只需枚举即可\n代码：\n12345678bool is_prime(int n){    if (n &lt; 2) return false;    for (int i = 2; i &lt;= n / i; i ++ )        if (x % i == 0)            return false;    return true;}\n\n细节\n①不推荐写要调用函数，太慢\n②不推荐写当太大时有可能溢出\n2.分解质因数最多只含一个的质因子，还是试除法，遇到约数就约掉\n如果约掉了所有的质因子之后仍，则约剩下的数必是质因子，单独处理即可\n代码：\n12345678910111213void divide(int n){    for (int i = 2; i &lt;= n / i; i ++ )        if (n % i == 0)        {            // 约掉所有因子，易证从小到大约掉的因子必是质因子            int s = 0;            while (x % i == 0) x /= i, s ++ ;            cout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; s &lt;&lt; endl; // 输出质因子及其个数        }    if (x &gt; 1) cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; 1 &lt;&lt; endl; // 单独处理最后一个因子    cout &lt;&lt; endl;}\n\n\n\n3.筛质数给一个范围筛掉范围内所有的质数\n朴素筛法思路：\n从枚举，依次筛掉倍数，倍数，倍数，\n例题\n洛谷P5736 【深基7.例2】质数筛 \n埃氏筛法优化：\n只筛掉质数的倍数，如在中枚举到，已经在的时候就被筛了，就跳过不再筛的倍数了\n显然，如果枚举到某个数，在前面没被筛掉则必是质数 \n缺点：仍旧还是有些数被重复筛了，如会被和同时筛掉，效率仍待提高\n线性筛法优化：每个数只会被自己最小质因子筛掉，如在上面只会被筛掉\n伪代码：\n①一定是最小质因子一定是最小质因子\n②一定小于的所有质因子也一定是最小质因子\n③按照此逻辑来决定一个数一个数筛\n代码：\n123456789101112131415int primes[N], cnt;     // primes[]存储所有素数bool st[N];         // st[x]存储x是否被筛掉void get_primes(int n){    for (int i = 2; i &lt;= n; i ++ )    {        if (!st[i]) primes[cnt ++ ] = i;        for (int j = 0; primes[j] &lt;= n / i; j ++ )        {            st[primes[j] * i] = true;            if (i % primes[j] == 0) break;        }    }}\n\n例题\n洛谷P3383 【模板】线性筛素数\n\n\n如果文中有任何错误之处，欢迎大家在评论区批评指正！🙏\n\n","slug":"数学-质数","date":"2024-09-26T05:10:48.000Z","categories_index":"算法","tags_index":"数论,质数","author_index":"Jerry"},{"id":"23e5ccb93b471aba058840eff980504f","title":"图论--最短路","content":"最短路先贴张总体图：\n\n\n最短路问题有以下性质：\n对于边权为正的图，任意两个结点之间的最短路，不会经过重复的结点。\n对于边权为正的图，任意两个结点之间的最短路，不会经过重复的边。\n对于边权为正的图，任意两个结点之间的最短路，任意一条的结点数不会超过  ，边数不会超过  。\n1.单源最短路(1)边权均为正数①朴素Dijkstra算法思路：\ndist[i]存到起点的最短距离（在执行过程更新），st[i]存是否已确定最短距离\n集合S已经确定最短距离的点集（实际上就是st[]为true的点）\n初始化所有点到起点距离均为无穷大，将起点到起点距离设置为0\n找当前所有未定最短距的点中的最近点t，用t更新其他点最短距离，并将t丢进集合S里\n迭代n次，即可确定所有点最短路\n\n证明：下面用数学归纳法证明，所有有边权为非负的情况下，Dijkstra 算法的正确性。\n简单来说，我们要证明的，就是在执行第 1 操作时，取出的一点  是最短的已经被确定，即满足 。\n初始时 ，假设成立。\n接下来用反证法。\n设  为算法中第一个加入  集合时不满足  的点。因为  点一定满足 ，且一定是第一个加入  集合的点，因此  加入  集合前，，如果不存在  的路径，则 ，假设不满足。\n于是一定存在路径 ，其中  为路径上的节点，而  为  的前驱结点（显然 ）。需要注意的是，可能存在  或  可能是空节点。\n因为在结点  加入前的 ，所以在  加入到  集合时，有 ，此时通过反证法，构造出的路径 ，一定有 ，使得  点加入到 。\n下面证明 ，在路径中，假设  点所有边权为负，因此 ，从而  加入  集合后被取出时才会终止。\n因此，Dijkstra 算法是正确的，算法终止时 ​ 完成。\n步骤：下面用一个具体的例子来辅助解释这个过程\n\n初始化  \n\n\n\n\n起点到起点的距离为 0，即 \n\n\n\n\n遍历 dist 数组，找到一个节点，这个节点是：没有确定最短路的节点中距离起点最近的点。\n假设该节点编号为   ，此时就找到了起点到该节点的最短距离，   置为  \n\n\n\n\n\n遍历  所有可以到达的节点 ，如果  大于  加上  的距离\n即 （ 为  的距离） ，则更新 \n\n\n\n\n\n\n\n一直重复上面的步骤直至所有点的最短路均被确定\n\n\n\n\n此时起点到所有点的最短路均被确定\n\n\n\n\n\n注意事项：\n\n复杂度： 遍历  次  遍历  个点找最近点 \n\n稠密图，邻接矩阵存有向图\n\n当前情况需要每个点要求第一次出队的时候就已经确定最短路，所以要求图内不能有负权边 （否则第一次出队可能不是最短路，则当前算法失效）\n\n朴素dijkstra用的比较少\n\n\n伪代码：\n12345678int dist[n],state[n];dist[1] = 0, state[1] = 1;for(i:1 ~ n){    t &lt;- 没有确定最短路径的节点中距离源点最近的点;    state[t] = 1;    更新 dist;}\n\n\n\n代码模板：\n123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;int n;\t\t  // 点数int d[N][N];  // 邻接矩阵存有向图int dist[N];  // 存储1号点到每个点的最短距离bool st[N];   // 存储每个点的最短路是否已经确定// 求1号点到n号点的最短路，如果不存在则返回-1int dijkstra(){    memset(dist, 0x3f, sizeof dist);    dist[1] = 0;    for (int i = 0; i &lt; n - 1; i ++ )    {        int t = -1;     // 在还未确定最短路的点中，寻找距离最小的点        for (int j = 1; j &lt;= n; j ++ )            if (!st[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j]))                t = j;        // 用t更新其他点的距离        for (int j = 1; j &lt;= n; j ++ )            dist[j] = min(dist[j], dist[t] + d[t][j]);        st[t] = true;    }    if (dist[n] == 0x3f3f3f3f) return -1;    return dist[n];}\n\n\n\n②堆优化版Dijkstra算法思路：\n容易发现在朴素Dijkstra算法中，通过枚举来找最近点的操作值得优化，这里采用小根堆来存所有点当前离起点的最短路，堆顶即为最近点，这步操作的复杂度仅为 \n其余仍与朴素Dijkstra一样\n\n注意事项：\n复杂度：\n稀疏图，邻接表存有向图\n\n代码模板：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;typedef pair&lt;int, int&gt; PII;int n;      \t\t\t\t\t\t// 点的数量int h[N], w[N], e[N], ne[N], idx;   // 邻接表存储所有边int dist[N];        \t\t\t\t// 存储所有点到1号点的距离bool st[N];    \t\t\t\t\t \t// 存储每个点的最短距离是否已确定// 初始化邻接表void init(){    memset(h, -1, sizeof h);}// 连接有向边a→bvoid add(int a, int b, int c){    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;}// 求1号点到n号点的最短距离，如果不存在，则返回-1int dijkstra(){    memset(dist, 0x3f, sizeof dist); // 初始化距离为无穷大    dist[1] = 0;    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap; // 小根堆    heap.push({0, 1});      // first存储距离，second存储节点编号    while (heap.size())    {        auto t = heap.top(); // 取出最近点        heap.pop();        int ver = t.second, distance = t.first;        if (st[ver]) continue;        st[ver] = true;        for (int i = h[ver]; i != -1; i = ne[i])        {            int j = e[i];            if (dist[j] &gt; distance + w[i])            {                dist[j] = distance + w[i];                heap.push({dist[j], j});            }        }    }    if (dist[n] == 0x3f3f3f3f) return -1;    return dist[n];}\n\n\n\n！思考：为何Dijkstra只对非负权边有效，能举出例子证明吗？\n例题洛谷P4779 【模板】单源最短路径（标准版）\n洛谷P1144 最短路计数\n洛谷P1948 Telephone Lines S\n\n题目\n题目描述\n多年以后，笨笨长大了，成为了电话线布置师。由于地震使得某市的电话线全部损坏，笨笨是负责接到震中市的负责人。该市周围分布着  根据  顺序编号的废弃的电话线杆，任意两根线杆之间没有电话线连接，一共有  对电话杆可以拉电话线。其他的由于地震使得无法连接。\n第i对电线杆的两个端点分别是  ，，它们的距离为 。数据中每对  只出现一次。编号为  的电话杆已经接入了全国的电话网络，整个市的电话线全都连到了编号  的电话线杆上。也就是说，笨笨的任务仅仅是找一条将  号和  号电线杆连起来的路径，其余的电话杆并不一定要连入电话网络。\n电信公司决定支援灾区免费为此市连接  对由笨笨指定的电话线杆，对于此外的那些电话线，需要为它们付费，总费用决定于其中最长的电话线的长度（每根电话线仅连接一对电话线杆）。如果需要连接的电话线杆不超过  对，那么支出为 。\n请你计算一下，将电话线引导震中市最少需要在电话线上花多少钱？\n输入\n输入文件的第一行包含三个数字 。\n第二行到第  行，每行分别都为三个整数 。\n输出\n一个整数，表示该项工程的最小支出，如果不可能完成则输出 -1。\n样例输入 #1\n123456785 7 11 2 53 1 42 4 83 2 35 2 93 4 74 5 6\n\n样例输出 #1\n14\n\n\n\n\n题解\n思路：\n题目大概意思是这样子，给一个双向图，要找第到的最短路。对于任意一条路径，其费用为第条边的费用，其实就是在找第最短路。\n只需要二分判断某个费用能否满足即可\n大概流程是这样：对于费用，大于  的边边权为  ，代表免费修建的道路条数；其余边权为 ，这样子求出来的最短路其实就是最少免费修建的道路的条数，如果总条数 则满足不了，否则可以满足，判断更小的费用能否满足，直至找到最小的费用\n代码：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117// 第k+1短路// 稀疏图,堆优化dijkstra#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#define x first#define y secondusing namespace std;typedef pair&lt;int, int&gt; PII;const int N = 1e3 + 10, M = 2e4 + 10;int n, m, k;int h[N], ne[M], e[M], w[M], idx;int dist[N];bool st[N];int l, r, mid;void add(int a, int b, int c){\te[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;}bool check_connect(){\tmemset(dist, 0x3f, sizeof dist);\tmemset(st, false, sizeof st);\tpriority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; q;\tq.push({ 0, 1 });\twhile (q.size())\t{\t\tauto t = q.top();\t\tq.pop();\t\tint p = t.y, d = t.x;\t\tif (st[p]) continue;\t\tst[p] = true;\t\tfor (int i = h[p]; ~i; i = ne[i])\t\t{\t\t\tint j = e[i];\t\t\tif (dist[j] &gt; d + w[i])\t\t\t{\t\t\t\tdist[j] = d + w[i];\t\t\t\tq.push({ dist[j], j });\t\t\t}\t\t}\t}\treturn dist[n] &lt; 0x3f3f3f3f &gt;&gt; 1;}bool check(int x){\tmemset(dist, 0x3f, sizeof dist);\tmemset(st, false, sizeof st);\tpriority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; q;\tq.push({ 0, 1 });\twhile (q.size())\t{\t\tauto t = q.top();\t\tq.pop();\t\tint p = t.y, d = t.x;\t\tif (st[p]) continue;\t\tst[p] = true;\t\tfor (int i = h[p]; ~i; i = ne[i])\t\t{\t\t\tint j = e[i], d1 = w[i] &gt; x ? 1 : 0;\t\t\tif (dist[j] &gt; d + d1)\t\t\t{\t\t\t\tdist[j] = d + d1;\t\t\t\tq.push({ dist[j], j });\t\t\t}\t\t}\t}\treturn dist[n] &lt;= k;}int main(){\tcin &gt;&gt; n &gt;&gt; m &gt;&gt; k;\t// 初始化邻接表\tmemset(h, -1, sizeof h);\tfor (int i = 0, a, b, c; i &lt; m; i++)\t{\t\tcin &gt;&gt; a &gt;&gt; b &gt;&gt; c;\t\tadd(a, b, c), add(b, a, c);\t\tr = max(r, c);\t}\t// 先判断是否联通\tif (!check_connect())\t{\t\tputs(\"-1\");\t\treturn 0;\t}\t// 开始二分\twhile (l &lt; r)\t{\t\t// 能满足的最小值\t\tmid = l + r &gt;&gt; 1;\t\tif (check(mid)) r = mid;\t\telse l = mid + 1;\t}\tcout &lt;&lt; l &lt;&lt; endl;\treturn 0;}\n\n\n\n(2)存在负权边①Bellman-Ford算法思路：\n在Dijkstra算法中，每个点第一次出队时最短路已经被确定\n但在存在负权边的情况下，这一性质被改变，故Dijkstra失效\n对于边  ，需要用到松弛操作，松弛操作对应下面的式子：。\n这么做的含义是显然的：我们尝试用 （其中  的路径取最短路）这条路径去更新  点最短路的长度，如果这条路径更优，就进行更新。\nBellman–Ford 算法所做的，就是不断尝试对图上每一条边进行松弛。我们每进行一轮循环，就对图上所有的边都尝试进行一次松弛操作，当一次循环中没有成功的松弛操作时，算法停止。\n每次循环是  的，那么最多会循环多少次呢？\n在最短路存在的情况下，由于一次松弛操作会使最短路的边数至少+1，而最短路的边数最多为 ，因此整个算法最多执行  轮松弛操作。故总时间复杂度为 。\n但还有一种情况，如果从  点出发，抵达一个负环时，松弛操作会无休止地进行下去。注意到前面的论证中已经说明了，对于最短路存在的图，松弛操作最多只会执行  轮，因此如果第  轮循环时仍然存在能松弛的边，说明从  点出发，能够抵达一个负环。\n注意事项：\n复杂度: ​\n用的比较少\n\n代码模板：123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;int n, m;       // n表示点数，m表示边数int dist[N];        // dist[x]存储1到x的最短路距离struct Edge     // 边，a表示出点，b表示入点，w表示边的权重{    int a, b, w;}edges[M];// 求1到n的最短路距离，如果无法从1走到n，则返回-1。int bellman_ford(){    memset(dist, 0x3f, sizeof dist);    dist[1] = 0;    // 如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。    for (int i = 0; i &lt; n; i ++ )    {        for (int j = 0; j &lt; m; j ++ )        {            int a = edges[j].a, b = edges[j].b, w = edges[j].w;            if (dist[b] &gt; dist[a] + w)                dist[b] = dist[a] + w;        }    }    if (dist[n] &gt; 0x3f3f3f3f / 2) return -1;    return dist[n];}\n\n\n\n②SPFA算法思路：很多时候我们并不需要那么多无用的松弛操作。\n很显然，只有上一次被松弛的结点，所连接的边，才有可能引起下一次的松弛操作。\n那么我们用队列来维护「哪些结点可能会引起松弛操作」，就能只访问必要的边了。\nSPFA 也可以用于判断  点是否能抵达一个负环，只需记录最短路经过了多少条边，当经过了至少  条边时，说明 ​ 点可以抵达一个负环。\n注意事项：\n复杂度:一般  ，最多 \n代码短，非负权边的情况一般也能用，但是容易被卡，建议还是在存在负权边时才用  参考文献—「笔记」如何优雅地卡 Spfa\n要求一定不含负环！！！！！\n\n代码模板：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;int n;      \t\t\t\t\t\t\t// 总点数int h[N], w[N], e[N], ne[N], idx;       // 邻接表存储所有边int dist[N];        \t\t\t\t\t// 存储每个点到1号点的最短距离bool st[N];     \t\t\t\t\t\t// 存储每个点是否在队列中void init(){    memset(h, -1, sizeof h);}// 连接a→b的有向边void add(int a,int b, int c){    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;}// 求1号点到n号点的最短路距离，如果从1号点无法走到n号点则返回-1int spfa(){    memset(dist, 0x3f, sizeof dist);    dist[1] = 0;    queue&lt;int&gt; q;    q.push(1);    st[1] = true;    while (q.size())    {        auto t = q.front();        q.pop();        st[t] = false;        for (int i = h[t]; i != -1; i = ne[i])        {            int j = e[i];            if (dist[j] &gt; dist[t] + w[i])            {                dist[j] = dist[t] + w[i];                if (!st[j])     // 如果队列中已存在j，则不需要将j重复插入                {                    q.push(j);                    st[j] = true;                }            }        }    }    if (dist[n] == 0x3f3f3f3f) return -1;    return dist[n];}\n\n\n\n例题：洛谷P1144 最短路计数\n洛谷P3385 【模板】负环\n2.多源最短路Floyd算法思路：就是暴力枚举所有的边，不断更新最短路\n注意事项：\n是用来求任意两个结点之间的最短路的（多源最短路）。\n\n复杂度  ，但是常数小，容易实现（只有三个 for）。\n\n适用于任何图，不管有向无向，边权正负，但是最短路必须存在。（不能有个负环）\n\n\n代码：1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int INF = 0x3f3f3f3f;int d[N][N]; // 邻接矩阵存距离// 初始化void init(){\tfor (int i = 1; i &lt;= n; i ++ )        for (int j = 1; j &lt;= n; j ++ )            if (i == j) d[i][j] = 0;            else d[i][j] = INF;}// 算法结束后，d[a][b]表示a到b的最短距离void floyd(){    for (int k = 1; k &lt;= n; k ++ )        for (int i = 1; i &lt;= n; i ++ )            for (int j = 1; j &lt;= n; j ++ )                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);}\n\n\n\n例题：洛谷P1119 灾后重建\n","slug":"图论-最短路","date":"2024-09-26T05:09:40.000Z","categories_index":"算法","tags_index":"最短路,图论,Dijkstra,SPFA,Bellman-Ford,Floyd","author_index":"Jerry"},{"id":"708fa6adfa46361c793158b58a61f772","title":"bfs","content":"宽度优先搜索\n待整理…………\n模型\nFlood Fill\n多源bfs\n双端队列bfs\n双向广搜\nA*\n","slug":"bfs","date":"2024-09-26T05:09:28.000Z","categories_index":"","tags_index":"","author_index":"Jerry"},{"id":"c0864a7ed82c2e6dd4eb8a34dacd4941","title":"dfs","content":"深度优先搜索\n想了一下dfs还是挺杂的，近期可能暂时整理不完啦，丢几个关键词，后续计划更新\n判断连通性\n剪枝\n\n可行性\n最优性\n估测性-预测未来\n\n迭代加深—早回头\n双向DFS\nIDA*\n","slug":"dfs","date":"2024-09-26T05:09:23.000Z","categories_index":"","tags_index":"","author_index":"Jerry"},{"id":"f897c3d44f1ea027302ceab6694fc628","title":"单调队列与单调栈","content":"\n  .image-grid {\n    display: grid;\n    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); /* 自动适应屏幕宽度 */\n    gap: 10px; /* 图片间距 */\n  }\n  .image-grid img {\n    width: 100%;\n    height: auto; /* 保持图片比例 */\n    border-radius: 8px; /* 图片圆角 */\n    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1); /* 添加阴影效果 */\n  }\n\n\n\n单调栈与单调队列引言单调栈和单调队列，顾名思义，就是在原本的基础上加上单调性的栈和队列。\n它们是为了解决高效获取极值问题而设计的特殊数据结构，核心思想是利用数据的单调性（递增或递减顺序），减少不必要的比较操作，显著提升算法效率。\n在许多问题中，比如滑动窗口最大值、寻找数组中相邻的更大或更小元素，传统方法每一层迭代均遍历之前每个元素来求最值的思路实际上是浪费了之前迭代所得到的’信息’，导致复杂度高达  ，而单调栈和单调队列恰好使得后面的迭代可以用上之前迭代留下来的’信息’，减少不必要的遍历，从而使复杂度优化到 。\n\n单调栈适合用于处理相邻元素的比较，常用于寻找左右两侧的更大或更小值。\n单调队列适合用于连续范围内的极值查询，如滑动窗口问题。\n\n单调栈1.介绍单调栈分为单调递增栈和单调递减栈\n通过在元素入栈时弹出栈顶不符合单调性的元素\n示例：\n\n  \n  \n  \n  \n  \n  \n\n\n\n2.例题洛谷P5788 【模板】单调栈\n题目\n题目描述\n给出项数为  的整数数列 。\n定义函数  代表数列中第  个元素之后第一个大于  的元素的下标，即 。若不存在，则 。\n试求出 。\n输入\n第一行一个正整数 。\n第二行  个正整数 。\n，\n输出\n一行  个整数表示  的值。\n样例输入 #1\n1251 4 2 3 5\n\n样例输出 #1\n12 5 4 5 0\n\n\n\n\n题解\n思路\n对数组两项 \n如果，显然  不可能有机会被用上\n用栈来存有可能被用上的元素，对于不可能被用上的直接丢掉，则栈中任意元素满足  ，是个单调递增栈\n所以只需要从右到左一个个元素遍历\n不断出栈到栈顶元素大小比自己大，此时栈顶元素的下标就是答案，再把当前元素入栈\n每个元素入栈一次出栈一次，复杂度 \n代码\n12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;stack&gt;using namespace std;typedef pair&lt;int, int&gt; PII; // 要多一维存下标const int N = 3e6 + 10;int n;int a[N];stack&lt;PII&gt; stk;int main(){\tios::sync_with_stdio(false);\tcin.tie(0);\tcout.tie(0);\tcin &gt;&gt; n;\tfor (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i];\tfor (int i = n; i &gt;= 1; i--)\t{\t\tPII t = { a[i], i };\t\twhile (!stk.empty() &amp;&amp; stk.top().first &lt;= a[i])\t\t\tstk.pop();\t\t// 没有比自己大的\t\tif (stk.empty()) a[i] = 0;\t\telse a[i] = stk.top().second;\t\tstk.push(t); // 入栈\t}\tfor (int i = 1; i &lt;= n; i++) cout &lt;&lt; a[i] &lt;&lt; \" \";\treturn 0;}\n\n\n\n\n\n进阶一点\n洛谷P2701 巨大的牛棚Big Barn单调队列1. 介绍单调队列分为单调递增队列和单调递减队列\n其基本原理是通过在队列中维护一个单调性的顺序，使得可以在 O(1) 的时间内获取队列的极值。\n在处理滑动窗口问题时，我们通常会维护一个队列，使得队列中元素的顺序始终是单调的。这样，我们可以在每次滑动窗口时，通过简单的队列操作来获取当前窗口的最大或最小值。\n2. 例题洛谷P1886 滑动窗口 /【模板】单调队列\n题目\n题目描述\n有一个长为  的序列 ，以及一个大小为  的窗口。现在这个从左边开始向右滑动，每次滑动一个单位，求出每次滑动后窗口中的最大值和最小值。\n例如，对于序列  以及 ，有如下过程：\nMisplaced \\hline\\def\\arraystretch{1.2} \\begin{array}{|c|c|c|}\\hline \\textsf{窗口位置} &amp; \\textsf{最小值} &amp; \\textsf{最大值} \\ \\hline \\verb![1   3  -1] -3   5   3   6   7 ! &amp; -1 &amp; 3 \\ \\hline \\verb! 1  [3  -1  -3]  5   3   6   7 ! &amp; -3 &amp; 3 \\ \\hline \\verb! 1   3 [-1  -3   5]  3   6   7 ! &amp; -3 &amp; 5 \\ \\hline \\verb! 1   3  -1 [-3   5   3]  6   7 ! &amp; -3 &amp; 5 \\ \\hline \\verb! 1   3  -1  -3  [5   3   6]  7 ! &amp; 3 &amp; 6 \\ \\hline \\verb! 1   3  -1  -3   5  [3   6   7]! &amp; 3 &amp; 7 \\ \\hline \\end{array} \n输入\n输入一共有两行，第一行有两个正整数 。第二行  个整数，表示序列 \n，\n输出\n输出共两行，第一行为每次窗口滑动的最小值第二行为每次窗口滑动的最大值\n样例输入 #1\n128 31 3 -1 -3 5 3 6 7\n\n样例输出 #1\n12-1 -3 -3 -3 3 33 3 5 5 6 7\n\n\n\n\n题解\n思路\n利用单调递减队列来维护当前滑动窗口的最大值。\n\n使用队列存储元素的索引，并在每次新元素进入窗口时，弹出队列中小于当前元素的索引（因为这些元素不会成为最大值）。\n确保队列的头部始终是当前窗口的最大值的索引。\n在每次移动窗口时，移除超出窗口的元素。\n\n最小值类似\n代码\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;const int N = 1e6 + 10;int n, k;int a[N];deque&lt;int&gt; q;int main(){    ios::sync_with_stdio(false);    cin.tie(0);    cout.tie(0);        cin &gt;&gt; n &gt;&gt; k;         for (int i = 1; i &lt;= n; i ++ ) cin &gt;&gt; a[i];        // 第一遍维护最小值    for (int i = 1; i &lt;= n; i ++ )    {        // 窗口外的出队        while (q.size() &amp;&amp; q.front() &lt; i - k + 1) q.pop_front();                // 维护新队列\t\twhile (q.size() &amp;&amp; a[q.back()] &gt;= a[i]) q.pop_back();        q.push_back(i);                // 判断是否要输出        if (i &gt;= k) cout &lt;&lt; a[q.front()] &lt;&lt; \" \";\t}    cout &lt;&lt; endl;        // 第二遍维护最大值    while (q.size()) q.pop_back();    for (int i = 1; i &lt;= n; i ++ )    {        while (q.size() &amp;&amp; q.front() &lt; i - k + 1) q.pop_front();        while (q.size()  &amp;&amp; a[q.back()] &lt;= a[i]) q.pop_back();        q.push_back(i);                if (i &gt;= k) cout &lt;&lt; a[q.front()] &lt;&lt; \" \";         \t}        return 0;}\n\n\n\n\n\n进阶一点\n洛谷P2216  理想的正方形洛谷P3422 LOT-A Journey to Mars洛谷P2627 Mowing the Lawn G ","slug":"单调队列与单调栈","date":"2024-09-26T05:09:03.000Z","categories_index":"数据结构","tags_index":"单调队列,单调栈","author_index":"Jerry"},{"id":"c18469ab20e7b093d36b4a61728d07eb","title":"并查集","content":"并查集（Union-Find）概述并查集是一种高效的数据结构，以多棵树的形式存储，每棵树有一个被打上标记的根节点\n主要用途：\n\n合并两个集合\n查询元素所属的集合\n\n常见题型：\n\n朴素并查集\n带权并查集\n维护size并查集\n\n数据结构并查集通常使用三个数组实现：\n\np[] (parent)数组：记录每个元素的父节点。\nd[] (distanse)数组：记录每个元素到父节点距离\nsize[]数组：记录每个并查集的大小\n\nps:虽然并查集在逻辑结构上是一棵棵在同一集合的树，但是存储结构仍可以用普通的数组实现\n操作1.建立初始化并查集\n并查集根节点root:的标记方式p[root] = root\n表示根节点的父节点就是自己\n123456void init()&#123;\t// 一开始每个节点各自为营\tfor (int i = 1; i &lt;= n; i ++ )\t\tp[i] = i;&#125; \n\n2.查找查找元素 x 所在集合的根节点：\n这里有个优化，利用递归在查找的时候就直接把每个节点的父节点压缩向了祖宗节点，此时距离d也更新为了到父节点(祖宗节点)的距离\n1234567891011int find(int x)&#123;    if (p[x] != x) p[x] = find(p[x]);    // p[x]效果为找x的祖宗节点    // 这里调用p[x] = find(p[x])直接让x的父节点指向了p[x]的祖宗节点    // 经过层层递归会最终指向整棵树的根节点    int root = find(p[x]);     // 先要存root是因为只有先跑find()才能让d[p[x]]变为p[x]到祖宗节点的距离    d[x] += d[p[x]];    return root;&#125;\n\n3.合并合并两棵树：\n12345678910111213void merge(int x, int y)&#123;\t// 找出两棵树的根节点\tint px = find(x), py = find(y);\t\t// 根节点不同才需要合并\tif (px != py)     &#123;\t\tp[px] = py;        size[py] += size[px];        // 可能还需要对d[px]进行操作,具体情形依题目而定\t&#125;&#125;\n\n至此，并查集的基本操作均已介绍完毕，操作简洁作用大，用处这么大的数据结构上哪里找呀~\n来几道例题尝试尝试~\n例题朴素并查集\n洛谷 P3367 【模板】并查集\n\n\n维护size的并查集\n洛谷P1455 搭配购买\n\n\n维护到祖宗节点距离的并查集(带权并查集)\n 洛谷P1196 银河英雄传说\n 洛谷P2024食物链 \n\n\n如果文中有任何错误之处，欢迎大家在评论区批评指正！🙏\n\n\n\n","slug":"并查集","date":"2024-09-26T05:08:52.000Z","categories_index":"数据结构","tags_index":"并查集","author_index":"Jerry"},{"id":"a448dfd8ebb4408d1633f0dff8411f1c","title":"线段树","content":"线段树（Segment Tree）概述线段树是一种高效的数据结构，用于解决区间查询和更新问题。它能够在 (O(\\log n)) 时间复杂度内完成以下操作：\n\n查询区间和\n更新区间元素\n\n线段树特别适用于需要频繁处理区间查询和动态更新的场景。\n数据结构线段树通常使用完全二叉树的形式存储，节点表示数组的不同区间。假设原数组为 A，线段树为 ST，则每个节点 ST[node] 表示数组 A 的某个区间的值。\n操作1. 建树操作构建线段树的过程如下：\ndef build(A, ST, node, start, end):\n    if start == end:\n        ST[node] = A[start]  # 叶子节点\n    else:\n        mid = (start + end) // 2\n        build(A, ST, 2 * node + 1, start, mid)  # 构建左子树\n        build(A, ST, 2 * node + 2, mid + 1, end)  # 构建右子树\n        ST[node] = ST[2 * node + 1] + ST[2 * node + 2]  # 计算节点值\n","slug":"线段树","date":"2024-09-26T05:05:40.000Z","categories_index":"数据结构","tags_index":"线段树","author_index":"Jerry"},{"id":"7ff326fdf142ec1868a8e7b87c57157c","title":"基础数据结构","content":"基础数据结构前言本文旨在帮助读者理解几种基本数据结构的原理,并能将数据结构充分的运用到算法题目当中\n介绍的数据结构均会以数组的形式模拟 \n 相对于传统用类/结构体的形式书写,这样虽然会导致一部分空间的浪费,但避免了复杂的指针处理并且各种操作的速度更快,在算法题中具有相当的优势\n闲言少叙,让我们开始吧!\n一、链表1.单链表介绍在算法题中,单链表常以邻接表的形式,用来存储图和树\n此外,拉链法创建哈希表也是以单链表的形式组织起来的\n结构 存当前节点的值\n  存当前节点的下一个节点的序号(相当于地址),当指向链表尾时为-1\n 总节点数量(包括被删除的) \n  存头节点的序号(相当于地址)\n操作1.初始化     \n12345void init(){\thead = -1; // 头节点为空\tidx = 0;   // 当前链表节点数为0}\n\n2.把新结点插到最前面     \n12345678// 头插xvoid add_to_head(int x){\te[idx] = x; \t\t// 建立新节点,唯一序号为idx(第idx+1个点序号为idx)→这个唯一序号等价于地址\tne[idx] = head;\t\t// 指向原本的头\thead = idx; \t\t// 换头\tidx ++ ; \t\t\t// 总节点数量+1}\n\n3.把新结点放到第k个插入的节点后     \n12345678// 中间插void add(int k, int x){\te[idx] = x;\tne[idx] = ne[k];\tne[k] = idx;    idx ++ ;}\n\n4.删除第  个插入节点     \n1234void remove(int k){\tne[k - 1] = ne[k];}\n\n有些题目描述的插入删除操作可能这里的不一样\n实际上这些具体操作并不会直接考出来，在算法题中数据结构的根本是用来帮助存储并尽可能降低时间复杂度，不会作为算法本身来考,关键是要理解运用\n2.双链表结构头节点占第  格,尾节点占第  格\n 当前节点的值\n 当前节点前一个节点的序号\n  当前节点后一个节点的序号\n 总节点数量(包括被删除的)\n  头节点序号\n操作1.初始化     \n123456void init(){\t// 头节点0,尾节点1\tr[0] = 1, l[1] = 0;\tidx = 2; // 初始链表就有头尾2个节点}\n\n2.在第  个插入的节点右端插入       \n1234567void insert(int k, int x){    e[idx] = x;    l[idx] = k, r[idx] = r[a];    l[r[a]] = idx, r[a] = idx;    idx ++ ;}\n\n2.删除第  个插入的节点     \n12345void remove(int k){    l[r[k]] = l[a];    r[l[a]] = r[a];}\n\n\n\n二、栈和队列1.栈介绍先进后出\n常在  (深搜)用于存储一组可行解\n拓展  单调栈\n结构  栈本身\n 栈顶 \n操作12345678910111213int stk[N], tt = 0; // tt表示栈顶// pushstk[ ++ tt] = x;// poptt -- ;//top;stk[tt];// isEmpty;return tt &lt;= 0;\n\n\n\n例题洛谷P1739 表达式括号匹配\n洛谷P1981表达式求值\n2.队列介绍先进先出\n常在  (宽搜)里用于存储一整层甚至多层节点\n拓展  单调队列\n结构 队列本身\n 队头\n  队尾\n操作12345678910111213int q[N], hh = 0, tt = -1; // hh表示队头, tt表示队尾// pushq[ ++ tt] = x;// pophh ++ ;// frontq[hh];// isEmptyreturn tt &lt; hh;\n\n\n\n例题洛谷B3616 【模板】队列\n三、堆为节约篇幅，这里以小根堆为例,大根堆性质相反\n性质1.是一棵二叉树,除最下一层节点其他全满,最下一层从左排到右\n2.每个点均  左右子节点\n4.3.根节点一定为堆中最小的节点\n如图\n\n\n\n\n结构堆也可以用数组来存\n 堆本身\n 第  个插入的点在堆中的序号\n  堆中序号为k的点是第几个插入的\n  堆中节点数\n建堆时,默认  的左子节点序号  ,  的右子节点序号 \n操作最关键只有2个操作,其余操作均可由这两个操作’拼’出来 \n说明:由于小根堆要求父节点&gt;=左右子节点,当子节点,当子节点的值发生改变,可能会违背这一性质,则需要将修改后的节点上放/下放 \n\n上放第  点     \n下放第  点     \n123456789101112131415161718192021222324252627282930313233// 交换两个点,及其映射关系void heap_swap(int a, int b){\t    // 交换堆中序号为a,b的点    swap(ph[hp[a]], ph[hp[b]]);    swap(hp[a], hp[b]);    swap(h[a], h[b]);}void up(int x){    // 子节点x&lt;父节点,需要上放x    while (x / 2 &amp;&amp; h[x] &lt; h[x / 2])    {        // 一直和父节点交换直至满足要求        heap_swap(x, x / 2);        x &gt;&gt;= 1;\t}}void down(int x){    int t = x;    if (x * 2 &lt;= size &amp;&amp; h[x * 2] &lt; h[t]) t = x * 2;    if (x * 2 + 1 &lt;= size &amp;&amp; h[x * 2 + 1] &lt; h[t]) t = x * 2 + 1;    if (x != t)    {        // 不满足规则,需要和子节点交换        heap_swap(u, t);        // 有可能还要继续下放        down(t);\t}}\n\n\n1.插入       \n123456// 先插到最下一层,然后往上放void insert(int x){\theap[++size] = x;\tup(size);}\n\n2.求最小值   \n3.删除最小值     \n12345// 把堆顶换成堆尾的值,然后把它下放,size-1void delete(){    heap[1] = heap[size], size --, down(1);}\n\n删除第个节点\n12345// 思路同上,只不过换完之后可能需要上可能需要下,两个都做一遍保险一点void remove(int k){    heap[k] = heap[size], size --, down(k), up(k);}\n\n修改第个节点\n123456// 改,上放一遍,下放一遍void modify(int k, int x){\theap[k] = x;\tup(k), down(k);}\n\n\n\n例题洛谷P3378 堆\n","slug":"基础数据结构","date":"2024-09-26T05:01:20.000Z","categories_index":"数据结构","tags_index":"链表,栈,队列,堆","author_index":"Jerry"},{"id":"36ef81d64d1d0edc64820d5afd16a0b4","title":"树状数组","content":"树状数组（Fenwick Tree）概述树状数组是一种用于高效处理动态数组中前缀和查询的数据结构。它能够在 (O(\\log n)) 时间复杂度内完成以下操作：\n\n更新数组中的元素O(logn)\n查询数组前缀和O(logn)\n\n数组： O(1) 更新，O(n) 前缀和\n前缀和数组：  O(n) 更新，O(1) 前缀和\n如果问题同时要大量更新和求前缀和，上述两种数据结构均会寄掉\n树状数组则采取折中思路，把整体复杂度降低至O(logn)\n数据结构先放张整体结构图：\n\n\n\n\n核心思想：二进制\n对任意数x可将其二进制分解\n其中\n从而将区间(0, x]分为以下几个部分：\n长度\n长度\n长度\n长度\n容易发现，对于任意一段区间(L,R]\n区间长度为lowbit(x),区间左端点L = R - lowbit(R)\n则在上述规则下，只要确定右端点，左端点的信息也唯一确定\n\n树状数组用一个数组来存储序列的信息:\ntr[x]：存储序列在[x - lowbit(x) + 1, x]之间的数的片段和\n则按照前面的区间划分规则\n\n看到公式的第三行，很容易想到可以用递归来实现，只需每层往下不断-lowbit(t)就行\nx最多只有logx位1，所以树状数组求前缀和的操作复杂度是O(logn)\n类似的，若要实现在原数组第x位上添加c均需添加c(可能这个结论不是那么明显，读者可自行思考其中的原理，后续笔者将补充上证明)\n当然这里不会无穷往后面加，我们只需用到1~n的数据，当加到超过n就可以停了，故整该操作的复杂度仍旧为O(logn)（分析同求和\n一个更容易理解的视频讲解\n操作1. lowbit运算复杂度：O(1)\n代码如下，大家可以自行找几个数验证一下\n12345int lowbit(int x){    // 取出x的最后一位1    return x &amp; -x;}\n\n\n\n2.添加复杂度：O(logn)\n123456int add(int x, int c){\t// 向第x位添加c,c可正可负\t// 对所有含第x位的树节点均加上c\tfor (int i = X; i &lt;= n; i += lowbit(i)) tr[i] += c;}\n\n\n\n3.前缀和复杂度：O(logn)\n1234567int sum(int x){\t// 对第1~x位求和\t// 计算当前数存的值,然后迭代求剩余节点的值\tif (!x) return 0;\treturn tr[x] + sum(x - lowbit(x));}\n\n\n\n\n\n例题洛谷 P10589 楼兰图腾\n\n题目\n题目描述\n在完成了分配任务之后，西部 314 来到了楼兰古城的西部。相传很久以前这片土地上（比楼兰古城还早）生活着两个部落，一个部落崇拜尖刀（V），一个部落崇拜铁锹（∧），他们分别用 V 和 ∧ 的形状来代表各自部落的图腾。\n西部 314 在楼兰古城的下面发现了一幅巨大的壁画，壁画上被标记出了  个点，经测量发现这  个点的水平位置和竖直位置是两两不同的。西部 314 认为这幅壁画所包含的信息与这  个点的相对位置有关，因此不妨设坐标分别为 ，其中  是  到  的一个排列。\n\n如图，图中的 ，，，，。\n西部 314 打算研究这幅壁画中包含着多少个图腾，其中 V 图腾的定义如下（注意：图腾的形式只和这三个纵坐标的相对大小排列顺序有关） 且 , ；\n而崇拜 ∧ 的部落的图腾被定义为  且 ，；\n西部 314 想知道，这  个点中两个部落图腾的数目。因此，你需要编写一个程序来求出 V 的个数和 ∧ 的个数。\n输入\n第一行一个正整数 ；\n第二行是  个正整数，分别代表 ​。\n，答案不超过 。\n输出\n输出两个数，中间用空格隔开，依次为 V 的个数和 ∧ 的个数\n样例输入 #1\n1251 5 3 2 4\n\n样例输出 #1\n13 4\n\n\n\n\n题解\n思路\n对字形图腾，只需要知道每个点前后各有多少个比它高的字形反之\n朴素思路是枚举到第个点，再一一枚举前后比它高的元素复杂度需要优化\n想象有这么一个的数轴我从左往右一一读取每个点读完一个点就在数轴上标记 \n则每个点左边比自己高的点数量其实就是前缀和\n而右边的只需从右往左一一读取再来一遍就行\n\n然而这个前缀数组需要一直修改尽管我们可以用的时间读出高点但是需要的时间去维护它\n复杂度仍旧是这就让我们想到了树状数组更新和求和复杂度均为\n树状数组优化后复杂度变为满足要求\n代码如下\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// 利用树状数组存储某个数左/右 大于/小于它自己的数的数量#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;const int N = 2e5 + 10;int n;int a[N];int tr[N];int gre[N], low[N]; // 存储LL res1, res2;inline int lowbit(int x){    return x &amp; (-x);}inline int sum(int x){    // 求前x项的和    if (!x) return 0;    return tr[x] + sum(x - lowbit(x));}inline void add(int x, int c){    for (int i = x; i &lt;= n; i += lowbit(i)) tr[i] += c;}int main(){    scanf(\"%d\", &amp;n);        for (int i = 1; i &lt;= n; i ++ )        scanf(\"%d\", &amp;a[i]);            // 从左到右来一遍    for (int i = 1; i &lt;= n; i ++ )    {        int y = a[i];        gre[i] = sum(n) - sum(y); // 统计在i左边y + 1到n的数的数量        low[i] = sum(y - 1); // 统计在i左边1到y - 1的数的数量        add(y, 1); // 插入这个数    }        memset(tr, 0, sizeof tr);        // 从右到左再来一遍    for (int i = n; i; i --)    {        int y = a[i];        res1 += (LL)gre[i] * (sum(n) - sum(y));        res2 += (LL)low[i] * (sum(y - 1));        add(y, 1);    }            printf(\"%lld %lld\", res1, res2);        return 0;    }\n\n\n\nPOJ 2182 迷路的奶牛  从后往前慢慢确定每头牛高度树状数组前缀和二分\nPOJ 3468  A Simple Problem with Integers  维护两个前缀和数组的树状数组\n\n\n如果文中有任何错误之处，欢迎大家在评论区批评指正！🙏\n\n\n\n","slug":"树状数组","date":"2024-09-26T04:54:35.000Z","categories_index":"数据结构","tags_index":"树状数组,lowbit,前缀和","author_index":"Jerry"},{"id":"8038215b5c2b5aa82664c7d7c50d2cdc","title":"二分","content":"二分\n\n\n\n\n\n\n注意\n❗❗❗❗二分查找的前提是被查找的数据必须有二段性\n\n如何理解这句话呢？\n举个例子，在数组[1, 5 , 8, 9, 23, 25, 40]里找9\n我可以让check标准为&lt;=9，则转化为找数组中&lt;=9最大值\n对于9左边的数，均小于等于9,而对于9右边的数，均大于9\n目标答案的两边一边满足check一边不满足check，这便是二段性的含义\n绝大多数时候，二段性均不明显，需要通过自行定义check标准把二段性弄出来，需要积累一定的题量\n核心思想二分查找通过不断缩小查找范围，每次将范围缩小一半，最终定位目标元素的位置。\n算法思路\n初始化边界\n\n进入二分，check(mid)\n\n重复操作\n\n\n核心：不断折半折半查找的关键在于通过不断折半查找区间，可以大幅度减少查找次数，效率为 O(log n)\n代码模板：二分的模板不唯一，关键就是要判断好循环终止条件和划分好折半区间的边界，避免死循环\n这里放一个我一直在用的模板\n整数二分\n123456789101112131415161718192021// 模板1：check选左bool check(int x){\t// 定义check标准\tif (……) return false;\treturn true;}int main(){    int l = L, r = R; // 初始化边界    int mid;    while (l &lt; r)    {        mid = l + r &gt;&gt; 1;        if (check(mid)) r = mid;        else l = mid + 1;    }    cout &lt;&lt; l &lt;&lt; endl;}\n\n123456789101112131415161718192021// 模板2: check选右bool check(int x){\t// 定义check标准\tif (……) return false;\treturn true;}int main(){    int l = L, r = R;    int mid;    while (l &lt; r)    {        mid = l + r + 1 &gt;&gt; 1;        if (check(mid)) l = mid;        else r = mid - 1;    }    cout &lt;&lt; l &lt;&lt; endl;}\n\n\n\n小数二分\n12345678910111213141516171819bool check(double x){\t// 定义check标准\tif (……) return false;\treturn true;}int main(){\tconst double eps = 1e-6; // 设置精度\tdouble l = L, r = R;\tdouble mid;\twhile (r - l &gt; eps)    {    \tmid = (l + r) / 2;    \tif (check(mid)) r = mid;    \telse l = mid;    }}\n\n\n\n例题洛谷P1083 借教室\n\n题目\n题目描述\n在大学期间，经常需要租借教室。大到院系举办活动，小到学习小组自习讨论，都需要向学校申请借教室。教室的大小功能不同，借教室人的身份不同，借教室的手续也不一样。\n面对海量租借教室的信息，我们自然希望编程解决这个问题。\n我们需要处理接下来  天的借教室信息，其中第  天学校有  个教室可供租借。共有  份订单，每份订单用三个正整数描述，分别为 ，表示某租借者需要从第  天到第  天租借教室（包括第  天和第  天），每天需要租借  个教室。\n我们假定，租借者对教室的大小、地点没有要求。即对于每份订单，我们只需要每天提供  个教室，而它们具体是哪些教室，每天是否是相同的教室则不用考虑。\n借教室的原则是先到先得，也就是说我们要按照订单的先后顺序依次为每份订单分配教室。如果在分配的过程中遇到一份订单无法完全满足，则需要停止教室的分配，通知当前申请人修改订单。这里的无法满足指从第  天到第  天中有至少一天剩余的教室数量不足  个。\n现在我们需要知道，是否会有订单无法完全满足。如果有，需要通知哪一个申请人修改订单。\n输入格式\n第一行包含两个正整数 ，表示天数和订单的数量。\n第二行包含  个正整数，其中第  个数为 ，表示第  天可用于租借的教室数量。\n接下来有  行，每行包含三个正整数 ，表示租借的数量，租借开始、结束分别在第几天。\n每行相邻的两个数之间均用一个空格隔开。天数与订单均用从  开始的整数编号。\n\n输出格式\n如果所有订单均可满足，则输出只有一行，包含一个整数 。否则（订单无法完全满足）\n输出两行，第一行输出一个负整数 ，第二行输出需要修改订单的申请人编号。\n样例输入 #1\n123454 3 2 5 4 3 2 1 3 3 2 4 4 2 4\n\n样例输出 #1\n12-1 2\n\n\n\n题解\n思路\n题目给的变量比较多，大致是这个意思：\n已知天的课室数量分布，份订单每份订单交代了天需要个课室\n从第份订单往后处理，判断哪个订单开始满足不了​\n\n朴素想法是枚举第份订单，然后判断加了订单之后天有没有哪天是满足不了的\n复杂度显然需要优化\n刚好二分可以带来一个的优化，刚好在允许范围内\n\n二分思路：无法满足的最早的一笔订单 \n这份订单前的订单都可以满足包括这份订单之后的都无法满足符合二段性\n这里可以用差分组优化来存储前份订单的数据\n代码如下：\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;typedef long long LL;const int N = 1e6 + 10;int n, m;LL R[N]; // 每天的课室数LL b[N]; // n天需要教室数量的差分数组struct {\tLL d;\tint s, t;} T[N]; // 订单bool check(int x){\t// 判断前x份订单是否能满足\t// 重置差分数组\tmemset(b, 0, sizeof b);\tfor (int i = 1; i &lt;= x; i++)\t\tb[T[i].s] += T[i].d, b[T[i].t + 1] -= T[i].d;\t// 差分数组求前缀和得每天需求量\tfor (int i = 1; i &lt;= n; i++) b[i] += b[i - 1];\t// 检测是否哪天完不成\tfor (int i = 1; i &lt;= n; i++)\t\tif (b[i] &gt; R[i]) return true;\treturn false;}int main(){\tios::sync_with_stdio(false);\tcin.tie(0);\tcout.tie(0);\tcin &gt;&gt; n &gt;&gt; m;\tfor (int i = 1; i &lt;= n; i++) cin &gt;&gt; R[i];\tfor (int i = 1; i &lt;= m; i++) cin &gt;&gt; T[i].d &gt;&gt; T[i].s &gt;&gt; T[i].t;\t// 开始二分\tint l = 1, r = m + 1;\tint mid;\twhile (l &lt; r)\t{\t\t// 找到无法满足的订单里最小的一笔\t\tmid = l + r &gt;&gt; 1;\t\tif (check(mid)) r = mid;\t\telse l = mid + 1;\t}\t// 都可满足\tif (l == m + 1) puts(\"0\");\telse cout &lt;&lt; -1 &lt;&lt; endl &lt;&lt; l &lt;&lt; endl;\treturn 0;}\n\n\n\n\n洛谷P3743 小鸟的设备\n\n题目\n题目描述\n小鸟有  个可同时使用的设备。第  个设备每秒消耗  个单位能量。能量的使用是连续的，也就是说能量不是某时刻突然消耗的，而是匀速消耗。也就是说，对于任意实数，在  秒内消耗的能量均为  单位。在开始的时候第  个设备里存储着  个单位能量。\n同时小鸟又有一个可以给任意一个设备充电的充电宝，每秒可以给接通的设备充能  个单位，充能也是连续的，不再赘述。你可以在任意时间给任意一个设备充能，从一个设备切换到另一个设备的时间忽略不计。\n小鸟想把这些设备一起使用，直到其中有设备能量降为  。所以小鸟想知道，在充电器的作用下，她最多能将这些设备一起使用多久。\n输入\n第一行给出两个整数 。\n接下来  行，每行表示一个设备，给出两个整数，分别是这个设备的  和 ​。\n，，。\n输出格式\n如果小鸟可以无限使用这些设备，输出 。\n否则输出小鸟在其中一个设备能量降为  之前最多能使用多久。\n设你的答案为 ，标准答案为 ，只有当  满足 的时候，你能得到本测试点的满分。\n样例输入 #1\n1232 12 22 1000\n\n样例输出 #1\n12.0000000000\n\n样例输入 #2\n121 1001 1\n\n样例输出 #2\n1-1\n\n样例输入 #3\n12343 54 35 26 1\n\n样例输出 #3\n10.5000000000\n\n\n\n\n题解\n思路\n能量连续使用，提醒我们这是小数二分\n二分思路找到无法使用的最短时间\n代码如下\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const double eps = 1e-6; //设置精度const int N = 1e5 + 10;int n;double p;double a[N], b[N];bool check(double x){    // 不能完成返回真,能完成返回假    double res = 0;    for (int i = 1; i &lt;= n; i++)    {        res -= min(b[i] - a[i] * x, 0.0);    }    return res &gt; p * x;}int main(){    ios::sync_with_stdio(false);    cin.tie(0);    cout.tie(0);    cin &gt;&gt; n &gt;&gt; p;    for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i] &gt;&gt; b[i];    double l = 0, r = 10000000001; // 设置最大边界,估一下大概在10^10量级    double mid;    while (r - l &gt; eps)    {        // 二分无法使用的最小值        mid = (l + r) / 2;        if (check(mid)) r = mid;        else l = mid;    }    if (r &gt; 10000000000) puts(\"-1\");    else cout &lt;&lt; l &lt;&lt; endl;    return 0;}\n\n\n\n洛谷P9240 冶炼金属 \n\n\n进阶一点\n洛谷P1314 聪明的质监员\n洛谷P1948 Telephone Lines S 找一条连接起点终点的路径，使得第长的边最小分\n\n\n 如果文中有任何错误之处，欢迎大家在评论区批评指正！ 🙏\n\n","slug":"二分","date":"2024-09-26T02:50:13.000Z","categories_index":"算法","tags_index":"基础算法,二分","author_index":"Jerry"},{"id":"2a1893ca085cc0c5b7d1cdcd8c0b1c91","title":"排序","content":"1.快速排序对数组 q 在下标 l 到 r 的范围内进行升序排序。\n快速排序通过多次的比较和交换，在一趟排序之中确定好选择的基准应该在的位置。这个位置满足的条件是：\n\n它的左边的数都小于它。\n它的右边的数都大于它。\n\n之后对左右的区间进行递归排序，最后所有的数都位于它应该在的地方，排序完成。\n排序思路\n确定分界点 x ：\n\n选择 x 为 q[l]、q[r] 或 q[(l + r) / 2] 中的任意一个。\nps: x可以任取，一般取为q[ l + r &gt;&gt; 1]\n\n\n\n调整数组：\n\nq[l] 到 q[x-1] 中的元素都小于 x，\nq[x+1] 到 q[r] 中的元素都大于或等于 x。\n\n\n递归处理子区间：\n\n\n核心操作双指针：\n\n设置两个指针，i 和 j，分别指向当前区间的头和尾。\n两个指针向中间移动，遇到不满足条件的元素(需要交换)时停止。\n交换这两个指针指向的元素，然后继续移动指针，直到它们相遇。\n\n注意事项\n在判断条件时要确保准确，避免死循环→注意前面的最前面的return判断\n确定好每次递归的区间，确保排序的完整性。\n时间复杂度O(nlogn)\n\n代码：12345678910111213141516void quick_sort(int q[], int l, int r)&#123;\tif (l &gt;= r) return; // 排序完成,返回\tint x = q[l + r &gt;&gt; 1], i = l - 1, j = r + 1;\twhile (i &lt; j)    &#123;\t\t// 当两个指针未相遇时,一直移动直至需要交换    \tdo i ++; while(q[i] &lt; x);    \tdo j --; while(q[j] &gt; x);    \tif (i &lt; j) swap(q[i], q[j]); // 交换    \t    \t// 分治子区间    \tquick_sort(q, l, j);    \tquick_sort(q, j + 1, r);    &#125;&#125;\n\n直接理解可能还是有点抽象，也许你会觉得好像寻找分界点让左小又大能有一定的排序作用，但是get不到为什么这样一通操作能保证全体点都严格排好序，找到了张动态图给大家参考一下~\n\n2.归并排序对数组 q 在下标 l 到 r 的范围内进行升序排序。\n核心思想分治\n排序思路\n确定分界点mid：\n\nmid = (l + r) / 2，将数组分为两部分。\n\n\n递归排序：\n\n递归地对 q[l] ~ q[mid] 和 q[mid+1] ~ q[r] 两部分进行排序，此时两部分已各自有序→当前需要进行的操作仅为归并已经排好的两段区间\n\n\n合并：\n\n\n核心操作双指针：\n\n指针分别指向两部分的头部。\n比较两部分当前指针指向的元素，将较小的复制到一个新的数组中。\n当其中一部分复制完后，将另一部分剩余的元素全部复制到新数组。\n将合并后的新数组复制回原数组。\n\n注意事项\n递归时需要确保左右部分的区间划分正确。\n时间复杂度O(nlogn)\n\n代码：12345678910111213141516171819202122232425262728const int N = 1e6 + 10; // 根据具体题目定数量级int tmp[N]; // 用来临时存归并完的数组void merge_sort(int q[], int l, int r)&#123;\tif (l &gt;= r) return; // 排序完成,返回\t\tint mid = l + r &gt;&gt; 1;\t\t// 排序好子区间\tmerge_sort(q, l, mid), merge_sort(q, mid + 1, r);\t\t// 合并\tint i = l, j = mid + 1, k = 0;\tint tmp[N];\twhile (i &lt;= mid &amp;&amp; j &lt;= r)\t&#123;\t\tif (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ];\t\telse tmp[k ++ ] = q[j ++ ];\t&#125;\t\twhile (i &lt;= mid) tmp[k ++ ] = q[i ++ ];\twhile (j &lt;= r) tmp[k ++ ] = q[j ++ ];\t\t// 把排完序的数组拷贝回去\tfor (i = l, k = 0; i &lt;= r;) q[i ++ ] = q[k ++ ];&#125;\n\n归并排序在大一的程设中也有出现喔，这里贴个图模拟一下排序的流程~\n\n排序模板题：洛谷 P1177 归并排序\n洛谷P1908 逆序对\n\n\n 如果文中有任何错误之处，欢迎大家在评论区批评指正！🙏\n\n\n","slug":"排序","date":"2024-09-26T02:05:17.000Z","categories_index":"算法","tags_index":"基础算法,快速排序,归并排序","author_index":"Jerry"},{"id":"b70cb6e2fe5cd3e70bacd823f6f633fc","title":"近期规划","content":"欢迎来到我的小天地！🎉嘿，欢迎来到我的小天地！这是一个属于技术与灵感碰撞的角落，无论你是路过还是驻足，都希望这儿能给你带来点什么有趣的东西。\n关于这个博客这个博客就像是我脑海里的“小宇宙”——技术、算法、科研，以及生活里的灵感火花。我想在这里和大家分享自己的探索，可能会有些前端、后端的技术总结，算法题目挑战的记录，项目笔记及日常随笔。\n你可以期待什么？未来这里会不断更新关于技术的思考、算法题的解题策略，也许还会时不时出现一些歌曲推荐 🎸 或者跑步训练随笔 🏃。你可以期待这里每一篇文章都带来一点灵感和乐趣！\n一起互动吧！如果你对某个技术话题感兴趣，或者也喜欢讨论算法问题，随时留言！我非常期待与你的互动。别害羞，我的评论区永远欢迎你！🙌\n\n好了，不多剧透了，先看文章吧！希望你每次来访都能有所收获，并愿意常来坐坐 😊。\n","slug":"近期规划","date":"2024-09-26T01:49:54.000Z","categories_index":"公告","tags_index":"","author_index":"Jerry"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post1$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server1$ hexo server\n\nMore info: Server\nGenerate static files1$ hexo generate\n\nMore info: Generating\nDeploy to remote sites1$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2024-09-25T08:52:32.921Z","categories_index":"博客","tags_index":"博客部署","author_index":"Jerry"}]